


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > IndexMultiList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: IndexMultiList (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">IndexMultiList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74,1%
  </span>
  <span class="absValue">
    (20/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84,5%
  </span>
  <span class="absValue">
    (87/103)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;package com.esri.core.geometry;
&nbsp;
<b class="fc">&nbsp;class IndexMultiList {</b>
&nbsp;
&nbsp;	StridedIndexTypeCollection m_listNodes; // stores lists and list elements.
&nbsp;											// Each list element is Index, next.
&nbsp;	StridedIndexTypeCollection m_lists; // stores lists. Each list is Head,
&nbsp;										// Tail, [PrevList, NextList].
&nbsp;	int m_list_of_lists;
&nbsp;	boolean m_b_allow_navigation_between_lists;// when False, get_first_list,
&nbsp;												// get_next_list return -1.
&nbsp;
&nbsp;	void freeNode_(int node) {
<b class="fc">&nbsp;		m_listNodes.deleteElement(node);</b>
&nbsp;	}
&nbsp;
&nbsp;	int newNode_() {
<b class="fc">&nbsp;		int node = m_listNodes.newElement();</b>
<b class="fc">&nbsp;		return node;</b>
&nbsp;	}
&nbsp;
&nbsp;	void freeList_(int list) {
<b class="fc">&nbsp;		m_lists.deleteElement(list);</b>
&nbsp;	}
&nbsp;
&nbsp;	int newList_() {
<b class="fc">&nbsp;		int list = m_lists.newElement();</b>
<b class="fc">&nbsp;		return list;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Same as Index_multi_list(true);
<b class="fc">&nbsp;	IndexMultiList() {</b>
<b class="fc">&nbsp;		m_listNodes = new StridedIndexTypeCollection(2);</b>
<b class="fc">&nbsp;		m_lists = new StridedIndexTypeCollection(4);</b>
<b class="fc">&nbsp;		m_list_of_lists = nullNode();</b>
<b class="fc">&nbsp;		m_b_allow_navigation_between_lists = true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// When b_allow_navigation_between_lists is False, the get_first_list and
&nbsp;	// get_next_list do not work.
&nbsp;	// There will be two Index_type elements per list and two Index_type
&nbsp;	// elements per list element
&nbsp;	// When b_allow_navigation_between_lists is True, the get_first_list and
&nbsp;	// get_next_list will work.
&nbsp;	// There will be four Index_type elements per list and two Index_type
&nbsp;	// elements per list element
<b class="nc">&nbsp;	IndexMultiList(boolean b_allow_navigation_between_lists) {</b>
<b class="nc">&nbsp;		m_listNodes = new StridedIndexTypeCollection(2);</b>
<b class="nc">&nbsp;		m_lists = new StridedIndexTypeCollection(</b>
<b class="nc">&nbsp;				b_allow_navigation_between_lists ? 4 : 2);</b>
<b class="nc">&nbsp;		m_list_of_lists = nullNode();</b>
<b class="nc">&nbsp;		m_b_allow_navigation_between_lists = b_allow_navigation_between_lists;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Creates new list and returns it&#39;s handle.
&nbsp;	int createList() {
<b class="fc">&nbsp;		int node = newList_();</b>
<b class="fc">&nbsp;		if (m_b_allow_navigation_between_lists) {</b>
<b class="fc">&nbsp;			m_lists.setField(node, 3, m_list_of_lists);</b>
<b class="fc">&nbsp;			if (m_list_of_lists != nullNode())</b>
<b class="fc">&nbsp;				m_lists.setField(m_list_of_lists, 2, node);</b>
<b class="fc">&nbsp;			m_list_of_lists = node;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return node;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Deletes a list.
&nbsp;	void deleteList(int list) {
<b class="fc">&nbsp;		int ptr = getFirst(list);</b>
<b class="fc">&nbsp;		while (ptr != nullNode()) {</b>
<b class="fc">&nbsp;			int p = ptr;</b>
<b class="fc">&nbsp;			ptr = getNext(ptr);</b>
<b class="fc">&nbsp;			freeNode_(p);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_b_allow_navigation_between_lists) {</b>
<b class="fc">&nbsp;			int prevList = m_lists.getField(list, 2);</b>
<b class="fc">&nbsp;			int nextList = m_lists.getField(list, 3);</b>
<b class="fc">&nbsp;			if (prevList != nullNode())</b>
<b class="fc">&nbsp;				m_lists.setField(prevList, 3, nextList);</b>
&nbsp;			else
<b class="fc">&nbsp;				m_list_of_lists = nextList;</b>
&nbsp;
<b class="fc">&nbsp;			if (nextList != nullNode())</b>
<b class="fc">&nbsp;				m_lists.setField(nextList, 2, prevList);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		freeList_(list);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Reserves memory for the given number of lists.
&nbsp;	void reserveLists(int listCount) {
<b class="fc">&nbsp;		m_lists.setCapacity(listCount);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Adds element to a given list. The element is added to the end. Returns
&nbsp;	// the new
&nbsp;	int addElement(int list, int element) {
<b class="fc">&nbsp;		int head = m_lists.getField(list, 0);</b>
<b class="fc">&nbsp;		int tail = m_lists.getField(list, 1);</b>
<b class="fc">&nbsp;		int node = newNode_();</b>
<b class="fc">&nbsp;		if (tail != nullNode()) {</b>
<b class="fc">&nbsp;			assert (head != nullNode());</b>
<b class="fc">&nbsp;			m_listNodes.setField(tail, 1, node);</b>
<b class="fc">&nbsp;			m_lists.setField(list, 1, node);</b>
<b class="fc">&nbsp;		} else {// empty list</b>
<b class="fc">&nbsp;			assert (head == nullNode());</b>
<b class="fc">&nbsp;			m_lists.setField(list, 0, node);</b>
<b class="fc">&nbsp;			m_lists.setField(list, 1, node);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		m_listNodes.setField(node, 0, element);</b>
<b class="fc">&nbsp;		return node;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Reserves memory for the given number of nodes.
&nbsp;	void reserveNodes(int nodeCount) {
<b class="fc">&nbsp;		m_listNodes.setCapacity(nodeCount);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Deletes a node from a list, given the previous node (previous node is
&nbsp;	// required, because the list is singly connected).
&nbsp;	void deleteElement(int list, int prevNode, int node) {
<b class="fc">&nbsp;		if (prevNode != nullNode()) {</b>
<b class="fc">&nbsp;			assert (m_listNodes.getField(prevNode, 1) == node);</b>
<b class="fc">&nbsp;			m_listNodes.setField(prevNode, 1, m_listNodes.getField(node, 1));</b>
<b class="fc">&nbsp;			if (m_lists.getField(list, 1) == node)// deleting a tail</b>
&nbsp;			{
<b class="fc">&nbsp;				m_lists.setField(list, 1, prevNode);</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			assert (m_lists.getField(list, 0) == node);</b>
<b class="fc">&nbsp;			m_lists.setField(list, 0, m_listNodes.getField(node, 1));</b>
<b class="fc">&nbsp;			if (m_lists.getField(list, 1) == node) {// removing last element</b>
<b class="fc">&nbsp;				assert (m_listNodes.getField(node, 1) == nullNode());</b>
<b class="fc">&nbsp;				m_lists.setField(list, 1, nullNode());</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		freeNode_(node);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Concatenates list1 and list2. The nodes of list2 are added to the end of
&nbsp;	// list1. The list2 index becomes invalid.
&nbsp;	// Returns list1.
&nbsp;	int concatenateLists(int list1, int list2) {
<b class="fc">&nbsp;		int tailNode1 = m_lists.getField(list1, 1);</b>
<b class="fc">&nbsp;		int headNode2 = m_lists.getField(list2, 0);</b>
<b class="fc">&nbsp;		if (headNode2 != nullNode())// do not concatenate empty lists</b>
&nbsp;		{
<b class="fc">&nbsp;			if (tailNode1 != nullNode()) {</b>
&nbsp;				// connect head of list2 to the tail of list1.
<b class="fc">&nbsp;				m_listNodes.setField(tailNode1, 1, headNode2);</b>
&nbsp;				// set the tail of the list1 to be the tail of list2.
<b class="fc">&nbsp;				m_lists.setField(list1, 1, m_lists.getField(list2, 1));</b>
<b class="fc">&nbsp;			} else {// list1 is empty, while list2 is not.</b>
<b class="nc">&nbsp;				m_lists.setField(list1, 0, headNode2);</b>
<b class="nc">&nbsp;				m_lists.setField(list1, 1, m_lists.getField(list2, 1));</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_b_allow_navigation_between_lists) {</b>
<b class="fc">&nbsp;			int prevList = m_lists.getField(list2, 2);</b>
<b class="fc">&nbsp;			int nextList = m_lists.getField(list2, 3);</b>
<b class="fc">&nbsp;			if (prevList != nullNode())</b>
<b class="fc">&nbsp;				m_lists.setField(prevList, 3, nextList);</b>
&nbsp;			else
<b class="fc">&nbsp;				m_list_of_lists = nextList;</b>
&nbsp;
<b class="fc">&nbsp;			if (nextList != nullNode())</b>
<b class="fc">&nbsp;				m_lists.setField(nextList, 2, prevList);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		freeList_(list2);</b>
<b class="fc">&nbsp;		return list1;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the data from the given list node.
&nbsp;	int getElement(int node_index) {
<b class="fc">&nbsp;		return m_listNodes.getField(node_index, 0);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Sets the data to the given list node.
&nbsp;	void setElement(int node_index, int element) {
<b class="nc">&nbsp;		m_listNodes.setField(node_index, 0, element);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns index of next node for the give node.
&nbsp;	int getNext(int node_index) {
<b class="fc">&nbsp;		return m_listNodes.getField(node_index, 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the first node in the least
&nbsp;	int getFirst(int list) {
<b class="fc">&nbsp;		return m_lists.getField(list, 0);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the element from the first node in the least. Equivalent to
&nbsp;	// get_element(get_first(list));
&nbsp;	int getFirstElement(int list) {
<b class="fc">&nbsp;		int f = getFirst(list);</b>
<b class="fc">&nbsp;		return getElement(f);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Check if the node is Null (does not exist)
&nbsp;	static int nullNode() {
<b class="fc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Clears all nodes and removes all lists. Frees the memory.
&nbsp;	void clear() {
<b class="nc">&nbsp;		m_listNodes.deleteAll(true);</b>
<b class="nc">&nbsp;		m_lists.deleteAll(true);</b>
<b class="nc">&nbsp;		m_list_of_lists = nullNode();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns True if the given list is empty.
&nbsp;	boolean isEmpty(int list) {
<b class="nc">&nbsp;		return m_lists.getField(list, 0) == nullNode();</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean isEmpty() {
<b class="nc">&nbsp;		return m_listNodes.size() == 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	int getNodeCount() {
<b class="nc">&nbsp;		return m_listNodes.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	int getListCount() {
<b class="nc">&nbsp;		return m_lists.size();</b>
&nbsp;	}
&nbsp;
&nbsp;	int getFirstList() {
<b class="fc">&nbsp;		assert (m_b_allow_navigation_between_lists);</b>
<b class="fc">&nbsp;		return m_list_of_lists;</b>
&nbsp;	}
&nbsp;
&nbsp;	int getNextList(int list) {
<b class="fc">&nbsp;		assert (m_b_allow_navigation_between_lists);</b>
<b class="fc">&nbsp;		return m_lists.getField(list, 3);</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 15:02</div>
</div>
</body>
</html>
