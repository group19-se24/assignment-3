


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > RelationalOperations</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: RelationalOperations (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">RelationalOperations</td>
<td class="coverageStat">
  <span class="percent">
    98,3%
  </span>
  <span class="absValue">
    (118/120)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,2%
  </span>
  <span class="absValue">
    (2414/2834)
  </span>
</td>
</tr>
  <tr>
    <td class="name">RelationalOperations$Accelerate_helper</td>
<td class="coverageStat">
  <span class="percent">
    66,7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87%
  </span>
  <span class="absValue">
    (20/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RelationalOperations$OverlapComparer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RelationalOperations$OverlapEvent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RelationalOperations$Relation</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    97,6%
  </span>
  <span class="absValue">
    (123/126)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,2%
  </span>
  <span class="absValue">
    (2444/2867)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;
<b class="fc">&nbsp;class RelationalOperations {</b>
&nbsp;	interface Relation {
&nbsp;		static final int contains = 1;
&nbsp;		static final int within = 2;
&nbsp;		static final int equals = 3;
&nbsp;		static final int disjoint = 4;
&nbsp;		static final int touches = 8;
&nbsp;		static final int crosses = 16;
&nbsp;		static final int overlaps = 32;
&nbsp;
&nbsp;		static final int unknown = 0;
&nbsp;		static final int intersects = 0x40000000;
&nbsp;	}
&nbsp;
&nbsp;	static boolean relate(Geometry geometry_a, Geometry geometry_b,
&nbsp;			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		int type_a = geometry_a.getType().value();</b>
<b class="fc">&nbsp;		int type_b = geometry_b.getType().value();</b>
&nbsp;
&nbsp;		// Give preference to the Point vs Envelope, Envelope vs Envelope and
&nbsp;		// Point vs Point realtions:
<b class="fc">&nbsp;		if (type_a == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;			if (type_b == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;				return relate((Envelope) geometry_a, (Envelope) geometry_b, sr,</b>
<b class="fc">&nbsp;						relation, progress_tracker);</b>
<b class="fc">&nbsp;			} else if (type_b == Geometry.GeometryType.Point) {</b>
<b class="fc">&nbsp;				if (relation == Relation.within)</b>
<b class="nc">&nbsp;					relation = Relation.contains;</b>
<b class="fc">&nbsp;				else if (relation == Relation.contains)</b>
<b class="fc">&nbsp;					relation = Relation.within;</b>
&nbsp;
<b class="fc">&nbsp;				return relate((Point) geometry_b, (Envelope) geometry_a, sr,</b>
<b class="fc">&nbsp;						relation, progress_tracker);</b>
&nbsp;			} else {
&nbsp;				// proceed below
&nbsp;			}
<b class="fc">&nbsp;		} else if (type_a == Geometry.GeometryType.Point) {</b>
<b class="fc">&nbsp;			if (type_b == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;				return relate((Point) geometry_a, (Envelope) geometry_b, sr,</b>
<b class="fc">&nbsp;						relation, progress_tracker);</b>
<b class="fc">&nbsp;			} else if (type_b == Geometry.GeometryType.Point) {</b>
<b class="fc">&nbsp;				return relate((Point) geometry_a, (Point) geometry_b, sr,</b>
<b class="fc">&nbsp;						relation, progress_tracker);</b>
&nbsp;			} else {
&nbsp;				// proceed below
&nbsp;			}
&nbsp;		} else {
&nbsp;			// proceed below
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (geometry_a.isEmpty() || geometry_b.isEmpty()) {</b>
<b class="fc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;				return true; // Always true</b>
&nbsp;
<b class="fc">&nbsp;			return false; // Always false</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env1 = new Envelope2D();</b>
<b class="fc">&nbsp;		geometry_a.queryEnvelope2D(env1);</b>
<b class="fc">&nbsp;		Envelope2D env2 = new Envelope2D();</b>
<b class="fc">&nbsp;		geometry_b.queryEnvelope2D(env2);</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D envMerged = new Envelope2D();</b>
<b class="fc">&nbsp;		envMerged.setCoords(env1);</b>
<b class="fc">&nbsp;		envMerged.merge(env2);</b>
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</b>
<b class="fc">&nbsp;				envMerged, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeDisjointEnvelope_(env1, env2, tolerance, progress_tracker)) {</b>
<b class="fc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		boolean bRelation = false;</b>
&nbsp;
&nbsp;		Geometry _geometry_a;
&nbsp;		Geometry _geometry_b;
&nbsp;		Polyline polyline_a, polyline_b;
&nbsp;
<b class="fc">&nbsp;		if (MultiPath.isSegment(type_a)) {</b>
<b class="nc">&nbsp;			polyline_a = new Polyline(geometry_a.getDescription());</b>
<b class="nc">&nbsp;			polyline_a.addSegment((Segment) geometry_a, true);</b>
<b class="nc">&nbsp;			_geometry_a = polyline_a;</b>
<b class="nc">&nbsp;			type_a = Geometry.GeometryType.Polyline;</b>
<b class="nc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_geometry_a = geometry_a;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (MultiPath.isSegment(type_b)) {</b>
<b class="nc">&nbsp;			polyline_b = new Polyline(geometry_b.getDescription());</b>
<b class="nc">&nbsp;			polyline_b.addSegment((Segment) geometry_b, true);</b>
<b class="nc">&nbsp;			_geometry_b = polyline_b;</b>
<b class="nc">&nbsp;			type_b = Geometry.GeometryType.Polyline;</b>
<b class="nc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_geometry_b = geometry_b;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (type_a != Geometry.GeometryType.Envelope</b>
<b class="fc">&nbsp;				&amp;&amp; type_b != Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;			if (_geometry_a.getDimension() &lt; _geometry_b.getDimension()</b>
<b class="fc">&nbsp;					|| (type_a == Geometry.GeometryType.Point &amp;&amp; type_b == Geometry.GeometryType.MultiPoint)) {// we</b>
&nbsp;																												// will
&nbsp;																												// switch
&nbsp;																												// the
&nbsp;																												// order
&nbsp;																												// of
&nbsp;																												// the
&nbsp;																												// geometries
&nbsp;																												// below.
<b class="fc">&nbsp;				if (relation == Relation.within)</b>
<b class="fc">&nbsp;					relation = Relation.contains;</b>
<b class="fc">&nbsp;				else if (relation == Relation.contains)</b>
<b class="fc">&nbsp;					relation = Relation.within;</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			if (type_a != Geometry.GeometryType.Polygon</b>
<b class="fc">&nbsp;					&amp;&amp; type_b != Geometry.GeometryType.Envelope) { // we will</b>
&nbsp;																	// switch
&nbsp;																	// the order
&nbsp;																	// of the
&nbsp;																	// geometries
&nbsp;																	// below.
<b class="fc">&nbsp;				if (relation == Relation.within)</b>
<b class="nc">&nbsp;					relation = Relation.contains;</b>
<b class="fc">&nbsp;				else if (relation == Relation.contains)</b>
<b class="fc">&nbsp;					relation = Relation.within;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		switch (type_a) {</b>
&nbsp;		case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;			switch (type_b) {</b>
&nbsp;			case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;				bRelation = polygonRelatePolygon_((Polygon) (_geometry_a),</b>
<b class="fc">&nbsp;						(Polygon) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;				bRelation = polygonRelatePolyline_((Polygon) (_geometry_a),</b>
<b class="fc">&nbsp;						(Polyline) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Point:
<b class="fc">&nbsp;				bRelation = polygonRelatePoint_((Polygon) (_geometry_a),</b>
<b class="fc">&nbsp;						(Point) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;				bRelation = polygonRelateMultiPoint_((Polygon) (_geometry_a),</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Envelope:
<b class="fc">&nbsp;				bRelation = polygonRelateEnvelope_((Polygon) (_geometry_a),</b>
<b class="fc">&nbsp;						(Envelope) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			default:
&nbsp;				break; // warning fix
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;
&nbsp;		case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;			switch (type_b) {</b>
&nbsp;			case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;				bRelation = polygonRelatePolyline_((Polygon) (_geometry_b),</b>
<b class="fc">&nbsp;						(Polyline) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;				bRelation = polylineRelatePolyline_((Polyline) (_geometry_a),</b>
<b class="fc">&nbsp;						(Polyline) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Point:
<b class="fc">&nbsp;				bRelation = polylineRelatePoint_((Polyline) (_geometry_a),</b>
<b class="fc">&nbsp;						(Point) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;				bRelation = polylineRelateMultiPoint_((Polyline) (_geometry_a),</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Envelope:
<b class="fc">&nbsp;				bRelation = polylineRelateEnvelope_((Polyline) (_geometry_a),</b>
<b class="fc">&nbsp;						(Envelope) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			default:
&nbsp;				break; // warning fix
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;
&nbsp;		case Geometry.GeometryType.Point:
<b class="fc">&nbsp;			switch (type_b) {</b>
&nbsp;			case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;				bRelation = polygonRelatePoint_((Polygon) (_geometry_b),</b>
<b class="fc">&nbsp;						(Point) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;				bRelation = polylineRelatePoint_((Polyline) (_geometry_b),</b>
<b class="fc">&nbsp;						(Point) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;				bRelation = multiPointRelatePoint_((MultiPoint) (_geometry_b),</b>
<b class="fc">&nbsp;						(Point) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			default:
&nbsp;				break; // warning fix
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;
&nbsp;		case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;			switch (type_b) {</b>
&nbsp;			case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;				bRelation = polygonRelateMultiPoint_((Polygon) (_geometry_b),</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;				bRelation = polylineRelateMultiPoint_((Polyline) (_geometry_b),</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;				bRelation = multiPointRelateMultiPoint_(</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_a), (MultiPoint) (_geometry_b),</b>
<b class="fc">&nbsp;						tolerance, relation, progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Point:
<b class="fc">&nbsp;				bRelation = multiPointRelatePoint_((MultiPoint) (_geometry_a),</b>
<b class="fc">&nbsp;						(Point) (_geometry_b), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Envelope:
<b class="fc">&nbsp;				bRelation = multiPointRelateEnvelope_(</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_a), (Envelope) (_geometry_b),</b>
<b class="fc">&nbsp;						tolerance, relation, progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			default:
&nbsp;				break; // warning fix
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;
&nbsp;		case Geometry.GeometryType.Envelope:
<b class="fc">&nbsp;			switch (type_b) {</b>
&nbsp;			case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;				bRelation = polygonRelateEnvelope_((Polygon) (_geometry_b),</b>
<b class="fc">&nbsp;						(Envelope) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.Polyline:
<b class="fc">&nbsp;				bRelation = polylineRelateEnvelope_((Polyline) (_geometry_b),</b>
<b class="fc">&nbsp;						(Envelope) (_geometry_a), tolerance, relation,</b>
<b class="fc">&nbsp;						progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			case Geometry.GeometryType.MultiPoint:
<b class="fc">&nbsp;				bRelation = multiPointRelateEnvelope_(</b>
<b class="fc">&nbsp;						(MultiPoint) (_geometry_b), (Envelope) (_geometry_a),</b>
<b class="fc">&nbsp;						tolerance, relation, progress_tracker);</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
&nbsp;			default:
&nbsp;				break; // warning fix
&nbsp;			}
<b class="nc">&nbsp;			break;</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return bRelation;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Computes the necessary 9 intersection relationships of boundary,
&nbsp;	// interior, and exterior of envelope_a vs envelope_b for the given
&nbsp;	// relation.
&nbsp;	private static boolean relate(Envelope envelope_a, Envelope envelope_b,
&nbsp;			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (envelope_a.isEmpty() || envelope_b.isEmpty()) {</b>
<b class="nc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;				return true; // Always true</b>
&nbsp;
<b class="nc">&nbsp;			return false; // Always false</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), env_merged = new Envelope2D();</b>
<b class="fc">&nbsp;		envelope_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_merged.setCoords(env_a);</b>
<b class="fc">&nbsp;		env_merged.merge(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</b>
<b class="fc">&nbsp;				env_merged, false);</b>
&nbsp;
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return envelopeDisjointEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="nc">&nbsp;			return envelopeContainsEnvelope_(env_b, env_a, tolerance,</b>
<b class="nc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return envelopeContainsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return envelopeTouchesEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return envelopeOverlapsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return envelopeCrossesEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Computes the necessary 9 intersection relationships of boundary,
&nbsp;	// interior, and exterior of point_a vs envelope_b for the given relation.
&nbsp;	private static boolean relate(Point point_a, Envelope envelope_b,
&nbsp;			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (point_a.isEmpty() || envelope_b.isEmpty()) {</b>
<b class="nc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;				return true; // Always true</b>
&nbsp;
<b class="nc">&nbsp;			return false; // Always false</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Point2D pt_a = point_a.getXY();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D(), env_merged = new Envelope2D();</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_merged.setCoords(pt_a);</b>
<b class="fc">&nbsp;		env_merged.merge(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</b>
<b class="fc">&nbsp;				env_merged, false);</b>
&nbsp;
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return pointDisjointEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return pointWithinEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return pointContainsEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return pointEqualsEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return pointTouchesEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Computes the necessary 9 intersection relationships of boundary,
&nbsp;	// interior, and exterior of point_a vs point_b for the given relation.
&nbsp;	private static boolean relate(Point point_a, Point point_b,
&nbsp;			SpatialReference sr, int relation, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (point_a.isEmpty() || point_b.isEmpty()) {</b>
<b class="fc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;				return true; // Always true</b>
&nbsp;
<b class="fc">&nbsp;			return false; // Always false</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Point2D pt_a = point_a.getXY();</b>
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		Envelope2D env_merged = new Envelope2D();</b>
<b class="fc">&nbsp;		env_merged.setCoords(pt_a);</b>
<b class="fc">&nbsp;		env_merged.merge(pt_b);</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(sr,</b>
<b class="fc">&nbsp;				env_merged, false);</b>
&nbsp;
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return pointDisjointPoint_(pt_a, pt_b, tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return pointContainsPoint_(pt_b, pt_a, tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return pointContainsPoint_(pt_a, pt_b, tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polygonRelatePolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polygonDisjointPolygon_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return polygonContainsPolygon_(polygon_b, polygon_a, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polygonContainsPolygon_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return polygonEqualsPolygon_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polygonTouchesPolygon_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return polygonOverlapsPolygon_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polygonRelatePolyline_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polygonDisjointPolyline_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polygonContainsPolyline_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polygonTouchesPolyline_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return polygonCrossesPolyline_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polygonRelatePoint_(Polygon polygon_a,
&nbsp;			Point point_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polygonDisjointPoint_(polygon_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polygonContainsPoint_(polygon_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polygonTouchesPoint_(polygon_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds
&nbsp;	private static boolean polygonRelateMultiPoint_(Polygon polygon_a,
&nbsp;			MultiPoint multipoint_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polygonDisjointMultiPoint_(polygon_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, true, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polygonContainsMultiPoint_(polygon_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polygonTouchesMultiPoint_(polygon_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="nc">&nbsp;			return polygonCrossesMultiPoint_(polygon_a, multipoint_b,</b>
<b class="nc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds
&nbsp;	private static boolean polygonRelateEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (polygonDisjointEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker)) {</b>
<b class="fc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;
<b class="fc">&nbsp;			return false;</b>
<b class="fc">&nbsp;		} else if (relation == Relation.disjoint) {</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.within:
<b class="nc">&nbsp;			return polygonWithinEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="nc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polygonContainsEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return polygonEqualsEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polygonTouchesEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return polygonOverlapsEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return polygonCrossesEnvelope_(polygon_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polylineRelatePolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polylineDisjointPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return polylineContainsPolyline_(polyline_b, polyline_a, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polylineContainsPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return polylineEqualsPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return polylineOverlapsPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polylineRelatePoint_(Polyline polyline_a,
&nbsp;			Point point_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polylineDisjointPoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polylineContainsPoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polylineTouchesPoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polylineRelateMultiPoint_(Polyline polyline_a,
&nbsp;			MultiPoint multipoint_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return polylineDisjointMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polylineContainsMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polylineTouchesMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return polylineCrossesMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean polylineRelateEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (polylineDisjointEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker)) {</b>
<b class="fc">&nbsp;			if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;
<b class="fc">&nbsp;			return false;</b>
<b class="fc">&nbsp;		} else if (relation == Relation.disjoint) {</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return polylineWithinEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return polylineContainsEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return polylineEqualsEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return polylineTouchesEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return polylineOverlapsEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return polylineCrossesEnvelope_(polyline_a, envelope_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean multiPointRelateMultiPoint_(MultiPoint multipoint_a,
&nbsp;			MultiPoint multipoint_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return multiPointDisjointMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return multiPointContainsMultiPoint_(multipoint_b, multipoint_a,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return multiPointContainsMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return multiPointEqualsMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.overlaps:
<b class="fc">&nbsp;			return multiPointOverlapsMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean multiPointRelatePoint_(MultiPoint multipoint_a,
&nbsp;			Point point_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return multiPointDisjointPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return multiPointWithinPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return multiPointContainsPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return multiPointEqualsPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation holds.
&nbsp;	private static boolean multiPointRelateEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance, int relation,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		switch (relation) {</b>
&nbsp;		case Relation.disjoint:
<b class="fc">&nbsp;			return multiPointDisjointEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.within:
<b class="fc">&nbsp;			return multiPointWithinEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.contains:
<b class="fc">&nbsp;			return multiPointContainsEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.equals:
<b class="fc">&nbsp;			return multiPointEqualsEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.touches:
<b class="fc">&nbsp;			return multiPointTouchesEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		case Relation.crosses:
<b class="fc">&nbsp;			return multiPointCrossesEnvelope_(multipoint_a, envelope_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;
&nbsp;		default:
&nbsp;			break; // warning fix
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a equals polygon_b.
&nbsp;	private static boolean polygonEqualsPolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polygon_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains</b>
<b class="fc">&nbsp;				|| relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick point equality check for true equality. This just checks if all
&nbsp;		// the points in each ring are the same (within a tolerance) and in the
&nbsp;		// same order
<b class="fc">&nbsp;		if (multiPathExactlyEqualsMultiPath_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker))</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		double length_a = polygon_a.calculateLength2D();</b>
<b class="fc">&nbsp;		double length_b = polygon_b.calculateLength2D();</b>
<b class="fc">&nbsp;		int max_vertices = Math.max(polygon_a.getPointCount(),</b>
<b class="fc">&nbsp;				polygon_b.getPointCount());</b>
&nbsp;
<b class="fc">&nbsp;		if (Math.abs(length_a - length_b) &gt; max_vertices * 4.0 * tolerance)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from polygon_b.
&nbsp;	private static boolean polygonDisjointPolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</b>
<b class="fc">&nbsp;				tolerance, true);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains || relation == Relation.within</b>
<b class="fc">&nbsp;				|| relation == Relation.intersects)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonDisjointMultiPath_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a touches polygon_b.
&nbsp;	private static boolean polygonTouchesPolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains</b>
<b class="fc">&nbsp;				|| relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a overlaps polygon_b.
&nbsp;	private static boolean polygonOverlapsPolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains</b>
<b class="fc">&nbsp;				|| relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a contains polygon_b.
&nbsp;	private static boolean polygonContainsPolygon_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polygon_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polygon_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from polyline_b.
&nbsp;	private static boolean polygonDisjointPolyline_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, true);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains || relation == Relation.intersects)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonDisjointMultiPath_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a touches polyline_b.
&nbsp;	private static boolean polygonTouchesPolyline_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonTouchesPolylineImpl_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a crosses polyline_b.
&nbsp;	private static boolean polygonCrossesPolyline_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a contains polyline_b.
&nbsp;	private static boolean polygonContainsPolyline_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polyline_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return polygonContainsPolylineImpl_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from point_b.
&nbsp;	private static boolean polygonDisjointPoint_(Polygon polygon_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</b>
<b class="fc">&nbsp;				polygon_a, point_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (result == PolygonUtils.PiPResult.PiPOutside)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true of polygon_a touches point_b.
&nbsp;	private static boolean polygonTouchesPoint_(Polygon polygon_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return polygonTouchesPointImpl_(polygon_a, pt_b, tolerance, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a contains point_b.
&nbsp;	private static boolean polygonContainsPoint_(Polygon polygon_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return polygonContainsPointImpl_(polygon_a, pt_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from multipoint_b.
&nbsp;	private static boolean polygonDisjointMultiPoint_(Polygon polygon_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			boolean bIncludeBoundaryA, ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</b>
<b class="fc">&nbsp;				multipoint_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a_inflated);</b>
<b class="fc">&nbsp;		env_a_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		Point2D ptB = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;			if (!env_a_inflated.contains(ptB))</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</b>
<b class="fc">&nbsp;					polygon_a, ptB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result == PolygonUtils.PiPResult.PiPInside</b>
<b class="fc">&nbsp;					|| (bIncludeBoundaryA &amp;&amp; result == PolygonUtils.PiPResult.PiPBoundary))</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a touches multipoint_b.
&nbsp;	private static boolean polygonTouchesMultiPoint_(Polygon polygon_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</b>
<b class="fc">&nbsp;				multipoint_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;        Envelope2D env_a_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;        polygon_a.queryEnvelope2D(env_a_inflated);</b>
<b class="fc">&nbsp;        env_a_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
&nbsp;        Point2D ptB;
<b class="fc">&nbsp;        boolean b_boundary = false;</b>
&nbsp;
<b class="fc">&nbsp;        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;        Polygon pa = null;</b>
<b class="fc">&nbsp;        Polygon p_polygon_a = polygon_a;</b>
&nbsp;
<b class="fc">&nbsp;        boolean b_checked_polygon_a_quad_tree = false;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</b>
&nbsp;        {
<b class="fc">&nbsp;            ptB = multipoint_b.getXY(i);</b>
&nbsp;
<b class="fc">&nbsp;            if (env_a_inflated.contains(ptB)) {</b>
&nbsp;
<b class="fc">&nbsp;                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;                if (result == PolygonUtils.PiPResult.PiPBoundary)</b>
<b class="fc">&nbsp;                    b_boundary = true;</b>
<b class="fc">&nbsp;                else if (result == PolygonUtils.PiPResult.PiPInside)</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (!b_checked_polygon_a_quad_tree) {</b>
<b class="fc">&nbsp;                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                    pa = new Polygon();</b>
<b class="nc">&nbsp;                    polygon_a.copyTo(pa);</b>
<b class="nc">&nbsp;                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                    p_polygon_a = pa;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    p_polygon_a = polygon_a;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                b_checked_polygon_a_quad_tree = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (b_boundary)</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a crosses multipoint_b.
&nbsp;	private static boolean polygonCrossesMultiPoint_(Polygon polygon_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="nc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</b>
<b class="nc">&nbsp;				multipoint_b, tolerance, false);</b>
&nbsp;
<b class="nc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="nc">&nbsp;        Envelope2D env_a = new Envelope2D(), env_a_inflated = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="nc">&nbsp;        polygon_a.queryEnvelope2D(env_a);</b>
<b class="nc">&nbsp;        multipoint_b.queryEnvelope2D(env_b);</b>
<b class="nc">&nbsp;        env_a_inflated.setCoords(env_a);</b>
<b class="nc">&nbsp;        env_a_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;        boolean b_interior = false, b_exterior = false;</b>
&nbsp;
&nbsp;        Point2D pt_b;
&nbsp;
<b class="nc">&nbsp;        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</b>
&nbsp;
<b class="nc">&nbsp;        Polygon pa = null;</b>
<b class="nc">&nbsp;        Polygon p_polygon_a = polygon_a;</b>
&nbsp;
<b class="nc">&nbsp;        boolean b_checked_polygon_a_quad_tree = false;</b>
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</b>
&nbsp;        {
<b class="nc">&nbsp;            pt_b = multipoint_b.getXY(i);</b>
&nbsp;
<b class="nc">&nbsp;            if (!env_a_inflated.contains(pt_b))</b>
&nbsp;            {
<b class="nc">&nbsp;                b_exterior = true;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;            else
&nbsp;            {
<b class="nc">&nbsp;                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                if (result == PolygonUtils.PiPResult.PiPOutside)</b>
<b class="nc">&nbsp;                    b_exterior = true;</b>
<b class="nc">&nbsp;                else if (result == PolygonUtils.PiPResult.PiPInside)</b>
<b class="nc">&nbsp;                    b_interior = true;</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            if (b_interior &amp;&amp; b_exterior)</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;
<b class="nc">&nbsp;            if (!b_checked_polygon_a_quad_tree) {</b>
<b class="nc">&nbsp;                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                    pa = new Polygon();</b>
<b class="nc">&nbsp;                    polygon_a.copyTo(pa);</b>
<b class="nc">&nbsp;                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                    p_polygon_a = pa;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    p_polygon_a = polygon_a;</b>
&nbsp;                }
&nbsp;
<b class="nc">&nbsp;                b_checked_polygon_a_quad_tree = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a contains multipoint_b.
&nbsp;	private static boolean polygonContainsMultiPoint_(Polygon polygon_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,</b>
<b class="fc">&nbsp;				multipoint_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;        boolean b_interior = false;</b>
&nbsp;        Point2D ptB;
&nbsp;
<b class="fc">&nbsp;        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;        Polygon pa = null;</b>
<b class="fc">&nbsp;        Polygon p_polygon_a = polygon_a;</b>
&nbsp;
<b class="fc">&nbsp;        boolean b_checked_polygon_a_quad_tree = false;</b>
&nbsp;
<b class="fc">&nbsp;        for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</b>
&nbsp;        {
<b class="fc">&nbsp;            ptB = multipoint_b.getXY(i);</b>
&nbsp;
<b class="fc">&nbsp;            if (!env_a.contains(ptB))</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="fc">&nbsp;            PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;            if (result == PolygonUtils.PiPResult.PiPInside)</b>
<b class="fc">&nbsp;                b_interior = true;</b>
<b class="fc">&nbsp;            else if (result == PolygonUtils.PiPResult.PiPOutside)</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;
<b class="fc">&nbsp;            if (!b_checked_polygon_a_quad_tree) {</b>
<b class="fc">&nbsp;                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) &amp;&amp; (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                    pa = new Polygon();</b>
<b class="nc">&nbsp;                    polygon_a.copyTo(pa);</b>
<b class="nc">&nbsp;                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                    p_polygon_a = pa;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    p_polygon_a = polygon_a;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                b_checked_polygon_a_quad_tree = true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return b_interior;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a equals envelope_b.
&nbsp;	private static boolean polygonEqualsEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
&nbsp;		// This check will correctly handle degenerate envelope cases (i.e.
&nbsp;		// degenerate to point or line)
<b class="fc">&nbsp;		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Polygon polygon_b = new Polygon();</b>
<b class="fc">&nbsp;		polygon_b.addEnvelope(envelope_b, false);</b>
&nbsp;
<b class="fc">&nbsp;		return linearPathEqualsLinearPath_(polygon_a, polygon_b, tolerance, true);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from envelope_b.
&nbsp;	private static boolean polygonDisjointEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains || relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		PolygonUtils.PiPResult pipres;
<b class="fc">&nbsp;		Point2D pt_b = new Point2D();</b>
<b class="fc">&nbsp;		env_b.queryLowerLeft(pt_b);</b>
<b class="fc">&nbsp;		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</b>
<b class="fc">&nbsp;		if (pipres != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		env_b.queryLowerRight(pt_b);</b>
<b class="fc">&nbsp;		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</b>
<b class="fc">&nbsp;		if (pipres != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		env_b.queryUpperRight(pt_b);</b>
<b class="fc">&nbsp;		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</b>
<b class="fc">&nbsp;		if (pipres != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		env_b.queryUpperLeft(pt_b);</b>
<b class="fc">&nbsp;		pipres = PolygonUtils.isPointInPolygon2D(polygon_a, pt_b, tolerance);</b>
<b class="fc">&nbsp;		if (pipres != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		MultiPathImpl mimpl_a = (MultiPathImpl) polygon_a._getImpl();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl pos = (AttributeStreamOfDbl) (mimpl_a</b>
<b class="fc">&nbsp;				.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		for (int ptIndex = 0, n = mimpl_a.getPointCount(); ptIndex &lt; n; ptIndex++) {</b>
<b class="fc">&nbsp;			double x = pos.read(2 * ptIndex);</b>
<b class="fc">&nbsp;			double y = pos.read(2 * ptIndex + 1);</b>
<b class="fc">&nbsp;			if (env_b_inflated.contains(x, y))</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return !linearPathIntersectsEnvelope_(polygon_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a touches envelope_b.
&nbsp;	private static boolean polygonTouchesEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains</b>
<b class="fc">&nbsp;				|| relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getWidth() &lt;= tolerance &amp;&amp; env_b.getHeight() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_b = envelope_b.getCenterXY();</b>
<b class="fc">&nbsp;			return polygonTouchesPointImpl_(polygon_a, pt_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// polyline
<b class="fc">&nbsp;			Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;			Point p = new Point();</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;			polyline_b.startPath(p);</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;			polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;			return polygonTouchesPolylineImpl_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;					tolerance, progress_tracker);</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat as polygon
<b class="fc">&nbsp;		Polygon polygon_b = new Polygon();</b>
<b class="fc">&nbsp;		polygon_b.addEnvelope(envelope_b, false);</b>
<b class="fc">&nbsp;		return polygonTouchesPolygonImpl_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a overlaps envelope_b.
&nbsp;	private static boolean polygonOverlapsEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.contains</b>
<b class="fc">&nbsp;				|| relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // has no interior</b>
&nbsp;
<b class="fc">&nbsp;		Polygon polygon_b = new Polygon();</b>
<b class="fc">&nbsp;		polygon_b.addEnvelope(envelope_b, false);</b>
<b class="fc">&nbsp;		return polygonOverlapsPolygonImpl_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is within envelope_b
&nbsp;	private static boolean polygonWithinEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="nc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="nc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="nc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
<b class="nc">&nbsp;		return envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a contains envelope_b.
&nbsp;	private static boolean polygonContainsEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick envelope rejection test
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint,
&nbsp;		// or if one is contained in the other.
<b class="fc">&nbsp;		int relation = tryRasterizedContainsOrDisjoint_(polygon_a, envelope_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.disjoint || relation == Relation.within)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (relation == Relation.contains)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getWidth() &lt;= tolerance &amp;&amp; env_b.getHeight() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_b = envelope_b.getCenterXY();</b>
<b class="fc">&nbsp;			return polygonContainsPointImpl_(polygon_a, pt_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getWidth() &lt;= tolerance || env_b.getHeight() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// polyline
<b class="fc">&nbsp;			Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;			Point p = new Point();</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;			polyline_b.startPath(p);</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;			polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;			return polygonContainsPolylineImpl_(polygon_a, polyline_b,</b>
<b class="fc">&nbsp;					tolerance, null);</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat as polygon
<b class="fc">&nbsp;		Polygon polygon_b = new Polygon();</b>
<b class="fc">&nbsp;		polygon_b.addEnvelope(envelope_b, false);</b>
<b class="fc">&nbsp;		return polygonContainsPolygonImpl_(polygon_a, polygon_b, tolerance,</b>
<b class="fc">&nbsp;				null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a crosses envelope_b.
&nbsp;	private static boolean polygonCrossesEnvelope_(Polygon polygon_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false; // when treated as an area, areas cannot cross areas.</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // when treated as a point, areas cannot cross points.</b>
&nbsp;
&nbsp;		// Treat as polyline
<b class="fc">&nbsp;		Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;		Point p = new Point();</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;		polyline_b.startPath(p);</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;		polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;		return polygonCrossesPolylineImpl_(polygon_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a equals polyline_b.
&nbsp;	private static boolean polylineEqualsPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polyline_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick point equality check for true equality. This just checks if all
&nbsp;		// the points in each ring are the same (within a tolerance) and in the
&nbsp;		// same order
<b class="fc">&nbsp;		if (multiPathExactlyEqualsMultiPath_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker))</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return linearPathEqualsLinearPath_(polyline_a, polyline_b, tolerance, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a is disjoint from polyline_b.
&nbsp;	private static boolean polylineDisjointPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polyline_a._getImpl();</b>
<b class="fc">&nbsp;        MultiPathImpl multi_path_impl_b = (MultiPathImpl)polyline_b._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;        PairwiseIntersectorImpl intersector_paths = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);</b>
&nbsp;
<b class="fc">&nbsp;        if (!intersector_paths.next())</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;
<b class="fc">&nbsp;		return !linearPathIntersectsLinearPath_(polyline_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a touches polyline_b.
&nbsp;	private static boolean polylineTouchesPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);</b>
&nbsp;
<b class="fc">&nbsp;		int dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, intersections);</b>
&nbsp;
<b class="fc">&nbsp;		if (dim != 0)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		MultiPoint intersection = new MultiPoint();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; intersections.size(); i += 2) {</b>
<b class="fc">&nbsp;			double x = intersections.read(i);</b>
<b class="fc">&nbsp;			double y = intersections.read(i + 1);</b>
<b class="fc">&nbsp;			intersection.add(x, y);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());</b>
<b class="fc">&nbsp;		MultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());</b>
&nbsp;
<b class="fc">&nbsp;		boundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());</b>
&nbsp;
<b class="fc">&nbsp;		return multiPointContainsMultiPointBrute_(boundary_a_b, intersection,</b>
<b class="fc">&nbsp;				tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a crosses polyline_b.
&nbsp;	private static boolean polylineCrossesPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfDbl intersections = new AttributeStreamOfDbl(0);</b>
&nbsp;
<b class="fc">&nbsp;		int dim = linearPathIntersectsLinearPathMaxDim_(polyline_a, polyline_b,</b>
<b class="fc">&nbsp;				tolerance, intersections);</b>
&nbsp;
<b class="fc">&nbsp;		if (dim != 0)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		MultiPoint intersection = new MultiPoint();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; intersections.size(); i += 2) {</b>
<b class="fc">&nbsp;			double x = intersections.read(i);</b>
<b class="fc">&nbsp;			double y = intersections.read(i + 1);</b>
<b class="fc">&nbsp;			intersection.add(x, y);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiPoint boundary_a_b = (MultiPoint) (polyline_a.getBoundary());</b>
<b class="fc">&nbsp;		MultiPoint boundary_b = (MultiPoint) (polyline_b.getBoundary());</b>
&nbsp;
<b class="fc">&nbsp;		boundary_a_b.add(boundary_b, 0, boundary_b.getPointCount());</b>
&nbsp;
<b class="fc">&nbsp;		return !multiPointContainsMultiPointBrute_(boundary_a_b, intersection,</b>
<b class="fc">&nbsp;				tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a overlaps polyline_b.
&nbsp;	private static boolean polylineOverlapsPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a contains polyline_b.
&nbsp;	private static boolean polylineContainsPolyline_(Polyline polyline_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polyline_b.queryEnvelope2D(env_b);</b>
&nbsp;
&nbsp;		// Quick envelope rejection test for false equality.
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a is disjoint from point_b.
&nbsp;	private static boolean polylineDisjointPoint_(Polyline polyline_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return !linearPathIntersectsPoint_(polyline_a, pt_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a touches point_b.
&nbsp;	private static boolean polylineTouchesPoint_(Polyline polyline_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true of polyline_a contains point_b.
&nbsp;	private static boolean polylineContainsPoint_(Polyline polyline_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, point_b, tolerance,</b>
<b class="fc">&nbsp;				false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return linearPathContainsPoint_(polyline_a, pt_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a is disjoint from multipoint_b.
&nbsp;	private static boolean polylineDisjointMultiPoint_(Polyline polyline_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return !linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a touches multipoint_b.
&nbsp;	private static boolean polylineTouchesMultiPoint_(Polyline polyline_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false) == Relation.disjoint) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl qtA = null;</b>
<b class="fc">&nbsp;		QuadTreeImpl quadTreeA = null;</b>
<b class="fc">&nbsp;        QuadTreeImpl quadTreePathsA = null;</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="fc">&nbsp;			quadTreeA = accel.getQuadTree();</b>
<b class="fc">&nbsp;            quadTreePathsA = accel.getQuadTreeForPaths();</b>
<b class="fc">&nbsp;			if (quadTreeA == null) {</b>
<b class="fc">&nbsp;				qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;						(MultiPathImpl) polyline_a._getImpl(), envInter);</b>
<b class="fc">&nbsp;				quadTreeA = qtA;</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;					(MultiPathImpl) polyline_a._getImpl(), envInter);</b>
<b class="fc">&nbsp;			quadTreeA = qtA;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</b>
<b class="fc">&nbsp;        if (quadTreePathsA != null)</b>
<b class="nc">&nbsp;            qtIterPathsA = quadTreePathsA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptB = new Point2D(), closest = new Point2D();</b>
<b class="fc">&nbsp;		boolean b_intersects = false;</b>
<b class="fc">&nbsp;		double toleranceSq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(</b>
<b class="fc">&nbsp;				multipoint_b.getPointCount());</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			intersects.write(i, (byte) 0);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;			if (!envInter.contains(ptB)) {</b>
<b class="nc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</b>
&nbsp;
<b class="fc">&nbsp;            if (qtIterPathsA != null) {</b>
<b class="nc">&nbsp;                qtIterPathsA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                if (qtIterPathsA.next() == -1)</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;			qtIterA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</b>
<b class="fc">&nbsp;					.next()) {</b>
<b class="fc">&nbsp;				int vertex_a = quadTreeA.getElement(elementHandleA);</b>
<b class="fc">&nbsp;				segIterA.resetToVertex(vertex_a);</b>
&nbsp;
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;				double t = segmentA.getClosestCoordinate(ptB, false);</b>
<b class="fc">&nbsp;				segmentA.getCoord2D(t, closest);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</b>
<b class="fc">&nbsp;					intersects.write(i, (byte) 1);</b>
<b class="fc">&nbsp;					b_intersects = true;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!b_intersects) {</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</b>
<b class="fc">&nbsp;		MultiPoint multipoint_b_inter = new MultiPoint();</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			if (intersects.read(i) == 0) {</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			multipoint_b.getXY(i, pt);</b>
<b class="fc">&nbsp;			multipoint_b_inter.add(pt.x, pt.y);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return multiPointContainsMultiPointBrute_(boundary_a,</b>
<b class="fc">&nbsp;				multipoint_b_inter, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a crosses multipoint_b.
&nbsp;	private static boolean polylineCrossesMultiPoint_(Polyline polyline_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false) == Relation.disjoint) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) polyline_a._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl qtA = null;</b>
<b class="fc">&nbsp;		QuadTreeImpl quadTreeA = null;</b>
<b class="fc">&nbsp;        QuadTreeImpl quadTreePathsA = null;</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) (polyline_a._getImpl()))</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="fc">&nbsp;			quadTreeA = accel.getQuadTree();</b>
<b class="fc">&nbsp;            quadTreePathsA = accel.getQuadTreeForPaths();</b>
<b class="fc">&nbsp;			if (quadTreeA == null) {</b>
<b class="fc">&nbsp;				qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;						(MultiPathImpl) polyline_a._getImpl(), envInter);</b>
<b class="fc">&nbsp;				quadTreeA = qtA;</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;					(MultiPathImpl) polyline_a._getImpl(), envInter);</b>
<b class="fc">&nbsp;			quadTreeA = qtA;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</b>
<b class="fc">&nbsp;        if (quadTreePathsA != null)</b>
<b class="nc">&nbsp;            qtIterPathsA = quadTreePathsA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        Point2D ptB = new Point2D(), closest = new Point2D();</b>
<b class="fc">&nbsp;		boolean b_intersects = false;</b>
<b class="fc">&nbsp;		boolean b_exterior_found = false;</b>
<b class="fc">&nbsp;		double toleranceSq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt8 intersects = new AttributeStreamOfInt8(</b>
<b class="fc">&nbsp;				multipoint_b.getPointCount());</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			intersects.write(i, (byte) 0);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;			if (!envInter.contains(ptB)) {</b>
<b class="nc">&nbsp;				b_exterior_found = true;</b>
<b class="nc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</b>
&nbsp;
<b class="fc">&nbsp;            if (qtIterPathsA != null) {</b>
<b class="nc">&nbsp;                qtIterPathsA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                if (qtIterPathsA.next() == -1) {</b>
<b class="nc">&nbsp;                    b_exterior_found = true;</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;			qtIterA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			boolean b_covered = false;</b>
&nbsp;
<b class="fc">&nbsp;			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</b>
<b class="fc">&nbsp;					.next()) {</b>
<b class="fc">&nbsp;				int vertex_a = quadTreeA.getElement(elementHandleA);</b>
<b class="fc">&nbsp;				segIterA.resetToVertex(vertex_a);</b>
&nbsp;
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;				double t = segmentA.getClosestCoordinate(ptB, false);</b>
<b class="fc">&nbsp;				segmentA.getCoord2D(t, closest);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</b>
<b class="fc">&nbsp;					intersects.write(i, (byte) 1);</b>
<b class="fc">&nbsp;					b_intersects = true;</b>
<b class="fc">&nbsp;					b_covered = true;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (!b_covered) {</b>
<b class="fc">&nbsp;				b_exterior_found = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!b_intersects || !b_exterior_found) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</b>
<b class="fc">&nbsp;		MultiPoint multipoint_b_inter = new MultiPoint();</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			if (intersects.read(i) == 0) {</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			multipoint_b.getXY(i, pt);</b>
<b class="fc">&nbsp;			multipoint_b_inter.add(pt.x, pt.y);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return !multiPointContainsMultiPointBrute_(boundary_a,</b>
<b class="fc">&nbsp;				multipoint_b_inter, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a contains multipoint_b.
&nbsp;	private static boolean polylineContainsMultiPoint_(Polyline polyline_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// Quick rasterize test to see whether the the geometries are disjoint.
<b class="fc">&nbsp;		if (tryRasterizedContainsOrDisjoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false) == Relation.disjoint)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (!linearPathIntersectsMultiPoint_(polyline_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, true))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		MultiPoint boundary_a = (MultiPoint) (polyline_a.getBoundary());</b>
<b class="fc">&nbsp;		return !multiPointIntersectsMultiPoint_(boundary_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a equals envelope_b.
&nbsp;	private static boolean polylineEqualsEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false; // area cannot equal a line</b>
&nbsp;
<b class="fc">&nbsp;		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a is disjoint from envelope_b.
&nbsp;	private static boolean polylineDisjointEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return !linearPathIntersectsEnvelope_(polyline_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a touches envelope_b.
&nbsp;	private static boolean polylineTouchesEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// Treat</b>
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_b = envelope_b.getCenterXY();</b>
<b class="fc">&nbsp;			return linearPathTouchesPointImpl_(polyline_a, pt_b, tolerance);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// Treat</b>
&nbsp;																				// as
&nbsp;																				// polyline
<b class="fc">&nbsp;			Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;			Point p = new Point();</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;			polyline_b.startPath(p);</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;			polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;			return polylineTouchesPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Treat env_b as area
&nbsp;
<b class="fc">&nbsp;		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_boundary = false;</b>
<b class="fc">&nbsp;		Envelope2D env_segment_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_inter = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;		while (seg_iter_a.nextPath()) {</b>
<b class="fc">&nbsp;			while (seg_iter_a.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment_a = seg_iter_a.nextSegment();</b>
<b class="fc">&nbsp;				segment_a.queryEnvelope2D(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				env_inter.setCoords(env_b_deflated);</b>
<b class="fc">&nbsp;				env_inter.intersect(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_inter.isEmpty()</b>
<b class="fc">&nbsp;						&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</b>
<b class="fc">&nbsp;								.getWidth() &gt; tolerance))</b>
<b class="fc">&nbsp;					return false; // consider segment within</b>
&nbsp;
<b class="fc">&nbsp;				env_inter.setCoords(env_b_inflated);</b>
<b class="fc">&nbsp;				env_inter.intersect(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_inter.isEmpty())</b>
<b class="fc">&nbsp;					b_boundary = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return b_boundary;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a overlaps envelope_b.
&nbsp;	private static boolean polylineOverlapsEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</b>
<b class="fc">&nbsp;				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false; // lines cannot overlap areas</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // lines cannot overlap points</b>
&nbsp;
&nbsp;		// Treat as polyline
<b class="fc">&nbsp;		Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;		Point p = new Point();</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;		polyline_b.startPath(p);</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;		polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;		return linearPathOverlapsLinearPath_(polyline_a, polyline_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a is within envelope_b.
&nbsp;	private static boolean polylineWithinEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		Envelope2D env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_interior = false;</b>
<b class="fc">&nbsp;		Envelope2D env_segment_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_inter = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;		while (seg_iter_a.nextPath()) {</b>
<b class="fc">&nbsp;			while (seg_iter_a.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment_a = seg_iter_a.nextSegment();</b>
<b class="fc">&nbsp;				segment_a.queryEnvelope2D(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (env_b_deflated.containsExclusive(env_segment_a)) {</b>
<b class="fc">&nbsp;					b_interior = true;</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				env_inter.setCoords(env_b_deflated);</b>
<b class="fc">&nbsp;				env_inter.intersect(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_inter.isEmpty()</b>
<b class="fc">&nbsp;						&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</b>
<b class="nc">&nbsp;								.getWidth() &gt; tolerance))</b>
<b class="fc">&nbsp;					b_interior = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return b_interior;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a contains envelope_b.
&nbsp;	private static boolean polylineContainsEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false; // when treated as an area, lines cannot contain</b>
&nbsp;							// areas.
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// Treat</b>
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_b = envelope_b.getCenterXY();</b>
<b class="fc">&nbsp;			return linearPathContainsPoint_(polyline_a, pt_b, tolerance);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Treat as polyline
<b class="fc">&nbsp;		Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;		Point p = new Point();</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;		polyline_b.startPath(p);</b>
<b class="fc">&nbsp;		envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;		polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;		return linearPathWithinLinearPath_(polyline_b, polyline_a, tolerance, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polyline_a crosses envelope_b.
&nbsp;	private static boolean polylineCrossesEnvelope_(Polyline polyline_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		polyline_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // when treated as a point, lines cannot cross points.</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// Treat</b>
&nbsp;																				// as
&nbsp;																				// polyline
<b class="fc">&nbsp;			Polyline polyline_b = new Polyline();</b>
<b class="fc">&nbsp;			Point p = new Point();</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(0, p);</b>
<b class="fc">&nbsp;			polyline_b.startPath(p);</b>
<b class="fc">&nbsp;			envelope_b.queryCornerByVal(2, p);</b>
<b class="fc">&nbsp;			polyline_b.lineTo(p);</b>
<b class="fc">&nbsp;			return polylineCrossesPolyline_(polyline_a, polyline_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Treat env_b as area
&nbsp;
<b class="fc">&nbsp;		SegmentIterator seg_iter_a = polyline_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_interior = false, b_exterior = false;</b>
<b class="fc">&nbsp;		Envelope2D env_segment_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_inter = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;		while (seg_iter_a.nextPath()) {</b>
<b class="fc">&nbsp;			while (seg_iter_a.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment_a = seg_iter_a.nextSegment();</b>
<b class="fc">&nbsp;				segment_a.queryEnvelope2D(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!b_exterior) {</b>
<b class="fc">&nbsp;					if (!env_b_inflated.contains(env_segment_a))</b>
<b class="fc">&nbsp;						b_exterior = true;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (!b_interior) {</b>
<b class="fc">&nbsp;					env_inter.setCoords(env_b_deflated);</b>
<b class="fc">&nbsp;					env_inter.intersect(env_segment_a);</b>
&nbsp;
<b class="fc">&nbsp;					if (!env_inter.isEmpty()</b>
<b class="fc">&nbsp;							&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</b>
<b class="fc">&nbsp;									.getWidth() &gt; tolerance))</b>
<b class="fc">&nbsp;						b_interior = true;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (b_interior &amp;&amp; b_exterior)</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a equals multipoint_b.
&nbsp;	private static boolean multiPointEqualsMultiPoint_(MultiPoint multipoint_a,
&nbsp;			MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeEqualsEnvelope_(env_a, env_b, tolerance, progress_tracker))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (multiPointExactlyEqualsMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, progress_tracker))</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false, true, false, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a is disjoint from multipoint_b.
&nbsp;	private static boolean multiPointDisjointMultiPoint_(
&nbsp;			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return !multiPointIntersectsMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a overlaps multipoint_b.
&nbsp;	private static boolean multiPointOverlapsMultiPoint_(
&nbsp;			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return multiPointCoverageMultiPoint_(multipoint_a, multipoint_b,</b>
<b class="fc">&nbsp;				tolerance, false, false, true, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a contains multipoint_b.
&nbsp;	private static boolean multiPointContainsMultiPoint_(
&nbsp;			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return multiPointCoverageMultiPoint_(multipoint_b, multipoint_a,</b>
<b class="fc">&nbsp;				tolerance, true, false, false, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean multiPointContainsMultiPointBrute_(
&nbsp;			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance) {
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;		Point2D pt_b = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, pt_b);</b>
<b class="fc">&nbsp;			boolean b_contained = false;</b>
&nbsp;
<b class="fc">&nbsp;			for (int j = 0; j &lt; multipoint_a.getPointCount(); j++) {</b>
<b class="fc">&nbsp;				multipoint_a.getXY(j, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance_sq) {</b>
<b class="fc">&nbsp;					b_contained = true;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (!b_contained)</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a equals point_b.
&nbsp;	static boolean multiPointEqualsPoint_(MultiPoint multipoint_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		point_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a is disjoint from point_b.
&nbsp;	private static boolean multiPointDisjointPoint_(MultiPoint multipoint_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Point2D pt_b = point_b.getXY();</b>
<b class="fc">&nbsp;		return multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a is within point_b.
&nbsp;	private static boolean multiPointWithinPoint_(MultiPoint multipoint_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return multiPointEqualsPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a contains point_b.
&nbsp;	private static boolean multiPointContainsPoint_(MultiPoint multipoint_a,
&nbsp;			Point point_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return !multiPointDisjointPoint_(multipoint_a, point_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a equals envelope_b.
&nbsp;	private static boolean multiPointEqualsEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance || env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
&nbsp;		// only true if all the points of the multi_point degenerate to a point
&nbsp;		// equal to the envelope
<b class="fc">&nbsp;		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a is disjoint from envelope_b.
&nbsp;	private static boolean multiPointDisjointEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (!env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a touches envelope_b.
&nbsp;	private static boolean multiPointTouchesEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D(), env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // there are no boundaries to intersect</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// line
&nbsp;
<b class="fc">&nbsp;			Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;			boolean b_boundary = false;</b>
&nbsp;
<b class="fc">&nbsp;			env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance)</b>
<b class="nc">&nbsp;				env_b_deflated.inflate(0, -tolerance);</b>
&nbsp;			else
<b class="fc">&nbsp;				env_b_deflated.inflate(-tolerance, 0);</b>
&nbsp;
<b class="fc">&nbsp;			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;				multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;
<b class="fc">&nbsp;				if (env_b.getHeight() &gt; tolerance) {</b>
<b class="nc">&nbsp;					if (pt_a.y &gt; env_b_deflated.ymin</b>
<b class="nc">&nbsp;							&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)</b>
<b class="nc">&nbsp;						return false;</b>
&nbsp;
<b class="nc">&nbsp;					b_boundary = true;</b>
<b class="nc">&nbsp;				} else {</b>
<b class="fc">&nbsp;					if (pt_a.x &gt; env_b_deflated.xmin</b>
<b class="fc">&nbsp;							&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)</b>
<b class="fc">&nbsp;						return false;</b>
&nbsp;
<b class="fc">&nbsp;					b_boundary = true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return b_boundary;</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat as area
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;		boolean b_boundary = false;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (!env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b_deflated.containsExclusive(pt_a))</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			b_boundary = true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return b_boundary;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a is within envelope_b.
&nbsp;	private static boolean multiPointWithinEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker); // treat as point</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// line
&nbsp;
<b class="fc">&nbsp;			boolean b_interior = false;</b>
&nbsp;
<b class="fc">&nbsp;			Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			env_b_inflated.setCoords(env_b);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance)</b>
<b class="nc">&nbsp;				env_b_deflated.inflate(0, -tolerance);</b>
&nbsp;			else
<b class="fc">&nbsp;				env_b_deflated.inflate(-tolerance, 0);</b>
&nbsp;
<b class="fc">&nbsp;			env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			Point2D pt_a = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;				multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_b_inflated.contains(pt_a))</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;
<b class="fc">&nbsp;				if (env_b.getHeight() &gt; tolerance) {</b>
<b class="nc">&nbsp;					if (pt_a.y &gt; env_b_deflated.ymin</b>
<b class="nc">&nbsp;							&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)</b>
<b class="nc">&nbsp;						b_interior = true;</b>
<b class="nc">&nbsp;				} else {</b>
<b class="fc">&nbsp;					if (pt_a.x &gt; env_b_deflated.xmin</b>
<b class="fc">&nbsp;							&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)</b>
<b class="fc">&nbsp;						b_interior = true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return b_interior;</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat as area
&nbsp;
<b class="fc">&nbsp;		boolean b_interior = false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
&nbsp;
&nbsp;		// we loop to find a proper interior intersection (i.e. something inside
&nbsp;		// instead of just on the boundary)
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (!env_b_inflated.contains(pt_a))</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b_deflated.containsExclusive(pt_a))</b>
<b class="fc">&nbsp;				b_interior = true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return b_interior;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a contains envelope_b.
&nbsp;	private static boolean multiPointContainsEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance || env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_b = envelope_b.getCenterXY();</b>
<b class="fc">&nbsp;		return !multiPointDisjointPointImpl_(multipoint_a, pt_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a crosses envelope_b.
&nbsp;	static boolean multiPointCrossesEnvelope_(MultiPoint multipoint_a,
&nbsp;			Envelope envelope_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		envelope_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// line
<b class="fc">&nbsp;			Envelope2D env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;			Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(env_b);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance)</b>
<b class="nc">&nbsp;				env_b_deflated.inflate(0, -tolerance);</b>
&nbsp;			else
<b class="fc">&nbsp;				env_b_deflated.inflate(-tolerance, 0);</b>
&nbsp;
<b class="fc">&nbsp;			env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;			boolean b_interior = false, b_exterior = false;</b>
&nbsp;
<b class="fc">&nbsp;			for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;				multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!b_interior) {</b>
<b class="fc">&nbsp;					if (env_b.getHeight() &gt; tolerance) {</b>
<b class="nc">&nbsp;						if (pt_a.y &gt; env_b_deflated.ymin</b>
<b class="nc">&nbsp;								&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)</b>
<b class="nc">&nbsp;							b_interior = true;</b>
<b class="nc">&nbsp;					} else {</b>
<b class="fc">&nbsp;						if (pt_a.x &gt; env_b_deflated.xmin</b>
<b class="fc">&nbsp;								&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)</b>
<b class="fc">&nbsp;							b_interior = true;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (!b_exterior &amp;&amp; !env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;					b_exterior = true;</b>
&nbsp;
<b class="fc">&nbsp;				if (b_interior &amp;&amp; b_exterior)</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_deflated = new Envelope2D(), env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;		assert (!env_b_deflated.isEmpty());</b>
&nbsp;
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;		boolean b_interior = false, b_exterior = false;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (!b_interior &amp;&amp; env_b_deflated.containsExclusive(pt_a))</b>
<b class="fc">&nbsp;				b_interior = true;</b>
&nbsp;
<b class="fc">&nbsp;			if (!b_exterior &amp;&amp; !env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;				b_exterior = true;</b>
&nbsp;
<b class="fc">&nbsp;			if (b_interior &amp;&amp; b_exterior)</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a equals pt_b.
&nbsp;	private static boolean pointEqualsPoint_(Point2D pt_a, Point2D pt_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance * tolerance)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a is disjoint from pt_b.
&nbsp;	private static boolean pointDisjointPoint_(Point2D pt_a, Point2D pt_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (Point2D.sqrDistance(pt_a, pt_b) &gt; tolerance * tolerance)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a contains pt_b.
&nbsp;	private static boolean pointContainsPoint_(Point2D pt_a, Point2D pt_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return pointEqualsPoint_(pt_a, pt_b, tolerance, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a equals enve_b.
&nbsp;	private static boolean pointEqualsEnvelope_(Point2D pt_a, Envelope2D env_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		env_a.setCoords(pt_a);</b>
<b class="fc">&nbsp;		return envelopeEqualsEnvelope_(env_a, env_b, tolerance,</b>
<b class="fc">&nbsp;				progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a is disjoint from env_b.
&nbsp;	static boolean pointDisjointEnvelope_(Point2D pt_a, Envelope2D env_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		return !env_b_inflated.contains(pt_a);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a touches env_b.
&nbsp;	private static boolean pointTouchesEnvelope_(Point2D pt_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // when treates as a point, points cannot touch points</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D(), env_b_deflated = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (!env_b_inflated.contains(pt_a))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(env_b);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance)</b>
<b class="nc">&nbsp;				env_b_deflated.inflate(0, -tolerance);</b>
&nbsp;			else
<b class="fc">&nbsp;				env_b_deflated.inflate(-tolerance, 0);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance) {</b>
<b class="nc">&nbsp;				if (pt_a.y &gt; env_b_deflated.ymin</b>
<b class="nc">&nbsp;						&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				if (pt_a.x &gt; env_b_deflated.xmin</b>
<b class="fc">&nbsp;						&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b_deflated.containsExclusive(pt_a))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a is within env_b.
&nbsp;	private static boolean pointWithinEnvelope_(Point2D pt_a, Envelope2D env_b,
&nbsp;			double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {</b>
&nbsp;			// assert(env_b_inflated.contains(pt_a)); // should contain if we
&nbsp;			// got to here (i.e. not disjoint)
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// as
&nbsp;																				// line
<b class="fc">&nbsp;			Envelope2D env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(env_b);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance)</b>
<b class="nc">&nbsp;				env_b_deflated.inflate(0, -tolerance);</b>
&nbsp;			else
<b class="fc">&nbsp;				env_b_deflated.inflate(-tolerance, 0);</b>
&nbsp;
<b class="fc">&nbsp;			boolean b_interior = false;</b>
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance) {</b>
<b class="nc">&nbsp;				if (pt_a.y &gt; env_b_deflated.ymin</b>
<b class="nc">&nbsp;						&amp;&amp; pt_a.y &lt; env_b_deflated.ymax)</b>
<b class="nc">&nbsp;					b_interior = true;</b>
<b class="nc">&nbsp;			} else {</b>
<b class="fc">&nbsp;				if (pt_a.x &gt; env_b_deflated.xmin</b>
<b class="fc">&nbsp;						&amp;&amp; pt_a.x &lt; env_b_deflated.xmax)</b>
<b class="fc">&nbsp;					b_interior = true;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return b_interior;</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat as area
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_deflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;		return env_b_deflated.containsExclusive(pt_a);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if pt_a contains env_b.
&nbsp;	private static boolean pointContainsEnvelope_(Point2D pt_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return pointEqualsEnvelope_(pt_a, env_b, tolerance, progress_tracker);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a equals env_b.
&nbsp;	private static boolean envelopeEqualsEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		return envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</b>
<b class="fc">&nbsp;				&amp;&amp; envelopeInfContainsEnvelope_(env_b, env_a, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a is disjoint from env_b.
&nbsp;	static boolean envelopeDisjointEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		return !env_a.isIntersecting(env_b_inflated);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a touches env_b.
&nbsp;	private static boolean envelopeTouchesEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// env_a
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_a = env_a.getCenter();</b>
<b class="fc">&nbsp;			return pointTouchesEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// env_b
&nbsp;																				// as
&nbsp;																				// point
<b class="fc">&nbsp;			Point2D pt_b = env_b.getCenter();</b>
<b class="fc">&nbsp;			return pointTouchesEnvelope_(pt_b, env_a, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
&nbsp;		Envelope2D _env_a;
&nbsp;		Envelope2D _env_b;
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &gt; tolerance</b>
<b class="fc">&nbsp;				&amp;&amp; env_a.getWidth() &gt; tolerance</b>
<b class="fc">&nbsp;				&amp;&amp; (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)) {</b>
&nbsp;			// swap a and b
<b class="fc">&nbsp;			_env_a = env_b;</b>
<b class="fc">&nbsp;			_env_b = env_a;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_env_a = env_a;</b>
<b class="fc">&nbsp;			_env_b = env_b;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (_env_a.getHeight() &lt;= tolerance || _env_a.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// env_a
&nbsp;																				// as
&nbsp;																				// line
&nbsp;
<b class="fc">&nbsp;			if (_env_b.getHeight() &lt;= tolerance</b>
<b class="fc">&nbsp;					|| _env_b.getWidth() &lt;= tolerance) {// treat env_b as line</b>
&nbsp;
<b class="fc">&nbsp;				Line line_a = new Line(), line_b = new Line();</b>
<b class="fc">&nbsp;				double[] scalars_a = new double[2];</b>
<b class="fc">&nbsp;				double[] scalars_b = new double[2];</b>
<b class="fc">&nbsp;				Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;				_env_a.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;				line_a.setStartXY(pt);</b>
<b class="fc">&nbsp;				_env_a.queryUpperRight(pt);</b>
<b class="fc">&nbsp;				line_a.setEndXY(pt);</b>
<b class="fc">&nbsp;				_env_b.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;				line_b.setStartXY(pt);</b>
<b class="fc">&nbsp;				_env_b.queryUpperRight(pt);</b>
<b class="fc">&nbsp;				line_b.setEndXY(pt);</b>
&nbsp;
<b class="fc">&nbsp;				line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</b>
<b class="fc">&nbsp;				int count = line_a.intersect(line_b, null, null, null,</b>
<b class="fc">&nbsp;						tolerance);</b>
&nbsp;
<b class="fc">&nbsp;				if (count != 1)</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;
<b class="fc">&nbsp;				return scalars_a[0] == 0.0 || scalars_a[1] == 1.0</b>
<b class="fc">&nbsp;						|| scalars_b[0] == 0.0 || scalars_b[1] == 1.0;</b>
&nbsp;			}
&nbsp;
&nbsp;			// treat env_b as area
&nbsp;
<b class="fc">&nbsp;			Envelope2D env_b_deflated = new Envelope2D(), env_inter = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(_env_b);</b>
<b class="fc">&nbsp;			env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;			env_inter.setCoords(env_b_deflated);</b>
<b class="fc">&nbsp;			env_inter.intersect(_env_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (!env_inter.isEmpty()</b>
<b class="fc">&nbsp;					&amp;&amp; (env_inter.getHeight() &gt; tolerance || env_inter</b>
<b class="fc">&nbsp;							.getWidth() &gt; tolerance))</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			assert (!envelopeDisjointEnvelope_(_env_a, _env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker));</b>
<b class="fc">&nbsp;			return true; // we already know they intersect within a tolerance</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_inter = new Envelope2D();</b>
<b class="fc">&nbsp;		env_inter.setCoords(_env_a);</b>
<b class="fc">&nbsp;		env_inter.intersect(_env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (!env_inter.isEmpty() &amp;&amp; env_inter.getHeight() &gt; tolerance</b>
<b class="fc">&nbsp;				&amp;&amp; env_inter.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true; // we already know they intersect within a tolerance</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a overlaps env_b.
&nbsp;	private static boolean envelopeOverlapsEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</b>
<b class="fc">&nbsp;				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // points cannot overlap</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // points cannot overlap</b>
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance || env_a.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// env_a
&nbsp;																				// as
&nbsp;																				// a
&nbsp;																				// line
&nbsp;
<b class="fc">&nbsp;			if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;				return false; // lines cannot overlap areas</b>
&nbsp;
&nbsp;			// treat both as lines
&nbsp;
<b class="fc">&nbsp;			Line line_a = new Line(), line_b = new Line();</b>
<b class="fc">&nbsp;			double[] scalars_a = new double[2];</b>
<b class="fc">&nbsp;			double[] scalars_b = new double[2];</b>
<b class="fc">&nbsp;			Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;			env_a.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;			line_a.setStartXY(pt);</b>
<b class="fc">&nbsp;			env_a.queryUpperRight(pt);</b>
<b class="fc">&nbsp;			line_a.setEndXY(pt);</b>
<b class="fc">&nbsp;			env_b.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;			line_b.setStartXY(pt);</b>
<b class="fc">&nbsp;			env_b.queryUpperRight(pt);</b>
<b class="fc">&nbsp;			line_b.setEndXY(pt);</b>
&nbsp;
<b class="fc">&nbsp;			line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</b>
<b class="fc">&nbsp;			int count = line_a.intersect(line_b, null, null, null, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (count != 2)</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			return (scalars_a[0] &gt; 0.0 || scalars_a[1] &lt; 1.0)</b>
<b class="fc">&nbsp;					&amp;&amp; (scalars_b[0] &gt; 0.0 || scalars_b[1] &lt; 1.0);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return false; // lines cannot overlap areas</b>
&nbsp;
&nbsp;		// treat both as areas
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_inter = new Envelope2D();</b>
<b class="fc">&nbsp;		env_inter.setCoords(env_a);</b>
<b class="fc">&nbsp;		env_inter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (env_inter.isEmpty())</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_inter.getHeight() &lt;= tolerance</b>
<b class="fc">&nbsp;				|| env_inter.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // not an area</b>
&nbsp;
<b class="fc">&nbsp;		assert (!envelopeInfContainsEnvelope_(env_inter, env_a, tolerance) &amp;&amp; !envelopeInfContainsEnvelope_(</b>
<b class="fc">&nbsp;				env_inter, env_b, tolerance));</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a contains env_b.
&nbsp;	private static boolean envelopeContainsEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance) {</b>
<b class="fc">&nbsp;			Point2D pt_a = env_a.getCenter();</b>
<b class="fc">&nbsp;			return pointWithinEnvelope_(pt_a, env_b, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance) {</b>
<b class="fc">&nbsp;			Point2D pt_b = env_b.getCenter();</b>
<b class="fc">&nbsp;			return pointWithinEnvelope_(pt_b, env_a, tolerance,</b>
<b class="fc">&nbsp;					progress_tracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance || env_a.getWidth() &lt;= tolerance)</b>
<b class="fc">&nbsp;			return envelopeInfContainsEnvelope_(env_a, env_b, tolerance); // treat</b>
&nbsp;																			// env_b
&nbsp;																			// as
&nbsp;																			// line
&nbsp;
&nbsp;		// treat env_a as area
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance || env_b.getWidth() &lt;= tolerance) {// treat</b>
&nbsp;																				// env_b
&nbsp;																				// as
&nbsp;																				// line
&nbsp;
<b class="fc">&nbsp;			Envelope2D env_a_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_a_deflated.setCoords(env_a);</b>
<b class="fc">&nbsp;			env_a_deflated.inflate(-tolerance, -tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_a_deflated.containsExclusive(env_b))</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;
<b class="fc">&nbsp;			Envelope2D env_inter = new Envelope2D();</b>
<b class="fc">&nbsp;			env_inter.setCoords(env_a_deflated);</b>
<b class="fc">&nbsp;			env_inter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_inter.isEmpty()</b>
<b class="fc">&nbsp;					|| (env_inter.getHeight() &lt;= tolerance &amp;&amp; env_inter</b>
<b class="fc">&nbsp;							.getWidth() &lt;= tolerance))</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return envelopeInfContainsEnvelope_(env_a, env_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a crosses env_b.
&nbsp;	private static boolean envelopeCrossesEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (envelopeInfContainsEnvelope_(env_a, env_b, tolerance)</b>
<b class="fc">&nbsp;				|| envelopeInfContainsEnvelope_(env_b, env_a, tolerance))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &lt;= tolerance &amp;&amp; env_a.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // points cannot cross</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &lt;= tolerance &amp;&amp; env_b.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;			return false; // points cannot cross</b>
&nbsp;
<b class="fc">&nbsp;		if (env_b.getHeight() &gt; tolerance &amp;&amp; env_b.getWidth() &gt; tolerance) {</b>
<b class="fc">&nbsp;			if (env_a.getHeight() &gt; tolerance &amp;&amp; env_a.getWidth() &gt; tolerance)</b>
<b class="fc">&nbsp;				return false; // areas cannot cross</b>
&nbsp;		}
&nbsp;
&nbsp;		Envelope2D _env_a;
&nbsp;		Envelope2D _env_b;
&nbsp;
<b class="fc">&nbsp;		if (env_a.getHeight() &gt; tolerance &amp;&amp; env_a.getWidth() &gt; tolerance) {</b>
&nbsp;			// swap b and a
<b class="fc">&nbsp;			_env_a = env_b;</b>
<b class="fc">&nbsp;			_env_b = env_a;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_env_a = env_a;</b>
<b class="fc">&nbsp;			_env_b = env_b;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (_env_b.getHeight() &gt; tolerance &amp;&amp; _env_b.getWidth() &gt; tolerance) {// treat</b>
&nbsp;																				// env_b
&nbsp;																				// as
&nbsp;																				// an
&nbsp;																				// area
&nbsp;																				// (env_a
&nbsp;																				// as
&nbsp;																				// a
&nbsp;																				// line);
&nbsp;
<b class="fc">&nbsp;			Envelope2D env_inter = new Envelope2D(), env_b_deflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_deflated.setCoords(_env_b);</b>
<b class="fc">&nbsp;			env_b_deflated.inflate(-tolerance, -tolerance);</b>
<b class="fc">&nbsp;			env_inter.setCoords(env_b_deflated);</b>
<b class="fc">&nbsp;			env_inter.intersect(_env_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (env_inter.isEmpty())</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			if (env_inter.getHeight() &lt;= tolerance</b>
<b class="fc">&nbsp;					&amp;&amp; env_inter.getWidth() &lt;= tolerance)</b>
<b class="nc">&nbsp;				return false; // not a line</b>
&nbsp;
<b class="fc">&nbsp;			assert (!envelopeInfContainsEnvelope_(env_inter, _env_a, tolerance));</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
&nbsp;		// treat both as lines
&nbsp;
<b class="fc">&nbsp;		Line line_a = new Line(), line_b = new Line();</b>
<b class="fc">&nbsp;		double[] scalars_a = new double[2];</b>
<b class="fc">&nbsp;		double[] scalars_b = new double[2];</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;		_env_a.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;		line_a.setStartXY(pt);</b>
<b class="fc">&nbsp;		_env_a.queryUpperRight(pt);</b>
<b class="fc">&nbsp;		line_a.setEndXY(pt);</b>
<b class="fc">&nbsp;		_env_b.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;		line_b.setStartXY(pt);</b>
<b class="fc">&nbsp;		_env_b.queryUpperRight(pt);</b>
<b class="fc">&nbsp;		line_b.setEndXY(pt);</b>
&nbsp;
<b class="fc">&nbsp;		line_a.intersect(line_b, null, scalars_a, scalars_b, tolerance);</b>
<b class="fc">&nbsp;		int count = line_a.intersect(line_b, null, null, null, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (count != 1)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return scalars_a[0] &gt; 0.0 &amp;&amp; scalars_a[1] &lt; 1.0 &amp;&amp; scalars_b[0] &gt; 0.0</b>
<b class="fc">&nbsp;				&amp;&amp; scalars_b[1] &lt; 1.0;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if polygon_a is disjoint from multipath_b.
&nbsp;	private static boolean polygonDisjointMultiPath_(Polygon polygon_a,
&nbsp;			MultiPath multipath_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;        Point2D pt_a, pt_b;
<b class="fc">&nbsp;        Envelope2D env_a_inf = new Envelope2D(), env_b_inf = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;        MultiPathImpl multi_path_impl_a = (MultiPathImpl)polygon_a._getImpl();</b>
<b class="fc">&nbsp;        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multipath_b._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, true);</b>
&nbsp;
<b class="fc">&nbsp;        if (!intersector.next())</b>
<b class="fc">&nbsp;            return true; // no rings intersect</b>
&nbsp;
<b class="fc">&nbsp;        boolean b_intersects = linearPathIntersectsLinearPath_(polygon_a, multipath_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;        if (b_intersects)</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;
<b class="fc">&nbsp;        Polygon pa = null;</b>
<b class="fc">&nbsp;        Polygon p_polygon_a = polygon_a;</b>
&nbsp;
<b class="fc">&nbsp;        Polygon pb = null;</b>
<b class="fc">&nbsp;        Polygon p_polygon_b = null;</b>
&nbsp;
<b class="fc">&nbsp;        if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</b>
<b class="fc">&nbsp;            p_polygon_b = (Polygon)multipath_b;</b>
&nbsp;
<b class="fc">&nbsp;        boolean b_checked_polygon_a_quad_tree = false;</b>
<b class="fc">&nbsp;        boolean b_checked_polygon_b_quad_tree = false;</b>
&nbsp;
&nbsp;        do
&nbsp;        {
<b class="fc">&nbsp;            int path_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;            int path_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;            pt_b = multipath_b.getXY(multipath_b.getPathStart(path_b));</b>
<b class="fc">&nbsp;            env_a_inf.setCoords(intersector.getRedEnvelope());</b>
<b class="fc">&nbsp;            env_a_inf.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;            if (env_a_inf.contains(pt_b))</b>
&nbsp;            {
<b class="fc">&nbsp;                PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, pt_b, 0.0);</b>
&nbsp;
<b class="fc">&nbsp;                if (result != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</b>
&nbsp;            {
<b class="fc">&nbsp;                pt_a = polygon_a.getXY(polygon_a.getPathStart(path_a));</b>
<b class="fc">&nbsp;                env_b_inf.setCoords(intersector.getBlueEnvelope());</b>
<b class="fc">&nbsp;                env_b_inf.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;                if (env_b_inf.contains(pt_a))</b>
&nbsp;                {
<b class="fc">&nbsp;                    PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_b, pt_a, 0.0);</b>
&nbsp;
<b class="fc">&nbsp;                    if (result != PolygonUtils.PiPResult.PiPOutside)</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (!b_checked_polygon_a_quad_tree) {</b>
<b class="fc">&nbsp;                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipath_b.getPathCount() - 1) &amp;&amp; (multi_path_impl_a._getAccelerators() == null || multi_path_impl_a._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                    pa = new Polygon();</b>
<b class="nc">&nbsp;                    polygon_a.copyTo(pa);</b>
<b class="nc">&nbsp;                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                    p_polygon_a = pa;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    p_polygon_a = polygon_a;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;                b_checked_polygon_a_quad_tree = true;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (multipath_b.getType().value() == Geometry.GeometryType.Polygon)</b>
&nbsp;            {
<b class="fc">&nbsp;                if (!b_checked_polygon_b_quad_tree) {</b>
<b class="fc">&nbsp;                    Polygon polygon_b = (Polygon) multipath_b;</b>
<b class="fc">&nbsp;                    if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) &amp;&amp; (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                        pb = new Polygon();</b>
<b class="nc">&nbsp;                        polygon_b.copyTo(pb);</b>
<b class="nc">&nbsp;                        ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                        p_polygon_b = pb;</b>
<b class="nc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        p_polygon_b = (Polygon) multipath_b;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    b_checked_polygon_b_quad_tree = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;        } while (intersector.next());</b>
&nbsp;
<b class="fc">&nbsp;        return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if env_a inflated contains env_b.
&nbsp;	private static boolean envelopeInfContainsEnvelope_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance) {
<b class="fc">&nbsp;		Envelope2D env_a_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;		env_a_inflated.setCoords(env_a);</b>
<b class="fc">&nbsp;		env_a_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		return env_a_inflated.contains(env_b);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if a coordinate of envelope A is outside of envelope B.
&nbsp;	private static boolean interiorEnvExteriorEnv_(Envelope2D env_a,
&nbsp;			Envelope2D env_b, double tolerance) {
<b class="fc">&nbsp;		Envelope2D envBInflated = new Envelope2D();</b>
<b class="fc">&nbsp;		envBInflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		envBInflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		env_a.queryLowerLeft(pt);</b>
<b class="fc">&nbsp;		if (!envBInflated.contains(pt))</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		env_a.queryLowerRight(pt);</b>
<b class="fc">&nbsp;		if (!envBInflated.contains(pt))</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		env_a.queryUpperLeft(pt);</b>
<b class="fc">&nbsp;		if (!envBInflated.contains(pt))</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		env_a.queryUpperRight(pt);</b>
<b class="fc">&nbsp;		if (!envBInflated.contains(pt))</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		assert (envBInflated.contains(env_a));</b>
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the points in each path of multipathA are the same as
&nbsp;	// those in multipathB, within a tolerance, and in the same order.
&nbsp;	private static boolean multiPathExactlyEqualsMultiPath_(
&nbsp;			MultiPath multipathA, MultiPath multipathB, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (multipathA.getPathCount() != multipathB.getPathCount()</b>
<b class="fc">&nbsp;				|| multipathA.getPointCount() != multipathB.getPointCount())</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptA = new Point2D(), ptB = new Point2D();</b>
<b class="fc">&nbsp;		boolean bAllPointsEqual = true;</b>
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		for (int ipath = 0; ipath &lt; multipathA.getPathCount(); ipath++) {</b>
<b class="fc">&nbsp;			if (multipathA.getPathEnd(ipath) != multipathB.getPathEnd(ipath)) {</b>
<b class="nc">&nbsp;				bAllPointsEqual = false;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			for (int i = multipathA.getPathStart(ipath); i &lt; multipathB</b>
<b class="fc">&nbsp;					.getPathEnd(ipath); i++) {</b>
<b class="fc">&nbsp;				multipathA.getXY(i, ptA);</b>
<b class="fc">&nbsp;				multipathB.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptA, ptB) &gt; tolerance_sq) {</b>
<b class="fc">&nbsp;					bAllPointsEqual = false;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (!bAllPointsEqual)</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!bAllPointsEqual)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the points of multipoint_a are the same as those in
&nbsp;	// multipoint_b, within a tolerance, and in the same order.
&nbsp;	private static boolean multiPointExactlyEqualsMultiPoint_(
&nbsp;			MultiPoint multipoint_a, MultiPoint multipoint_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (multipoint_a.getPointCount() != multipoint_b.getPointCount())</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptA = new Point2D(), ptB = new Point2D();</b>
<b class="fc">&nbsp;		boolean bAllPointsEqual = true;</b>
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, ptA);</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;			if (Point2D.sqrDistance(ptA, ptB) &gt; tolerance_sq) {</b>
<b class="nc">&nbsp;				bAllPointsEqual = false;</b>
<b class="nc">&nbsp;				break;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!bAllPointsEqual)</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// By default this will perform the within operation if bEquals is false.
&nbsp;	// Otherwise it will do equals.
&nbsp;	private static boolean multiPointCoverageMultiPoint_(
&nbsp;			MultiPoint _multipointA, MultiPoint _multipointB, double tolerance,
&nbsp;			boolean bPerformWithin, boolean bPerformEquals,
&nbsp;			boolean bPerformOverlaps, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		boolean bPerformContains = false;</b>
&nbsp;		MultiPoint multipoint_a;
&nbsp;		MultiPoint multipoint_b;
&nbsp;
<b class="fc">&nbsp;		if (_multipointA.getPointCount() &gt; _multipointB.getPointCount()) {</b>
<b class="fc">&nbsp;			if (bPerformWithin) {</b>
<b class="fc">&nbsp;				bPerformWithin = false;</b>
<b class="fc">&nbsp;				bPerformContains = true;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			multipoint_a = _multipointB;</b>
<b class="fc">&nbsp;			multipoint_b = _multipointA;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			multipoint_a = _multipointA;</b>
<b class="fc">&nbsp;			multipoint_b = _multipointB;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt8 contained = null;</b>
&nbsp;
<b class="fc">&nbsp;		if (bPerformEquals || bPerformOverlaps || bPerformContains) {</b>
<b class="fc">&nbsp;			contained = new AttributeStreamOfInt8(multipoint_b.getPointCount());</b>
&nbsp;
<b class="fc">&nbsp;			for (int i = 0; i &lt; multipoint_b.getPointCount(); i++)</b>
<b class="fc">&nbsp;				contained.write(i, (byte) 0);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptA = new Point2D();</b>
<b class="fc">&nbsp;		Point2D ptB = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		boolean bWithin = true; // starts off true by default</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;				(MultiPointImpl) (multipoint_b._getImpl()), envInter);</b>
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</b>
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		for (int vertex_a = 0; vertex_a &lt; multipoint_a.getPointCount(); vertex_a++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(vertex_a, ptA);</b>
&nbsp;
<b class="fc">&nbsp;			if (!envInter.contains(ptA)) {</b>
<b class="fc">&nbsp;				if (bPerformEquals || bPerformWithin)</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				else {
<b class="fc">&nbsp;					bWithin = false;</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			boolean bPtACovered = false;</b>
<b class="fc">&nbsp;			env_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);</b>
<b class="fc">&nbsp;			qtIterB.resetIterator(env_a, tolerance);</b>
<b class="fc">&nbsp;			for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</b>
<b class="fc">&nbsp;					.next()) {</b>
<b class="fc">&nbsp;				int vertex_b = quadTreeB.getElement(elementHandleB);</b>
<b class="fc">&nbsp;				multipoint_b.getXY(vertex_b, ptB);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptA, ptB) &lt;= tolerance_sq) {</b>
<b class="fc">&nbsp;					if (bPerformEquals || bPerformOverlaps || bPerformContains)</b>
<b class="fc">&nbsp;						contained.write(vertex_b, (byte) 1);</b>
&nbsp;
<b class="fc">&nbsp;					bPtACovered = true;</b>
&nbsp;
<b class="fc">&nbsp;					if (bPerformWithin)</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (!bPtACovered) {</b>
<b class="fc">&nbsp;				bWithin = false;</b>
&nbsp;
<b class="fc">&nbsp;				if (bPerformEquals || bPerformWithin)</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (bPerformOverlaps &amp;&amp; bWithin)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (bPerformWithin)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			if (contained.read(i) == 1) {</b>
<b class="fc">&nbsp;				if (bPerformOverlaps)</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				if (bPerformEquals || bPerformContains)</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (bPerformOverlaps)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipoint_a intersects multipoint_b.
&nbsp;	private static boolean multiPointIntersectsMultiPoint_(
&nbsp;			MultiPoint _multipointA, MultiPoint _multipointB, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
&nbsp;		MultiPoint multipoint_a;
&nbsp;		MultiPoint multipoint_b;
&nbsp;
<b class="fc">&nbsp;		if (_multipointA.getPointCount() &gt; _multipointB.getPointCount()) {</b>
<b class="fc">&nbsp;			multipoint_a = _multipointB;</b>
<b class="fc">&nbsp;			multipoint_b = _multipointA;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			multipoint_a = _multipointA;</b>
<b class="fc">&nbsp;			multipoint_b = _multipointB;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		multipoint_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptA = new Point2D();</b>
<b class="fc">&nbsp;		Point2D ptB = new Point2D();</b>
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl quadTreeB = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;				(MultiPointImpl) (multipoint_b._getImpl()), envInter);</b>
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;		for (int vertex_a = 0; vertex_a &lt; multipoint_a.getPointCount(); vertex_a++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(vertex_a, ptA);</b>
&nbsp;
<b class="fc">&nbsp;			if (!envInter.contains(ptA))</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			env_a.setCoords(ptA.x, ptA.y, ptA.x, ptA.y);</b>
<b class="fc">&nbsp;			qtIterB.resetIterator(env_a, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</b>
<b class="nc">&nbsp;					.next()) {</b>
<b class="fc">&nbsp;				int vertex_b = quadTreeB.getElement(elementHandleB);</b>
<b class="fc">&nbsp;				multipoint_b.getXY(vertex_b, ptB);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptA, ptB) &lt;= tolerance_sq)</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if multipathA equals multipathB.
&nbsp;	private static boolean linearPathEqualsLinearPath_(MultiPath multipathA,
&nbsp;			MultiPath multipathB, double tolerance, boolean bEnforceOrientation) {
<b class="fc">&nbsp;		return linearPathWithinLinearPath_(multipathA, multipathB, tolerance, bEnforceOrientation)</b>
<b class="fc">&nbsp;				&amp;&amp; linearPathWithinLinearPath_(multipathB, multipathA,</b>
<b class="fc">&nbsp;						tolerance, bEnforceOrientation);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the segments of multipathA are within the segments of
&nbsp;	// multipathB.
&nbsp;	private static boolean linearPathWithinLinearPath_(MultiPath multipathA,
&nbsp;			MultiPath multipathB, double tolerance, boolean bEnforceOrientation) {
<b class="fc">&nbsp;		boolean bWithin = true;</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		int ievent = 0;</b>
<b class="fc">&nbsp;		AttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		RelationalOperations relOps = new RelationalOperations();</b>
<b class="fc">&nbsp;		OverlapComparer overlapComparer = new OverlapComparer(relOps);</b>
&nbsp;		OverlapEvent overlapEvent;
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		multipathA.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipathB.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl qtB = null;</b>
<b class="fc">&nbsp;		QuadTreeImpl quadTreeB = null;</b>
<b class="fc">&nbsp;        QuadTreeImpl quadTreePathsB = null;</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="fc">&nbsp;			quadTreeB = accel.getQuadTree();</b>
<b class="fc">&nbsp;            quadTreePathsB = accel.getQuadTreeForPaths();</b>
<b class="fc">&nbsp;			if (quadTreeB == null) {</b>
<b class="fc">&nbsp;				qtB = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;						(MultiPathImpl) multipathB._getImpl(), envInter);</b>
<b class="fc">&nbsp;				quadTreeB = qtB;</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			qtB = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;					(MultiPathImpl) multipathB._getImpl(), envInter);</b>
<b class="fc">&nbsp;			quadTreeB = qtB;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;</b>
<b class="fc">&nbsp;        if (quadTreePathsB != null)</b>
<b class="nc">&nbsp;            qtIterPathsB = quadTreePathsB.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;		while (segIterA.nextPath()) {</b>
<b class="fc">&nbsp;			while (segIterA.hasNextSegment()) {</b>
<b class="fc">&nbsp;				boolean bStringOfSegmentAsCovered = false;</b>
&nbsp;
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;				segmentA.queryEnvelope2D(env_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_a.isIntersecting(envInter)) {</b>
<b class="nc">&nbsp;					return false; // bWithin = false</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;                if (qtIterPathsB != null) {</b>
<b class="nc">&nbsp;                    qtIterPathsB.resetIterator(env_a, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                    if (qtIterPathsB.next() == -1) {</b>
<b class="nc">&nbsp;                        bWithin = false;</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;				double lengthA = segmentA.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				qtIterB.resetIterator(segmentA, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;				for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</b>
<b class="fc">&nbsp;						.next()) {</b>
<b class="fc">&nbsp;					int vertex_b = quadTreeB.getElement(elementHandleB);</b>
<b class="fc">&nbsp;					segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;					Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;					int result = segmentA.intersect(segmentB, null, scalarsA,</b>
<b class="fc">&nbsp;							scalarsB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;					if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</b>
<b class="fc">&nbsp;						double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;						double scalar_a_1 = scalarsA[1];</b>
<b class="fc">&nbsp;						double scalar_b_0 = scalarsB[0];</b>
<b class="fc">&nbsp;						double scalar_b_1 = scalarsB[1];</b>
&nbsp;
&nbsp;						// Performance enhancement for nice cases where
&nbsp;						// localization occurs. Increment segIterA as far as we
&nbsp;						// can while the current segmentA is covered.
<b class="fc">&nbsp;						if (scalar_a_0 * lengthA &lt;= tolerance</b>
<b class="fc">&nbsp;								&amp;&amp; (1.0 - scalar_a_1) * lengthA &lt;= tolerance) {</b>
<b class="fc">&nbsp;							bStringOfSegmentAsCovered = true;</b>
&nbsp;
<b class="fc">&nbsp;							ievent = 0;</b>
<b class="fc">&nbsp;							eventIndices.resize(0);</b>
<b class="fc">&nbsp;							relOps.m_overlap_events.clear();</b>
&nbsp;
<b class="fc">&nbsp;							int ivertex_a = segIterA.getStartPointIndex();</b>
<b class="fc">&nbsp;							boolean bSegmentACovered = true;</b>
&nbsp;
<b class="fc">&nbsp;							while (bSegmentACovered) {// keep going while the</b>
&nbsp;								// current segmentA is
&nbsp;								// covered.
<b class="fc">&nbsp;								if (segIterA.hasNextSegment()) {</b>
<b class="fc">&nbsp;									segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;									lengthA = segmentA.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;									result = segmentA.intersect(segmentB, null,</b>
<b class="fc">&nbsp;											scalarsA, scalarsB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;									if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</b>
<b class="fc">&nbsp;										scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;										scalar_a_1 = scalarsA[1];</b>
&nbsp;
<b class="fc">&nbsp;										if (scalar_a_0 * lengthA &lt;= tolerance</b>
<b class="fc">&nbsp;												&amp;&amp; (1.0 - scalar_a_1) * lengthA &lt;= tolerance) {</b>
<b class="fc">&nbsp;											ivertex_a = segIterA</b>
<b class="fc">&nbsp;													.getStartPointIndex();</b>
<b class="fc">&nbsp;											continue;</b>
&nbsp;										}
&nbsp;									}
&nbsp;
<b class="fc">&nbsp;									if (segIterB.hasNextSegment()) {</b>
<b class="fc">&nbsp;										segmentB = segIterB.nextSegment();</b>
<b class="fc">&nbsp;										result = segmentA.intersect(segmentB,</b>
<b class="fc">&nbsp;												null, scalarsA, scalarsB,</b>
<b class="fc">&nbsp;												tolerance);</b>
&nbsp;
<b class="fc">&nbsp;										if (result == 2 &amp;&amp; (!bEnforceOrientation || scalarsB[0] &lt;= scalarsB[1])) {</b>
<b class="fc">&nbsp;											scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;											scalar_a_1 = scalarsA[1];</b>
&nbsp;
<b class="fc">&nbsp;											if (scalar_a_0 * lengthA &lt;= tolerance</b>
<b class="fc">&nbsp;													&amp;&amp; (1.0 - scalar_a_1)</b>
<b class="fc">&nbsp;															* lengthA &lt;= tolerance) {</b>
<b class="fc">&nbsp;												ivertex_a = segIterA</b>
<b class="fc">&nbsp;														.getStartPointIndex();</b>
<b class="fc">&nbsp;												continue;</b>
&nbsp;											}
&nbsp;										}
&nbsp;									}
&nbsp;								}
&nbsp;
<b class="fc">&nbsp;								bSegmentACovered = false;</b>
&nbsp;							}
&nbsp;
<b class="fc">&nbsp;							if (ivertex_a != segIterA.getStartPointIndex()) {</b>
<b class="fc">&nbsp;								segIterA.resetToVertex(ivertex_a);</b>
<b class="fc">&nbsp;								segIterA.nextSegment();</b>
&nbsp;							}
&nbsp;
<b class="fc">&nbsp;							break;</b>
&nbsp;						} else {
<b class="fc">&nbsp;							int ivertex_a = segIterA.getStartPointIndex();</b>
<b class="fc">&nbsp;							int ipath_a = segIterA.getPathIndex();</b>
<b class="fc">&nbsp;							int ivertex_b = segIterB.getStartPointIndex();</b>
<b class="fc">&nbsp;							int ipath_b = segIterB.getPathIndex();</b>
&nbsp;
<b class="fc">&nbsp;							overlapEvent = OverlapEvent.construct(ivertex_a,</b>
<b class="fc">&nbsp;									ipath_a, scalar_a_0, scalar_a_1, ivertex_b,</b>
<b class="fc">&nbsp;									ipath_b, scalar_b_0, scalar_b_1);</b>
<b class="fc">&nbsp;							relOps.m_overlap_events.add(overlapEvent);</b>
<b class="fc">&nbsp;							eventIndices.add(eventIndices.size());</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (bStringOfSegmentAsCovered) {</b>
<b class="fc">&nbsp;					continue; // no need to check that segmentA is covered</b>
&nbsp;				}
<b class="fc">&nbsp;				if (ievent == relOps.m_overlap_events.size()) {</b>
<b class="fc">&nbsp;					return false; // bWithin = false</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (eventIndices.size() - ievent &gt; 1) {</b>
<b class="fc">&nbsp;					eventIndices.Sort(ievent, eventIndices.size(),</b>
<b class="fc">&nbsp;							overlapComparer);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				double lastScalar = 0.0;</b>
&nbsp;
<b class="fc">&nbsp;				for (int i = ievent; i &lt; relOps.m_overlap_events.size(); i++) {</b>
<b class="fc">&nbsp;					overlapEvent = relOps.m_overlap_events.get(eventIndices</b>
<b class="fc">&nbsp;							.get(i));</b>
&nbsp;
<b class="fc">&nbsp;					if (overlapEvent.m_scalar_a_0 &lt; lastScalar</b>
<b class="nc">&nbsp;							&amp;&amp; overlapEvent.m_scalar_a_1 &lt; lastScalar) {</b>
<b class="nc">&nbsp;						continue;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) &gt; tolerance) {</b>
<b class="nc">&nbsp;						return false; // bWithin = false</b>
&nbsp;					} else {
<b class="fc">&nbsp;						lastScalar = overlapEvent.m_scalar_a_1;</b>
&nbsp;
<b class="fc">&nbsp;						if (lengthA * (1.0 - lastScalar) &lt;= tolerance</b>
<b class="fc">&nbsp;								|| lastScalar == 1.0) {</b>
<b class="nc">&nbsp;							break;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (lengthA * (1.0 - lastScalar) &gt; tolerance) {</b>
<b class="nc">&nbsp;					return false; // bWithin = false</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				ievent = 0;</b>
<b class="fc">&nbsp;				eventIndices.resize(0);</b>
<b class="fc">&nbsp;				relOps.m_overlap_events.clear();</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return bWithin;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the segments of multipathA overlap the segments of
&nbsp;	// multipathB.
&nbsp;	private static boolean linearPathOverlapsLinearPath_(MultiPath multipathA,
&nbsp;			MultiPath multipathB, double tolerance) {
<b class="fc">&nbsp;		int dim = linearPathIntersectsLinearPathMaxDim_(multipathA, multipathB,</b>
<b class="fc">&nbsp;				tolerance, null);</b>
&nbsp;
<b class="fc">&nbsp;		if (dim &lt; 1)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		multipathA.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipathB.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		boolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);</b>
<b class="fc">&nbsp;		boolean bIntBExtA = interiorEnvExteriorEnv_(env_b, env_a, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (bIntAExtB &amp;&amp; bIntBExtA)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (bIntAExtB &amp;&amp; !bIntBExtA)</b>
<b class="fc">&nbsp;			return !linearPathWithinLinearPath_(multipathB, multipathA,</b>
<b class="fc">&nbsp;					tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (bIntBExtA &amp;&amp; !bIntAExtB)</b>
<b class="fc">&nbsp;			return !linearPathWithinLinearPath_(multipathA, multipathB,</b>
<b class="fc">&nbsp;					tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		return !linearPathWithinLinearPath_(multipathA, multipathB, tolerance, false)</b>
<b class="nc">&nbsp;				&amp;&amp; !linearPathWithinLinearPath_(multipathB, multipathA,</b>
<b class="nc">&nbsp;						tolerance, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true the dimension of intersection of _multipathA and
&nbsp;	// _multipathB.
&nbsp;	static int linearPathIntersectsLinearPathMaxDim_(MultiPath _multipathA,
&nbsp;			MultiPath _multipathB, double tolerance,
&nbsp;			AttributeStreamOfDbl intersections) {
&nbsp;		MultiPath multipathA;
&nbsp;		MultiPath multipathB;
&nbsp;
<b class="fc">&nbsp;		if (_multipathA.getSegmentCount() &gt; _multipathB.getSegmentCount()) {</b>
<b class="fc">&nbsp;			multipathA = _multipathB;</b>
<b class="fc">&nbsp;			multipathB = _multipathA;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			multipathA = _multipathA;</b>
<b class="fc">&nbsp;			multipathB = _multipathB;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = ((MultiPathImpl) multipathB._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		int dim = -1;</b>
&nbsp;
<b class="fc">&nbsp;		int ievent = 0;</b>
&nbsp;		double overlapLength;
<b class="fc">&nbsp;		AttributeStreamOfInt32 eventIndices = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		RelationalOperations relOps = new RelationalOperations();</b>
<b class="fc">&nbsp;		OverlapComparer overlapComparer = new OverlapComparer(relOps);</b>
&nbsp;		OverlapEvent overlapEvent;
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		multipathA.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipathB.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		Point2D int_point = null;</b>
&nbsp;
<b class="fc">&nbsp;		if (intersections != null) {</b>
<b class="fc">&nbsp;			int_point = new Point2D();</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl qtB = null;</b>
<b class="fc">&nbsp;		QuadTreeImpl quadTreeB = null;</b>
<b class="fc">&nbsp;        QuadTreeImpl quadTreePathsB = null;</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) multipathB._getImpl())</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="nc">&nbsp;			quadTreeB = accel.getQuadTree();</b>
<b class="nc">&nbsp;            quadTreePathsB = accel.getQuadTreeForPaths();</b>
<b class="nc">&nbsp;			if (quadTreeB == null) {</b>
<b class="nc">&nbsp;				qtB = InternalUtils.buildQuadTree(</b>
<b class="nc">&nbsp;						(MultiPathImpl) multipathB._getImpl(), envInter);</b>
<b class="nc">&nbsp;				quadTreeB = qtB;</b>
&nbsp;			}
<b class="nc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			qtB = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;					(MultiPathImpl) multipathB._getImpl(), envInter);</b>
<b class="fc">&nbsp;			quadTreeB = qtB;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterB = quadTreeB.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsB = null;</b>
<b class="fc">&nbsp;        if (quadTreePathsB != null)</b>
<b class="nc">&nbsp;            qtIterPathsB = quadTreePathsB.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;		while (segIterA.nextPath()) {</b>
<b class="fc">&nbsp;			overlapLength = 0.0;</b>
&nbsp;
<b class="fc">&nbsp;			while (segIterA.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;				segmentA.queryEnvelope2D(env_a);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_a.isIntersecting(envInter)) {</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;                if (qtIterPathsB != null) {</b>
<b class="nc">&nbsp;                    qtIterPathsB.resetIterator(env_a, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                    if (qtIterPathsB.next() == -1)</b>
<b class="nc">&nbsp;                        continue;</b>
&nbsp;                }
&nbsp;
<b class="fc">&nbsp;				double lengthA = segmentA.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				qtIterB.resetIterator(segmentA, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;				for (int elementHandleB = qtIterB.next(); elementHandleB != -1; elementHandleB = qtIterB</b>
<b class="fc">&nbsp;						.next()) {</b>
<b class="fc">&nbsp;					int vertex_b = quadTreeB.getElement(elementHandleB);</b>
<b class="fc">&nbsp;					segIterB.resetToVertex(vertex_b);</b>
&nbsp;
<b class="fc">&nbsp;					Segment segmentB = segIterB.nextSegment();</b>
<b class="fc">&nbsp;					double lengthB = segmentB.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;					int result = segmentA.intersect(segmentB, null, scalarsA,</b>
<b class="fc">&nbsp;							scalarsB, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;					if (result &gt; 0) {</b>
<b class="fc">&nbsp;						double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;						double scalar_b_0 = scalarsB[0];</b>
<b class="fc">&nbsp;						double scalar_a_1 = (result == 2 ? scalarsA[1]</b>
<b class="fc">&nbsp;								: NumberUtils.TheNaN);</b>
<b class="fc">&nbsp;						double scalar_b_1 = (result == 2 ? scalarsB[1]</b>
<b class="fc">&nbsp;								: NumberUtils.TheNaN);</b>
&nbsp;
<b class="fc">&nbsp;						if (result == 2) {</b>
<b class="fc">&nbsp;							if (lengthA * (scalar_a_1 - scalar_a_0) &gt; tolerance) {</b>
<b class="fc">&nbsp;								dim = 1;</b>
<b class="fc">&nbsp;								return dim;</b>
&nbsp;							}
&nbsp;
&nbsp;							// Quick neighbor check
<b class="nc">&nbsp;							double length = lengthA * (scalar_a_1 - scalar_a_0);</b>
&nbsp;
<b class="nc">&nbsp;							if (segIterB.hasNextSegment()) {</b>
<b class="nc">&nbsp;								segmentB = segIterB.nextSegment();</b>
<b class="nc">&nbsp;								result = segmentA.intersect(segmentB, null,</b>
<b class="nc">&nbsp;										scalarsA, null, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;								if (result == 2) {</b>
<b class="nc">&nbsp;									double nextScalarA0 = scalarsA[0];</b>
<b class="nc">&nbsp;									double nextScalarA1 = scalarsA[1];</b>
&nbsp;
<b class="nc">&nbsp;									double lengthNext = lengthA</b>
<b class="nc">&nbsp;											* (nextScalarA1 - nextScalarA0);</b>
&nbsp;
<b class="nc">&nbsp;									if (length + lengthNext &gt; tolerance) {</b>
<b class="nc">&nbsp;										dim = 1;</b>
<b class="nc">&nbsp;										return dim;</b>
&nbsp;									}
&nbsp;								}
&nbsp;
<b class="nc">&nbsp;								segIterB.resetToVertex(vertex_b);</b>
<b class="nc">&nbsp;								segIterB.nextSegment();</b>
&nbsp;							}
&nbsp;
<b class="nc">&nbsp;							if (!segIterB.isFirstSegmentInPath()) {</b>
<b class="nc">&nbsp;								segIterB.previousSegment();</b>
<b class="nc">&nbsp;								segmentB = segIterB.previousSegment();</b>
<b class="nc">&nbsp;								result = segmentA.intersect(segmentB, null,</b>
<b class="nc">&nbsp;										scalarsA, null, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;								if (result == 2) {</b>
<b class="nc">&nbsp;									double nextScalarA0 = scalarsA[0];</b>
<b class="nc">&nbsp;									double nextScalarA1 = scalarsA[1];</b>
&nbsp;
<b class="nc">&nbsp;									double lengthPrevious = lengthA</b>
<b class="nc">&nbsp;											* (nextScalarA1 - nextScalarA0);</b>
&nbsp;
<b class="nc">&nbsp;									if (length + lengthPrevious &gt; tolerance) {</b>
<b class="nc">&nbsp;										dim = 1;</b>
<b class="nc">&nbsp;										return dim;</b>
&nbsp;									}
&nbsp;								}
&nbsp;
<b class="nc">&nbsp;								segIterB.resetToVertex(vertex_b);</b>
<b class="nc">&nbsp;								segIterB.nextSegment();</b>
&nbsp;							}
&nbsp;
<b class="nc">&nbsp;							if (segIterA.hasNextSegment()) {</b>
<b class="nc">&nbsp;								int vertex_a = segIterA.getStartPointIndex();</b>
<b class="nc">&nbsp;								segmentA = segIterA.nextSegment();</b>
<b class="nc">&nbsp;								result = segmentA.intersect(segmentB, null,</b>
<b class="nc">&nbsp;										scalarsA, null, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;								if (result == 2) {</b>
<b class="nc">&nbsp;									double nextScalarA0 = scalarsA[0];</b>
<b class="nc">&nbsp;									double nextScalarA1 = scalarsA[1];</b>
&nbsp;
<b class="nc">&nbsp;									double lengthNext = lengthA</b>
<b class="nc">&nbsp;											* (nextScalarA1 - nextScalarA0);</b>
&nbsp;
<b class="nc">&nbsp;									if (length + lengthNext &gt; tolerance) {</b>
<b class="nc">&nbsp;										dim = 1;</b>
<b class="nc">&nbsp;										return dim;</b>
&nbsp;									}
&nbsp;								}
&nbsp;
<b class="nc">&nbsp;								segIterA.resetToVertex(vertex_a);</b>
<b class="nc">&nbsp;								segIterA.nextSegment();</b>
&nbsp;							}
&nbsp;
<b class="nc">&nbsp;							if (!segIterA.isFirstSegmentInPath()) {</b>
<b class="nc">&nbsp;								int vertex_a = segIterA.getStartPointIndex();</b>
<b class="nc">&nbsp;								segIterA.previousSegment();</b>
<b class="nc">&nbsp;								segmentA = segIterA.previousSegment();</b>
<b class="nc">&nbsp;								result = segmentA.intersect(segmentB, null,</b>
<b class="nc">&nbsp;										scalarsA, null, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;								if (result == 2) {</b>
<b class="nc">&nbsp;									double nextScalarA0 = scalarsA[0];</b>
<b class="nc">&nbsp;									double nextScalarA1 = scalarsA[1];</b>
&nbsp;
<b class="nc">&nbsp;									double lengthPrevious = lengthB</b>
<b class="nc">&nbsp;											* (nextScalarA1 - nextScalarA0);</b>
&nbsp;
<b class="nc">&nbsp;									if (length + lengthPrevious &gt; tolerance) {</b>
<b class="nc">&nbsp;										dim = 1;</b>
<b class="nc">&nbsp;										return dim;</b>
&nbsp;									}
&nbsp;								}
&nbsp;
<b class="nc">&nbsp;								segIterA.resetToVertex(vertex_a);</b>
<b class="nc">&nbsp;								segIterA.nextSegment();</b>
&nbsp;							}
&nbsp;
<b class="nc">&nbsp;							int ivertex_a = segIterA.getStartPointIndex();</b>
<b class="nc">&nbsp;							int ipath_a = segIterA.getPathIndex();</b>
<b class="nc">&nbsp;							int ivertex_b = segIterB.getStartPointIndex();</b>
<b class="nc">&nbsp;							int ipath_b = segIterB.getPathIndex();</b>
&nbsp;
<b class="nc">&nbsp;							overlapEvent = OverlapEvent.construct(ivertex_a,</b>
<b class="nc">&nbsp;									ipath_a, scalar_a_0, scalar_a_1, ivertex_b,</b>
<b class="nc">&nbsp;									ipath_b, scalar_b_0, scalar_b_1);</b>
<b class="nc">&nbsp;							relOps.m_overlap_events.add(overlapEvent);</b>
<b class="nc">&nbsp;							eventIndices.add(eventIndices.size());</b>
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						dim = 0;</b>
&nbsp;
<b class="fc">&nbsp;						if (intersections != null) {</b>
<b class="fc">&nbsp;							segmentA.getCoord2D(scalar_a_0, int_point);</b>
<b class="fc">&nbsp;							intersections.add(int_point.x);</b>
<b class="fc">&nbsp;							intersections.add(int_point.y);</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (ievent &lt; relOps.m_overlap_events.size()) {</b>
<b class="nc">&nbsp;					eventIndices.Sort(ievent, eventIndices.size(),</b>
<b class="nc">&nbsp;							overlapComparer);</b>
&nbsp;
<b class="nc">&nbsp;					double lastScalar = 0.0;</b>
<b class="nc">&nbsp;					int lastPath = relOps.m_overlap_events.get(eventIndices</b>
<b class="nc">&nbsp;							.get(ievent)).m_ipath_a;</b>
&nbsp;
<b class="nc">&nbsp;					for (int i = ievent; i &lt; relOps.m_overlap_events.size(); i++) {</b>
<b class="nc">&nbsp;						overlapEvent = relOps.m_overlap_events.get(eventIndices</b>
<b class="nc">&nbsp;								.get(i));</b>
&nbsp;
<b class="nc">&nbsp;						if (overlapEvent.m_scalar_a_0 &lt; lastScalar</b>
<b class="nc">&nbsp;								&amp;&amp; overlapEvent.m_scalar_a_1 &lt; lastScalar) {</b>
<b class="nc">&nbsp;							continue;</b>
&nbsp;						}
&nbsp;
<b class="nc">&nbsp;						if (lengthA * (overlapEvent.m_scalar_a_0 - lastScalar) &gt; tolerance) {</b>
<b class="nc">&nbsp;							overlapLength = lengthA</b>
<b class="nc">&nbsp;									* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset</b>
<b class="nc">&nbsp;							lastScalar = overlapEvent.m_scalar_a_1;</b>
<b class="nc">&nbsp;							lastPath = overlapEvent.m_ipath_a;</b>
<b class="nc">&nbsp;						} else {</b>
<b class="nc">&nbsp;							if (overlapEvent.m_ipath_a != lastPath) {</b>
<b class="nc">&nbsp;								overlapLength = lengthA</b>
<b class="nc">&nbsp;										* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // reset</b>
<b class="nc">&nbsp;								lastPath = overlapEvent.m_ipath_a;</b>
<b class="nc">&nbsp;							} else {</b>
<b class="nc">&nbsp;								overlapLength += lengthA</b>
<b class="nc">&nbsp;										* (overlapEvent.m_scalar_a_1 - overlapEvent.m_scalar_a_0); // accumulate</b>
&nbsp;							}
<b class="nc">&nbsp;							if (overlapLength &gt; tolerance) {</b>
<b class="nc">&nbsp;								dim = 1;</b>
<b class="nc">&nbsp;								return dim;</b>
&nbsp;							}
&nbsp;
<b class="nc">&nbsp;							lastScalar = overlapEvent.m_scalar_a_1;</b>
&nbsp;
<b class="nc">&nbsp;							if (lastScalar == 1.0) {</b>
<b class="nc">&nbsp;								break;</b>
&nbsp;							}
&nbsp;						}
&nbsp;					}
&nbsp;
<b class="nc">&nbsp;					if (lengthA * (1.0 - lastScalar) &gt; tolerance) {</b>
<b class="nc">&nbsp;						overlapLength = 0.0; // reset</b>
&nbsp;					}
<b class="nc">&nbsp;					ievent = 0;</b>
<b class="nc">&nbsp;					eventIndices.resize(0);</b>
<b class="nc">&nbsp;					relOps.m_overlap_events.clear();</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return dim;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the line segments of _multipathA intersect the line
&nbsp;	// segments of _multipathB.
&nbsp;	private static boolean linearPathIntersectsLinearPath_(
&nbsp;			MultiPath multipathA, MultiPath multipathB, double tolerance) {
<b class="fc">&nbsp;		MultiPathImpl multi_path_impl_a = (MultiPathImpl) multipathA._getImpl();</b>
<b class="fc">&nbsp;		MultiPathImpl multi_path_impl_b = (MultiPathImpl) multipathB._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = multi_path_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(multi_path_impl_a, multi_path_impl_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		while (intersector.next()) {</b>
<b class="fc">&nbsp;			int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;			int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;			segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;			segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;			Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;			Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			int result = segmentB.intersect(segmentA, null, null, null,</b>
<b class="fc">&nbsp;					tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result &gt; 0) {</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the relation intersects, crosses, or contains holds
&nbsp;	// between multipathA and multipoint_b. multipathA is put in the
&nbsp;	// Quad_tree_impl.
&nbsp;	private static boolean linearPathIntersectsMultiPoint_(
&nbsp;			MultiPath multipathA, MultiPoint multipoint_b, double tolerance,
&nbsp;			boolean b_intersects_all) {
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;		Envelope2D envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		multipathA.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		multipoint_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		env_b.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl qtA = null;</b>
<b class="fc">&nbsp;		QuadTreeImpl quadTreeA = null;</b>
<b class="fc">&nbsp;        QuadTreeImpl quadTreePathsA = null;</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="fc">&nbsp;			quadTreeA = accel.getQuadTree();</b>
<b class="fc">&nbsp;			quadTreePathsA = accel.getQuadTreeForPaths();</b>
<b class="fc">&nbsp;			if (quadTreeA == null) {</b>
<b class="fc">&nbsp;				qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;						(MultiPathImpl) multipathA._getImpl(), envInter);</b>
<b class="fc">&nbsp;				quadTreeA = qtA;</b>
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			qtA = InternalUtils.buildQuadTree(</b>
<b class="fc">&nbsp;					(MultiPathImpl) multipathA._getImpl(), envInter);</b>
<b class="fc">&nbsp;			quadTreeA = qtA;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		QuadTreeImpl.QuadTreeIteratorImpl qtIterA = quadTreeA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;        QuadTreeImpl.QuadTreeIteratorImpl qtIterPathsA = null;</b>
<b class="fc">&nbsp;        if (quadTreePathsA != null)</b>
<b class="nc">&nbsp;            qtIterPathsA = quadTreePathsA.getIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Point2D ptB = new Point2D(), closest = new Point2D();</b>
<b class="fc">&nbsp;		double toleranceSq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_b.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_b.getXY(i, ptB);</b>
&nbsp;
<b class="fc">&nbsp;			if (!envInter.contains(ptB)) {</b>
<b class="nc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			env_b.setCoords(ptB.x, ptB.y, ptB.x, ptB.y);</b>
&nbsp;
<b class="fc">&nbsp;            if (qtIterPathsA != null) {</b>
<b class="nc">&nbsp;                qtIterPathsA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="nc">&nbsp;                if (qtIterPathsA.next() == -1)</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;			qtIterA.resetIterator(env_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			boolean b_covered = false;</b>
&nbsp;
<b class="fc">&nbsp;			for (int elementHandleA = qtIterA.next(); elementHandleA != -1; elementHandleA = qtIterA</b>
<b class="fc">&nbsp;					.next()) {</b>
<b class="fc">&nbsp;				int vertex_a = quadTreeA.getElement(elementHandleA);</b>
<b class="fc">&nbsp;				segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;				double t = segmentA.getClosestCoordinate(ptB, false);</b>
<b class="fc">&nbsp;				segmentA.getCoord2D(t, closest);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(closest, ptB) &lt;= toleranceSq) {</b>
<b class="fc">&nbsp;					b_covered = true;</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (b_intersects_all) {</b>
<b class="fc">&nbsp;				if (!b_covered) {</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				if (b_covered) {</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (b_intersects_all) {</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if a segment of multipathA intersects point_b.
&nbsp;	static boolean linearPathIntersectsPoint_(MultiPath multipathA,
&nbsp;			Point2D ptB, double tolerance) {
<b class="fc">&nbsp;		Point2D closest = new Point2D();</b>
<b class="fc">&nbsp;		double toleranceSq = tolerance * tolerance;</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		GeometryAccelerators accel = ((MultiPathImpl) multipathA._getImpl())</b>
<b class="fc">&nbsp;				._getAccelerators();</b>
&nbsp;
<b class="fc">&nbsp;		if (accel != null) {</b>
<b class="fc">&nbsp;			QuadTreeImpl quadTreeA = accel.getQuadTree();</b>
<b class="fc">&nbsp;			if (quadTreeA != null) {</b>
<b class="fc">&nbsp;				Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;				env_b.setCoords(ptB);</b>
&nbsp;
<b class="fc">&nbsp;				QuadTreeImpl.QuadTreeIteratorImpl qt_iter = quadTreeA</b>
<b class="fc">&nbsp;						.getIterator(env_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;				for (int e = qt_iter.next(); e != -1; e = qt_iter.next()) {</b>
<b class="fc">&nbsp;					segIterA.resetToVertex(quadTreeA.getElement(e));</b>
&nbsp;
<b class="fc">&nbsp;					if (segIterA.hasNextSegment()) {</b>
<b class="fc">&nbsp;						Segment segmentA = segIterA.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;						double t = segmentA.getClosestCoordinate(ptB, false);</b>
<b class="fc">&nbsp;						segmentA.getCoord2D(t, closest);</b>
&nbsp;
<b class="fc">&nbsp;						if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</b>
<b class="fc">&nbsp;							return true;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;		while (segIterA.nextPath()) {</b>
<b class="fc">&nbsp;			while (segIterA.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;				segmentA.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;				env_a.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;				if (!env_a.contains(ptB)) {</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				double t = segmentA.getClosestCoordinate(ptB, false);</b>
<b class="fc">&nbsp;				segmentA.getCoord2D(t, closest);</b>
&nbsp;
<b class="fc">&nbsp;				if (Point2D.sqrDistance(ptB, closest) &lt;= toleranceSq) {</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean linearPathContainsPoint_(MultiPath multipathA,
&nbsp;			Point2D pt_b, double tolerance) {
<b class="fc">&nbsp;		return linearPathIntersectsPoint_(multipathA, pt_b, tolerance)</b>
<b class="fc">&nbsp;				&amp;&amp; !linearPathTouchesPointImpl_(multipathA, pt_b, tolerance);</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean linearPathTouchesPointImpl_(MultiPath multipathA,
&nbsp;			Point2D ptB, double tolerance) {
<b class="fc">&nbsp;		MultiPoint boundary = (MultiPoint) (multipathA.getBoundary());</b>
<b class="fc">&nbsp;		return !multiPointDisjointPointImpl_(boundary, ptB, tolerance, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if the segments of multipathA intersects env_b
&nbsp;	private static boolean linearPathIntersectsEnvelope_(MultiPath multipath_a,
&nbsp;			Envelope2D env_b, double tolerance, ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		if (!multipath_a.hasNonLinearSegments()) {</b>
<b class="fc">&nbsp;			Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;			env_b_inflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			env_b_inflated.inflate(tolerance, tolerance);</b>
<b class="fc">&nbsp;			MultiPathImpl mimpl_a = (MultiPathImpl) multipath_a._getImpl();</b>
<b class="fc">&nbsp;			AttributeStreamOfDbl xy = (AttributeStreamOfDbl) (mimpl_a</b>
<b class="fc">&nbsp;					.getAttributeStreamRef(VertexDescription.Semantics.POSITION));</b>
<b class="fc">&nbsp;			Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;			Point2D pt_prev = new Point2D();</b>
<b class="fc">&nbsp;			Point2D pt_1 = new Point2D();</b>
<b class="fc">&nbsp;			Point2D pt_2 = new Point2D();</b>
<b class="fc">&nbsp;			for (int ipath = 0, npath = mimpl_a.getPathCount(); ipath &lt; npath; ipath++) {</b>
<b class="fc">&nbsp;				boolean b_first = true;</b>
<b class="fc">&nbsp;				for (int i = mimpl_a.getPathStart(ipath), n = mimpl_a</b>
<b class="fc">&nbsp;						.getPathEnd(ipath); i &lt; n; i++) {</b>
<b class="fc">&nbsp;					if (b_first) {</b>
<b class="fc">&nbsp;						xy.read(2 * i, pt_prev);</b>
<b class="fc">&nbsp;						b_first = false;</b>
<b class="fc">&nbsp;						continue;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					xy.read(2 * i, pt);</b>
<b class="fc">&nbsp;					pt_1.setCoords(pt_prev);</b>
<b class="fc">&nbsp;					pt_2.setCoords(pt);</b>
<b class="fc">&nbsp;					if (env_b_inflated.clipLine(pt_1, pt_2) != 0)</b>
<b class="fc">&nbsp;						return true;</b>
&nbsp;
<b class="fc">&nbsp;					pt_prev.setCoords(pt);</b>
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			Line line_1 = new Line(env_b.xmin, env_b.ymin, env_b.xmin,</b>
<b class="nc">&nbsp;					env_b.ymax);</b>
<b class="nc">&nbsp;			Line line_2 = new Line(env_b.xmin, env_b.ymax, env_b.xmax,</b>
<b class="nc">&nbsp;					env_b.ymax);</b>
<b class="nc">&nbsp;			Line line3 = new Line(env_b.xmax, env_b.ymax, env_b.xmax,</b>
<b class="nc">&nbsp;					env_b.ymin);</b>
<b class="nc">&nbsp;			Line line4 = new Line(env_b.xmax, env_b.ymin, env_b.xmin,</b>
<b class="nc">&nbsp;					env_b.ymin);</b>
<b class="nc">&nbsp;			SegmentIterator iter = multipath_a.querySegmentIterator();</b>
<b class="nc">&nbsp;			while (iter.nextPath()) {</b>
<b class="nc">&nbsp;				while (iter.hasNextSegment()) {</b>
<b class="nc">&nbsp;					Segment polySeg = iter.nextSegment();</b>
<b class="nc">&nbsp;					if (polySeg.isIntersecting(line_1, tolerance))</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;
<b class="nc">&nbsp;					if (polySeg.isIntersecting(line_2, tolerance))</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;
<b class="nc">&nbsp;					if (polySeg.isIntersecting(line3, tolerance))</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;
<b class="nc">&nbsp;					if (polySeg.isIntersecting(line4, tolerance))</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns contains, disjoint, or within if the relationship can be
&nbsp;	// determined from the rasterized tests.
&nbsp;	// When bExtraTestForIntersects is true performs extra tests and can return
&nbsp;	// &quot;intersects&quot;.
&nbsp;	static int tryRasterizedContainsOrDisjoint_(Geometry geom_a,
&nbsp;			Geometry geom_b, double tolerance, boolean bExtraTestForIntersects) {
<b class="fc">&nbsp;		int gtA = geom_a.getType().value();</b>
<b class="fc">&nbsp;		int gtB = geom_b.getType().value();</b>
&nbsp;		do {
<b class="fc">&nbsp;			if (Geometry.isMultiVertex(gtA)) {</b>
<b class="fc">&nbsp;				MultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_a</b>
<b class="fc">&nbsp;						._getImpl();</b>
<b class="fc">&nbsp;				GeometryAccelerators accel = impl._getAccelerators();</b>
<b class="fc">&nbsp;				if (accel != null) {</b>
<b class="fc">&nbsp;					RasterizedGeometry2D rgeom = accel.getRasterizedGeometry();</b>
<b class="fc">&nbsp;					if (rgeom != null) {</b>
<b class="fc">&nbsp;						if (gtB == Geometry.GeometryType.Point) {</b>
<b class="fc">&nbsp;							Point2D ptB = ((Point) geom_b).getXY();</b>
<b class="fc">&nbsp;							RasterizedGeometry2D.HitType hit = rgeom</b>
<b class="fc">&nbsp;									.queryPointInGeometry(ptB.x, ptB.y);</b>
<b class="fc">&nbsp;							if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="nc">&nbsp;								return Relation.contains;</b>
<b class="fc">&nbsp;							} else if (hit == RasterizedGeometry2D.HitType.Outside) {</b>
<b class="nc">&nbsp;								return Relation.disjoint;</b>
&nbsp;							}
&nbsp;							break;
&nbsp;						}
<b class="fc">&nbsp;						Envelope2D env_b = new Envelope2D();</b>
<b class="fc">&nbsp;						geom_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;						RasterizedGeometry2D.HitType hit = rgeom</b>
<b class="fc">&nbsp;								.queryEnvelopeInGeometry(env_b);</b>
<b class="fc">&nbsp;						if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="fc">&nbsp;							return Relation.contains;</b>
<b class="fc">&nbsp;						} else if (hit == RasterizedGeometry2D.HitType.Outside) {</b>
<b class="fc">&nbsp;							return Relation.disjoint;</b>
<b class="fc">&nbsp;						} else if (bExtraTestForIntersects</b>
<b class="fc">&nbsp;								&amp;&amp; Geometry.isMultiVertex(gtB)) {</b>
<b class="fc">&nbsp;							if (checkVerticesForIntersection_(</b>
<b class="fc">&nbsp;									(MultiVertexGeometryImpl) geom_b._getImpl(),</b>
<b class="fc">&nbsp;									rgeom)) {</b>
<b class="fc">&nbsp;								return Relation.intersects;</b>
&nbsp;							}
&nbsp;						}
&nbsp;
&nbsp;						break;
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		} while (false);
&nbsp;
&nbsp;		do {
<b class="fc">&nbsp;			if (Geometry.isMultiVertex(gtB)) {</b>
<b class="fc">&nbsp;				MultiVertexGeometryImpl impl = (MultiVertexGeometryImpl) geom_b</b>
<b class="fc">&nbsp;						._getImpl();</b>
<b class="fc">&nbsp;				GeometryAccelerators accel = impl._getAccelerators();</b>
<b class="fc">&nbsp;				if (accel != null) {</b>
<b class="fc">&nbsp;					RasterizedGeometry2D rgeom = accel.getRasterizedGeometry();</b>
<b class="fc">&nbsp;					if (rgeom != null) {</b>
<b class="fc">&nbsp;						if (gtA == Geometry.GeometryType.Point) {</b>
<b class="nc">&nbsp;							Point2D ptA = ((Point) geom_a).getXY();</b>
<b class="nc">&nbsp;							RasterizedGeometry2D.HitType hit = rgeom</b>
<b class="nc">&nbsp;									.queryPointInGeometry(ptA.x, ptA.y);</b>
<b class="nc">&nbsp;							if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="nc">&nbsp;								return Relation.within;</b>
<b class="nc">&nbsp;							} else if (hit == RasterizedGeometry2D.HitType.Outside) {</b>
<b class="nc">&nbsp;								return Relation.disjoint;</b>
&nbsp;							}
&nbsp;							break;
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						Envelope2D env_a = new Envelope2D();</b>
<b class="fc">&nbsp;						geom_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;						RasterizedGeometry2D.HitType hit = rgeom</b>
<b class="fc">&nbsp;								.queryEnvelopeInGeometry(env_a);</b>
<b class="fc">&nbsp;						if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="nc">&nbsp;							return Relation.within;</b>
<b class="fc">&nbsp;						} else if (hit == RasterizedGeometry2D.HitType.Outside) {</b>
<b class="fc">&nbsp;							return Relation.disjoint;</b>
<b class="fc">&nbsp;						} else if (bExtraTestForIntersects</b>
<b class="fc">&nbsp;								&amp;&amp; Geometry.isMultiVertex(gtA)) {</b>
<b class="fc">&nbsp;							if (checkVerticesForIntersection_(</b>
<b class="fc">&nbsp;									(MultiVertexGeometryImpl) geom_a._getImpl(),</b>
<b class="fc">&nbsp;									rgeom)) {</b>
<b class="fc">&nbsp;								return Relation.intersects;</b>
&nbsp;							}
&nbsp;						}
&nbsp;
&nbsp;						break;
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		} while (false);
&nbsp;
<b class="fc">&nbsp;		return Relation.unknown;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns true if intersects and false if nothing can be determined.
&nbsp;	private static boolean checkVerticesForIntersection_(
&nbsp;			MultiVertexGeometryImpl geom, RasterizedGeometry2D rgeom) {
&nbsp;		// Do a quick raster test for each point. If any point is inside, then
&nbsp;		// there is an intersection.
<b class="fc">&nbsp;		int pointCount = geom.getPointCount();</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;		for (int ipoint = 0; ipoint &lt; pointCount; ipoint++) {</b>
<b class="fc">&nbsp;			geom.getXY(ipoint, pt);</b>
<b class="fc">&nbsp;			RasterizedGeometry2D.HitType hit = rgeom.queryPointInGeometry(pt.x,</b>
<b class="fc">&nbsp;					pt.y);</b>
<b class="fc">&nbsp;			if (hit == RasterizedGeometry2D.HitType.Inside) {</b>
<b class="fc">&nbsp;				return true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonTouchesPolygonImpl_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</b>
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_b = (MultiPathImpl) polygon_b._getImpl();</b>
&nbsp;
&nbsp;		// double geom_tolerance;
<b class="fc">&nbsp;		boolean b_geometries_simple = polygon_impl_a.getIsSimple(0.0) &gt;= 1</b>
<b class="nc">&nbsp;				&amp;&amp; polygon_impl_b.getIsSimple(0.0) &gt;= 1;</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = polygon_impl_b.querySegmentIterator();</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</b>
<b class="fc">&nbsp;				polygon_impl_a, polygon_impl_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_boundaries_intersect = false;</b>
&nbsp;
<b class="fc">&nbsp;		while (intersector.next()) {</b>
<b class="fc">&nbsp;			int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;			int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;			segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;			segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;			Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;			Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</b>
<b class="fc">&nbsp;					tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result == 2) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_a_1 = scalarsA[1];</b>
<b class="fc">&nbsp;				double length_a = segmentA.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				if (b_geometries_simple</b>
<b class="nc">&nbsp;						&amp;&amp; (scalar_a_1 - scalar_a_0) * length_a &gt; tolerance) {</b>
&nbsp;					// If the line segments overlap along the same direction,
&nbsp;					// then we have an Interior-Interior intersection
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
<b class="fc">&nbsp;			} else if (result != 0) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_b_0 = scalarsB[0];</b>
&nbsp;
<b class="fc">&nbsp;				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</b>
<b class="fc">&nbsp;						&amp;&amp; scalar_b_0 &lt; 1.0) {</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!b_boundaries_intersect) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polygon_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
&nbsp;		Polygon _polygonA;
&nbsp;		Polygon _polygonB;
&nbsp;
<b class="fc">&nbsp;		if (polygon_a.getPointCount() &gt; 10) {</b>
<b class="fc">&nbsp;			_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter, tolerance,</b>
<b class="fc">&nbsp;					0.0));</b>
<b class="fc">&nbsp;			if (_polygonA.isEmpty()) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			_polygonA = polygon_a;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (polygon_b.getPointCount() &gt; 10) {</b>
<b class="nc">&nbsp;			_polygonB = (Polygon) (Clipper.clip(polygon_b, envInter, tolerance,</b>
<b class="nc">&nbsp;					0.0));</b>
<b class="nc">&nbsp;			if (_polygonB.isEmpty()) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			_polygonB = polygon_b;</b>
&nbsp;		}
&nbsp;
&nbsp;		// We just need to determine whether interior_interior is false
<b class="fc">&nbsp;		String scl = &quot;F********&quot;;</b>
<b class="fc">&nbsp;		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolygon_(</b>
<b class="fc">&nbsp;				_polygonA, _polygonB, tolerance, scl, progressTracker);</b>
&nbsp;
<b class="fc">&nbsp;		return bRelation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonOverlapsPolygonImpl_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</b>
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_b = (MultiPathImpl) polygon_b._getImpl();</b>
&nbsp;
&nbsp;		// double geom_tolerance;
<b class="fc">&nbsp;		boolean b_geometries_simple = polygon_impl_a.getIsSimple(0.0) &gt;= 1</b>
<b class="nc">&nbsp;				&amp;&amp; polygon_impl_b.getIsSimple(0.0) &gt;= 1;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polygon_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		boolean bInteriorIntersectionKnown = false;</b>
&nbsp;
<b class="fc">&nbsp;		boolean bIntAExtB = interiorEnvExteriorEnv_(env_a, env_b, tolerance);</b>
<b class="fc">&nbsp;		boolean bExtAIntB = interiorEnvExteriorEnv_(env_b, env_a, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = polygon_impl_b.querySegmentIterator();</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</b>
<b class="fc">&nbsp;				polygon_impl_a, polygon_impl_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		while (intersector.next()) {</b>
<b class="fc">&nbsp;			int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;			int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;			segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;			segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;			Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;			Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</b>
<b class="fc">&nbsp;					tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result == 2) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_a_1 = scalarsA[1];</b>
<b class="fc">&nbsp;				double length_a = segmentA.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				if (b_geometries_simple</b>
<b class="nc">&nbsp;						&amp;&amp; (scalar_a_1 - scalar_a_0) * length_a &gt; tolerance) {</b>
&nbsp;					// When the line segments intersect along the same
&nbsp;					// direction, then we have an interior-interior intersection
<b class="nc">&nbsp;					bInteriorIntersectionKnown = true;</b>
&nbsp;
<b class="nc">&nbsp;					if (bIntAExtB &amp;&amp; bExtAIntB) {</b>
<b class="nc">&nbsp;						return true;</b>
&nbsp;					}
&nbsp;				}
<b class="fc">&nbsp;			} else if (result != 0) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_b_0 = scalarsB[0];</b>
&nbsp;
<b class="fc">&nbsp;				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</b>
<b class="fc">&nbsp;						&amp;&amp; scalar_b_0 &lt; 1.0) {</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D envAInflated = new Envelope2D(), envBInflated = new Envelope2D();</b>
<b class="fc">&nbsp;		envAInflated.setCoords(env_a);</b>
<b class="fc">&nbsp;		envAInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;		envBInflated.setCoords(env_b);</b>
<b class="fc">&nbsp;		envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		envInter.setCoords(envAInflated);</b>
<b class="fc">&nbsp;		envInter.intersect(envBInflated);</b>
&nbsp;
&nbsp;		Polygon _polygonA;
&nbsp;		Polygon _polygonB;
<b class="fc">&nbsp;		StringBuilder scl = new StringBuilder();</b>
&nbsp;
<b class="fc">&nbsp;		if (!bInteriorIntersectionKnown) {</b>
<b class="fc">&nbsp;			scl.append(&quot;T*&quot;);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			scl.append(&quot;**&quot;);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (bIntAExtB) {</b>
<b class="fc">&nbsp;			if (polygon_b.getPointCount() &gt; 10) {</b>
<b class="nc">&nbsp;				_polygonB = (Polygon) (Clipper.clip(polygon_b, envInter,</b>
<b class="nc">&nbsp;						tolerance, 0.0));</b>
<b class="nc">&nbsp;				if (_polygonB.isEmpty()) {</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				_polygonB = polygon_b;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			scl.append(&quot;****&quot;);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_polygonB = polygon_b;</b>
<b class="fc">&nbsp;			scl.append(&quot;T***&quot;);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (bExtAIntB) {</b>
<b class="fc">&nbsp;			if (polygon_a.getPointCount() &gt; 10) {</b>
<b class="fc">&nbsp;				_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter,</b>
<b class="fc">&nbsp;						tolerance, 0.0));</b>
<b class="fc">&nbsp;				if (_polygonA.isEmpty()) {</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				_polygonA = polygon_a;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			scl.append(&quot;***&quot;);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			_polygonA = polygon_a;</b>
<b class="fc">&nbsp;			scl.append(&quot;T**&quot;);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolygon_(</b>
<b class="fc">&nbsp;				_polygonA, _polygonB, tolerance, scl.toString(),</b>
<b class="fc">&nbsp;				progressTracker);</b>
<b class="fc">&nbsp;		return bRelation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonContainsPolygonImpl_(Polygon polygon_a,
&nbsp;			Polygon polygon_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;        boolean[] b_result_known = new boolean[1];</b>
<b class="fc">&nbsp;        b_result_known[0] = false;</b>
<b class="fc">&nbsp;        boolean res = polygonContainsMultiPath_(polygon_a, polygon_b, tolerance, b_result_known, progressTracker);</b>
&nbsp;
<b class="fc">&nbsp;        if (b_result_known[0])</b>
<b class="fc">&nbsp;            return res;</b>
&nbsp;
&nbsp;        // We can clip polygon_a to the extent of polyline_b
&nbsp;
<b class="fc">&nbsp;        Envelope2D envBInflated = new Envelope2D();</b>
<b class="fc">&nbsp;        polygon_b.queryEnvelope2D(envBInflated);</b>
<b class="fc">&nbsp;        envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
&nbsp;
<b class="fc">&nbsp;        Polygon _polygonA = null;</b>
&nbsp;
<b class="fc">&nbsp;        if (polygon_a.getPointCount() &gt; 10)</b>
&nbsp;        {
<b class="fc">&nbsp;            _polygonA = (Polygon)Clipper.clip(polygon_a, envBInflated, tolerance, 0.0);</b>
<b class="fc">&nbsp;            if (_polygonA.isEmpty())</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;        else
&nbsp;        {
<b class="fc">&nbsp;            _polygonA = polygon_a;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        boolean bContains = RelationalOperationsMatrix.polygonContainsPolygon_(_polygonA, polygon_b, tolerance, progressTracker);</b>
<b class="fc">&nbsp;        return bContains;</b>
&nbsp;	}
&nbsp;
&nbsp;    private static boolean polygonContainsMultiPath_(Polygon polygon_a, MultiPath multi_path_b, double tolerance, boolean[] b_result_known, ProgressTracker progress_tracker)
&nbsp;    {
<b class="fc">&nbsp;        b_result_known[0] = false;</b>
&nbsp;
<b class="fc">&nbsp;        MultiPathImpl polygon_impl_a = (MultiPathImpl)polygon_a._getImpl();</b>
<b class="fc">&nbsp;        MultiPathImpl multi_path_impl_b = (MultiPathImpl)multi_path_b._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;        SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;        SegmentIteratorImpl segIterB = multi_path_impl_b.querySegmentIterator();</b>
<b class="fc">&nbsp;        double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;        double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;        PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(polygon_impl_a, multi_path_impl_b, tolerance, false);</b>
<b class="fc">&nbsp;        boolean b_boundaries_intersect = false;</b>
&nbsp;
<b class="fc">&nbsp;        while (intersector.next())</b>
&nbsp;        {
<b class="fc">&nbsp;            int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;            int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;            segIterA.resetToVertex(vertex_a, -1);</b>
<b class="fc">&nbsp;            segIterB.resetToVertex(vertex_b, -1);</b>
<b class="fc">&nbsp;            Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;            Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;            int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;            if (result != 0) {</b>
<b class="fc">&nbsp;                b_boundaries_intersect = true;</b>
<b class="fc">&nbsp;                if (result == 1) {</b>
<b class="fc">&nbsp;                    double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;                    double scalar_b_0 = scalarsB[0];</b>
&nbsp;
<b class="fc">&nbsp;                    if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0 &amp;&amp; scalar_b_0 &lt; 1.0) {</b>
<b class="fc">&nbsp;                        b_result_known[0] = true;</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (!b_boundaries_intersect)</b>
&nbsp;        {
<b class="fc">&nbsp;            b_result_known[0] = true;</b>
&nbsp;
&nbsp;            //boundaries do not intersect
&nbsp;
<b class="fc">&nbsp;            Envelope2D env_a_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;            polygon_a.queryEnvelope2D(env_a_inflated);</b>
<b class="fc">&nbsp;            env_a_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;            Polygon pa = null;</b>
<b class="fc">&nbsp;            Polygon p_polygon_a = polygon_a;</b>
&nbsp;
<b class="fc">&nbsp;            boolean b_checked_polygon_a_quad_tree = false;</b>
&nbsp;
<b class="fc">&nbsp;            Envelope2D path_env_b = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;            for (int ipath = 0, npath = multi_path_b.getPathCount(); ipath &lt; npath; ipath++)</b>
&nbsp;            {
<b class="fc">&nbsp;                if (multi_path_b.getPathSize(ipath) &gt; 0)</b>
&nbsp;                {
<b class="fc">&nbsp;                    multi_path_b.queryPathEnvelope2D(ipath, path_env_b);</b>
&nbsp;
<b class="fc">&nbsp;                    if (env_a_inflated.isIntersecting(path_env_b))</b>
&nbsp;                    {
<b class="fc">&nbsp;                        Point2D anyPoint = multi_path_b.getXY(multi_path_b.getPathStart(ipath));</b>
<b class="fc">&nbsp;                        int res = PointInPolygonHelper.isPointInPolygon(p_polygon_a, anyPoint, 0);</b>
<b class="fc">&nbsp;                        if (res == 0)</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                    }
&nbsp;                    else
&nbsp;                    {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (!b_checked_polygon_a_quad_tree) {</b>
<b class="fc">&nbsp;                        if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multi_path_b.getPathCount() - 1) &amp;&amp; (polygon_impl_a._getAccelerators() == null || polygon_impl_a._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                            pa = new Polygon();</b>
<b class="nc">&nbsp;                            polygon_a.copyTo(pa);</b>
<b class="nc">&nbsp;                            ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                            p_polygon_a = pa;</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            p_polygon_a = polygon_a;</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        b_checked_polygon_a_quad_tree = true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            if (polygon_a.getPathCount() == 1 || multi_path_b.getType().value() == Geometry.GeometryType.Polyline)</b>
<b class="fc">&nbsp;                return true; //boundaries do not intersect. all paths of b are inside of a</b>
&nbsp;
&nbsp;            // Polygon A has multiple rings, and Multi_path B is a polygon.
&nbsp;
<b class="fc">&nbsp;            Polygon polygon_b = (Polygon)multi_path_b;</b>
&nbsp;
<b class="fc">&nbsp;            Envelope2D env_b_inflated = new Envelope2D();</b>
<b class="fc">&nbsp;            polygon_b.queryEnvelope2D(env_b_inflated);</b>
<b class="fc">&nbsp;            env_b_inflated.inflate(tolerance, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;            Polygon pb = null;</b>
<b class="fc">&nbsp;            Polygon p_polygon_b = polygon_b;</b>
&nbsp;
<b class="fc">&nbsp;            boolean b_checked_polygon_b_quad_tree = false;</b>
&nbsp;
<b class="fc">&nbsp;            Envelope2D path_env_a = new Envelope2D();</b>
&nbsp;
<b class="fc">&nbsp;            for (int ipath = 0, npath = polygon_a.getPathCount(); ipath &lt; npath; ipath++)</b>
&nbsp;            {
<b class="fc">&nbsp;                if (polygon_a.getPathSize(ipath) &gt; 0)</b>
&nbsp;                {
<b class="fc">&nbsp;                    polygon_a.queryPathEnvelope2D(ipath, path_env_a);</b>
&nbsp;
<b class="fc">&nbsp;                    if (env_b_inflated.isIntersecting(path_env_a))</b>
&nbsp;                    {
<b class="fc">&nbsp;                        Point2D anyPoint = polygon_a.getXY(polygon_a.getPathStart(ipath));</b>
<b class="fc">&nbsp;                        int res = PointInPolygonHelper.isPointInPolygon(p_polygon_b, anyPoint, 0);</b>
<b class="fc">&nbsp;                        if (res == 1)</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                    }
&nbsp;
<b class="fc">&nbsp;                    if (!b_checked_polygon_b_quad_tree) {</b>
<b class="fc">&nbsp;                        if (PointInPolygonHelper.quadTreeWillHelp(polygon_b, polygon_a.getPathCount() - 1) &amp;&amp; (multi_path_impl_b._getAccelerators() == null || multi_path_impl_b._getAccelerators().getQuadTree() == null)) {</b>
<b class="nc">&nbsp;                            pb = new Polygon();</b>
<b class="nc">&nbsp;                            polygon_b.copyTo(pb);</b>
<b class="nc">&nbsp;                            ((MultiPathImpl) pb._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);</b>
<b class="nc">&nbsp;                            p_polygon_b = pb;</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            p_polygon_b = polygon_b;</b>
&nbsp;                        }
&nbsp;
<b class="fc">&nbsp;                        b_checked_polygon_b_quad_tree = true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;	private static boolean polygonTouchesPolylineImpl_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</b>
<b class="fc">&nbsp;		MultiPathImpl polyline_impl_b = (MultiPathImpl) polyline_b._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = polyline_impl_b.querySegmentIterator();</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</b>
<b class="fc">&nbsp;				polygon_impl_a, polyline_impl_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_boundaries_intersect = false;</b>
&nbsp;
<b class="fc">&nbsp;		while (intersector.next()) {</b>
<b class="fc">&nbsp;			int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;			int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;			segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;			segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;			Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;			Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</b>
<b class="fc">&nbsp;					tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result == 2) {</b>
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
<b class="fc">&nbsp;			} else if (result != 0) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_b_0 = scalarsB[0];</b>
&nbsp;
<b class="fc">&nbsp;				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</b>
<b class="fc">&nbsp;						&amp;&amp; scalar_b_0 &lt; 1.0) {</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!b_boundaries_intersect) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polyline_b.queryEnvelope2D(env_b);</b>
<b class="fc">&nbsp;		env_a.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;		env_b.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;		envInter.setCoords(env_a);</b>
<b class="fc">&nbsp;		envInter.intersect(env_b);</b>
&nbsp;
&nbsp;		Polygon _polygonA;
&nbsp;		Polyline _polylineB;
&nbsp;
<b class="fc">&nbsp;		if (polygon_a.getPointCount() &gt; 10) {</b>
<b class="fc">&nbsp;			_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter, tolerance,</b>
<b class="fc">&nbsp;					0.0));</b>
<b class="fc">&nbsp;			if (_polygonA.isEmpty()) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			_polygonA = polygon_a;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (polyline_b.getPointCount() &gt; 10) {</b>
<b class="nc">&nbsp;			_polylineB = (Polyline) Clipper.clip(polyline_b, envInter,</b>
<b class="nc">&nbsp;					tolerance, 0.0);</b>
<b class="nc">&nbsp;			if (_polylineB.isEmpty()) {</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		} else {
<b class="fc">&nbsp;			_polylineB = polyline_b;</b>
&nbsp;		}
&nbsp;
&nbsp;		// We just need to determine that interior_interior is false
<b class="fc">&nbsp;		String scl = &quot;F********&quot;;</b>
<b class="fc">&nbsp;		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolyline_(</b>
<b class="fc">&nbsp;				_polygonA, _polylineB, tolerance, scl, progressTracker);</b>
&nbsp;
<b class="fc">&nbsp;		return bRelation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonCrossesPolylineImpl_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		MultiPathImpl polygon_impl_a = (MultiPathImpl) polygon_a._getImpl();</b>
<b class="fc">&nbsp;		MultiPathImpl polyline_impl_b = (MultiPathImpl) polyline_b._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		SegmentIteratorImpl segIterA = polygon_impl_a.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterB = polyline_impl_b.querySegmentIterator();</b>
<b class="fc">&nbsp;		double[] scalarsA = new double[2];</b>
<b class="fc">&nbsp;		double[] scalarsB = new double[2];</b>
&nbsp;
<b class="fc">&nbsp;		PairwiseIntersectorImpl intersector = new PairwiseIntersectorImpl(</b>
<b class="fc">&nbsp;				polygon_impl_a, polyline_impl_b, tolerance, false);</b>
&nbsp;
<b class="fc">&nbsp;		boolean b_boundaries_intersect = false;</b>
&nbsp;
<b class="fc">&nbsp;		while (intersector.next()) {</b>
<b class="fc">&nbsp;			int vertex_a = intersector.getRedElement();</b>
<b class="fc">&nbsp;			int vertex_b = intersector.getBlueElement();</b>
&nbsp;
<b class="fc">&nbsp;			segIterA.resetToVertex(vertex_a);</b>
<b class="fc">&nbsp;			segIterB.resetToVertex(vertex_b);</b>
<b class="fc">&nbsp;			Segment segmentA = segIterA.nextSegment();</b>
<b class="fc">&nbsp;			Segment segmentB = segIterB.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			int result = segmentB.intersect(segmentA, null, scalarsB, scalarsA,</b>
<b class="fc">&nbsp;					tolerance);</b>
&nbsp;
<b class="fc">&nbsp;			if (result == 2) {</b>
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
<b class="fc">&nbsp;			} else if (result != 0) {</b>
<b class="fc">&nbsp;				double scalar_a_0 = scalarsA[0];</b>
<b class="fc">&nbsp;				double scalar_b_0 = scalarsB[0];</b>
&nbsp;
<b class="fc">&nbsp;				if (scalar_a_0 &gt; 0.0 &amp;&amp; scalar_a_0 &lt; 1.0 &amp;&amp; scalar_b_0 &gt; 0.0</b>
<b class="fc">&nbsp;						&amp;&amp; scalar_b_0 &lt; 1.0) {</b>
<b class="fc">&nbsp;					return true;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				b_boundaries_intersect = true;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!b_boundaries_intersect) {</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D(), envAInflated = new Envelope2D(), envBInflated = new Envelope2D(), envInter = new Envelope2D();</b>
<b class="fc">&nbsp;		polygon_a.queryEnvelope2D(env_a);</b>
<b class="fc">&nbsp;		polyline_b.queryEnvelope2D(env_b);</b>
&nbsp;
<b class="fc">&nbsp;		if (interiorEnvExteriorEnv_(env_b, env_a, tolerance)) {</b>
<b class="fc">&nbsp;			envAInflated.setCoords(env_a);</b>
<b class="fc">&nbsp;			envAInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;			envBInflated.setCoords(env_b);</b>
<b class="fc">&nbsp;			envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
<b class="fc">&nbsp;			envInter.setCoords(envAInflated);</b>
<b class="fc">&nbsp;			envInter.intersect(envBInflated);</b>
&nbsp;
&nbsp;			Polygon _polygonA;
&nbsp;			Polyline _polylineB;
&nbsp;
<b class="fc">&nbsp;			if (polygon_a.getPointCount() &gt; 10) {</b>
<b class="nc">&nbsp;				_polygonA = (Polygon) (Clipper.clip(polygon_a, envInter,</b>
<b class="nc">&nbsp;						tolerance, 0.0));</b>
<b class="nc">&nbsp;				if (_polygonA.isEmpty()) {</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				_polygonA = polygon_a;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (polyline_b.getPointCount() &gt; 10) {</b>
<b class="nc">&nbsp;				_polylineB = (Polyline) (Clipper.clip(polyline_b, envInter,</b>
<b class="nc">&nbsp;						tolerance, 0.0));</b>
<b class="nc">&nbsp;				if (_polylineB.isEmpty()) {</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			} else {
<b class="fc">&nbsp;				_polylineB = polyline_b;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			String scl = &quot;T********&quot;;</b>
<b class="fc">&nbsp;			boolean bRelation = RelationalOperationsMatrix</b>
<b class="fc">&nbsp;					.polygonRelatePolyline_(_polygonA, _polylineB, tolerance,</b>
<b class="fc">&nbsp;							scl, progressTracker);</b>
<b class="fc">&nbsp;			return bRelation;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		String scl = &quot;T*****T**&quot;;</b>
<b class="fc">&nbsp;		boolean bRelation = RelationalOperationsMatrix.polygonRelatePolyline_(</b>
<b class="fc">&nbsp;				polygon_a, polyline_b, tolerance, scl, progressTracker);</b>
&nbsp;
<b class="fc">&nbsp;		return bRelation;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonContainsPolylineImpl_(Polygon polygon_a,
&nbsp;			Polyline polyline_b, double tolerance,
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;        boolean[] b_result_known = new boolean[1];</b>
<b class="fc">&nbsp;        b_result_known[0] = false;</b>
<b class="fc">&nbsp;        boolean res = polygonContainsMultiPath_(polygon_a, polyline_b, tolerance, b_result_known, progress_tracker);</b>
&nbsp;
<b class="fc">&nbsp;        if (b_result_known[0])</b>
<b class="fc">&nbsp;            return res;</b>
&nbsp;
&nbsp;        // We can clip polygon_a to the extent of polyline_b
&nbsp;
<b class="fc">&nbsp;        Envelope2D envBInflated = new Envelope2D();</b>
<b class="fc">&nbsp;        polyline_b.queryEnvelope2D(envBInflated);</b>
<b class="fc">&nbsp;        envBInflated.inflate(1000.0 * tolerance, 1000.0 * tolerance);</b>
&nbsp;
<b class="fc">&nbsp;        Polygon _polygonA = null;</b>
&nbsp;
<b class="fc">&nbsp;        if (polygon_a.getPointCount() &gt; 10)</b>
&nbsp;        {
<b class="fc">&nbsp;            _polygonA = (Polygon)Clipper.clip(polygon_a, envBInflated, tolerance, 0.0);</b>
<b class="fc">&nbsp;            if (_polygonA.isEmpty())</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;        }
&nbsp;        else
&nbsp;        {
<b class="fc">&nbsp;            _polygonA = polygon_a;</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        boolean bContains = RelationalOperationsMatrix.polygonContainsPolyline_(_polygonA, polyline_b, tolerance, progress_tracker);</b>
<b class="fc">&nbsp;        return bContains;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonContainsPointImpl_(Polygon polygon_a,
&nbsp;			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</b>
<b class="fc">&nbsp;				polygon_a, pt_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (result == PolygonUtils.PiPResult.PiPInside)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static boolean polygonTouchesPointImpl_(Polygon polygon_a,
&nbsp;			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;		PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(</b>
<b class="fc">&nbsp;				polygon_a, pt_b, tolerance);</b>
&nbsp;
<b class="fc">&nbsp;		if (result == PolygonUtils.PiPResult.PiPBoundary)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	static boolean multiPointDisjointPointImpl_(MultiPoint multipoint_a,
&nbsp;			Point2D pt_b, double tolerance, ProgressTracker progressTracker) {
<b class="fc">&nbsp;		Point2D pt_a = new Point2D();</b>
<b class="fc">&nbsp;		double tolerance_sq = tolerance * tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; multipoint_a.getPointCount(); i++) {</b>
<b class="fc">&nbsp;			multipoint_a.getXY(i, pt_a);</b>
&nbsp;
<b class="fc">&nbsp;			if (Point2D.sqrDistance(pt_a, pt_b) &lt;= tolerance_sq)</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static final class OverlapEvent {
&nbsp;		int m_ivertex_a;
&nbsp;		int m_ipath_a;
&nbsp;		double m_scalar_a_0;
&nbsp;		double m_scalar_a_1;
&nbsp;		int m_ivertex_b;
&nbsp;//		int m_ipath_b;
&nbsp;//		double m_scalar_b_0;
&nbsp;//		double m_scalar_b_1;
&nbsp;
&nbsp;		static OverlapEvent construct(int ivertex_a, int ipath_a,
&nbsp;				double scalar_a_0, double scalar_a_1, int ivertex_b,
&nbsp;				int ipath_b, double scalar_b_0, double scalar_b_1) {
<b class="fc">&nbsp;			OverlapEvent overlapEvent = new OverlapEvent();</b>
<b class="fc">&nbsp;			overlapEvent.m_ivertex_a = ivertex_a;</b>
<b class="fc">&nbsp;			overlapEvent.m_ipath_a = ipath_a;</b>
<b class="fc">&nbsp;			overlapEvent.m_scalar_a_0 = scalar_a_0;</b>
<b class="fc">&nbsp;			overlapEvent.m_scalar_a_1 = scalar_a_1;</b>
<b class="fc">&nbsp;			overlapEvent.m_ivertex_b = ivertex_b;</b>
&nbsp;//			overlapEvent.m_ipath_b = ipath_b;
&nbsp;//			overlapEvent.m_scalar_b_0 = scalar_b_0;
&nbsp;//			overlapEvent.m_scalar_b_1 = scalar_b_1;
<b class="fc">&nbsp;			return overlapEvent;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	ArrayList&lt;OverlapEvent&gt; m_overlap_events;
&nbsp;
<b class="fc">&nbsp;	private RelationalOperations() {</b>
<b class="fc">&nbsp;		m_overlap_events = new ArrayList&lt;OverlapEvent&gt;();</b>
&nbsp;	}
&nbsp;
&nbsp;	private static class OverlapComparer extends
&nbsp;			AttributeStreamOfInt32.IntComparator {
<b class="fc">&nbsp;		OverlapComparer(RelationalOperations rel_ops) {</b>
<b class="fc">&nbsp;			m_rel_ops = rel_ops;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(int o_1, int o_2) {
<b class="fc">&nbsp;			return m_rel_ops.compareOverlapEvents_(o_1, o_2);</b>
&nbsp;		}
&nbsp;
&nbsp;		private RelationalOperations m_rel_ops;
&nbsp;	}
&nbsp;
&nbsp;	int compareOverlapEvents_(int o_1, int o_2) {
<b class="fc">&nbsp;		OverlapEvent overlapEvent1 = m_overlap_events.get(o_1);</b>
<b class="fc">&nbsp;		OverlapEvent overlapEvent2 = m_overlap_events.get(o_2);</b>
&nbsp;
<b class="fc">&nbsp;		if (overlapEvent1.m_ipath_a &lt; overlapEvent2.m_ipath_a)</b>
<b class="nc">&nbsp;			return -1;</b>
&nbsp;
<b class="fc">&nbsp;		if (overlapEvent1.m_ipath_a == overlapEvent2.m_ipath_a) {</b>
<b class="fc">&nbsp;			if (overlapEvent1.m_ivertex_a &lt; overlapEvent2.m_ivertex_a)</b>
<b class="nc">&nbsp;				return -1;</b>
&nbsp;
<b class="fc">&nbsp;			if (overlapEvent1.m_ivertex_a == overlapEvent2.m_ivertex_a) {</b>
<b class="fc">&nbsp;				if (overlapEvent1.m_scalar_a_0 &lt; overlapEvent2.m_scalar_a_0)</b>
<b class="fc">&nbsp;					return -1;</b>
&nbsp;
<b class="fc">&nbsp;				if (overlapEvent1.m_scalar_a_0 == overlapEvent2.m_scalar_a_0) {</b>
<b class="nc">&nbsp;					if (overlapEvent1.m_scalar_a_1 &lt; overlapEvent2.m_scalar_a_1)</b>
<b class="nc">&nbsp;						return -1;</b>
&nbsp;
<b class="nc">&nbsp;					if (overlapEvent1.m_scalar_a_1 == overlapEvent2.m_scalar_a_1) {</b>
<b class="nc">&nbsp;						if (overlapEvent1.m_ivertex_b &lt; overlapEvent2.m_ivertex_b)</b>
<b class="nc">&nbsp;							return -1;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return 1;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static final class Accelerate_helper {</b>
&nbsp;		static boolean accelerate_geometry(Geometry geometry,
&nbsp;				SpatialReference sr,
&nbsp;				Geometry.GeometryAccelerationDegree accel_degree) {
<b class="fc">&nbsp;			if (!can_accelerate_geometry(geometry))</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			double tol = InternalUtils.calculateToleranceFromGeometry(sr,</b>
<b class="fc">&nbsp;					geometry, false);</b>
<b class="fc">&nbsp;			boolean bAccelerated = false;</b>
<b class="fc">&nbsp;			if (GeometryAccelerators.canUseRasterizedGeometry(geometry))</b>
<b class="fc">&nbsp;				bAccelerated |= ((MultiVertexGeometryImpl) geometry._getImpl())</b>
<b class="fc">&nbsp;						._buildRasterizedGeometryAccelerator(tol, accel_degree);</b>
&nbsp;
<b class="fc">&nbsp;			Geometry.Type type = geometry.getType();</b>
<b class="fc">&nbsp;			if ((type == Geometry.Type.Polygon || type == Geometry.Type.Polyline)</b>
<b class="fc">&nbsp;					&amp;&amp; GeometryAccelerators.canUseQuadTree(geometry)</b>
<b class="fc">&nbsp;					&amp;&amp; accel_degree != Geometry.GeometryAccelerationDegree.enumMild)</b>
<b class="fc">&nbsp;				bAccelerated |= ((MultiVertexGeometryImpl) geometry._getImpl())</b>
<b class="fc">&nbsp;						._buildQuadTreeAccelerator(accel_degree);</b>
&nbsp;
<b class="fc">&nbsp;			if ((type == Geometry.Type.Polygon || type == Geometry.Type.Polyline)</b>
<b class="fc">&nbsp;					&amp;&amp; GeometryAccelerators.canUseQuadTreeForPaths(geometry)</b>
<b class="fc">&nbsp;					&amp;&amp; accel_degree != Geometry.GeometryAccelerationDegree.enumMild)</b>
<b class="fc">&nbsp;				bAccelerated |= ((MultiPathImpl) geometry._getImpl())</b>
<b class="fc">&nbsp;						._buildQuadTreeForPathsAccelerator(accel_degree);</b>
&nbsp;
<b class="fc">&nbsp;			return bAccelerated;</b>
&nbsp;		}
&nbsp;
&nbsp;        static boolean can_accelerate_geometry(Geometry geometry) {
<b class="fc">&nbsp;            return GeometryAccelerators.canUseRasterizedGeometry(geometry)</b>
<b class="nc">&nbsp;                    || GeometryAccelerators.canUseQuadTree(geometry) || GeometryAccelerators.canUseQuadTreeForPaths(geometry);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 15:02</div>
</div>
</body>
</html>
