


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>Coverage Report > OperatorUnionCursor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: OperatorUnionCursor (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OperatorUnionCursor</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82,3%
  </span>
  <span class="absValue">
    (107/130)
  </span>
</td>
</tr>
  <tr>
    <td class="name">OperatorUnionCursor$Bin_type</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorUnionCursor$Geom_pair</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    89,5%
  </span>
  <span class="absValue">
    (17/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,7%
  </span>
  <span class="absValue">
    (118/141)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.TreeMap;
&nbsp;
<b class="fc">&nbsp;final class OperatorUnionCursor extends GeometryCursor {</b>
&nbsp;
&nbsp;	private GeometryCursor m_inputGeoms;
&nbsp;	private ProgressTracker m_progress_tracker;
&nbsp;	private SpatialReferenceImpl m_spatial_reference;
<b class="fc">&nbsp;	private int m_index = -1;</b>
<b class="fc">&nbsp;	private boolean m_b_done = false;</b>
<b class="fc">&nbsp;	private boolean [] m_had_geometry = new boolean[4];</b>
<b class="fc">&nbsp;	private int [] m_dim_geom_counts = new int [4];</b>
<b class="fc">&nbsp;	private boolean m_b_union_all_dimensions = false;</b>
<b class="fc">&nbsp;	private int m_max_dimension = -1;</b>
<b class="fc">&nbsp;	private int m_added_geoms = 0;</b>
<b class="fc">&nbsp;	private int m_current_dim = -1;</b>
&nbsp;	
<b class="fc">&nbsp;    private final static class Geom_pair</b>
&nbsp;    {
<b class="fc">&nbsp;      void init() { geom = null; vertex_count = -1; unioned = false; }</b>
&nbsp;      Geometry geom;
&nbsp;      int vertex_count;
&nbsp;      boolean unioned;//true if geometry is a result of union operation
&nbsp;    }
&nbsp;
<b class="fc">&nbsp;    final static class Bin_type //bin array and the total vertex count in the bin</b>
&nbsp;    {
<b class="fc">&nbsp;      int bin_vertex_count = 0;</b>
<b class="fc">&nbsp;      ArrayList&lt;Geom_pair&gt; geometries = new ArrayList&lt;Geom_pair&gt;();</b>
&nbsp;      
&nbsp;      void add_pair(Geom_pair geom)
&nbsp;      {
<b class="fc">&nbsp;        bin_vertex_count += geom.vertex_count;</b>
<b class="fc">&nbsp;        geometries.add(geom);</b>
&nbsp;      }
&nbsp;      void pop_pair()
&nbsp;      {
<b class="fc">&nbsp;        bin_vertex_count -= geometries.get(geometries.size() - 1).vertex_count;</b>
<b class="fc">&nbsp;        geometries.remove(geometries.size() - 1);</b>
&nbsp;      }
<b class="fc">&nbsp;      Geom_pair back_pair() { return geometries.get(geometries.size() - 1); }</b>
<b class="fc">&nbsp;      int geom_count() { return geometries.size(); }</b>
&nbsp;    }
&nbsp;    
<b class="fc">&nbsp;    ArrayList&lt; TreeMap&lt;Integer, Bin_type&gt; &gt; m_union_bins = new ArrayList&lt; TreeMap&lt;Integer, Bin_type&gt; &gt;();//for each dimension there is a list of bins sorted by level</b>
&nbsp;
<b class="fc">&nbsp;	OperatorUnionCursor(GeometryCursor inputGeoms1, SpatialReference sr,</b>
&nbsp;			ProgressTracker progress_tracker) {
<b class="fc">&nbsp;		m_inputGeoms = inputGeoms1;</b>
<b class="fc">&nbsp;		m_spatial_reference = (SpatialReferenceImpl) (sr);</b>
<b class="fc">&nbsp;		m_progress_tracker = progress_tracker;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private Geometry get_result_geometry(int dim) {
<b class="fc">&nbsp;		assert (m_dim_geom_counts[dim] &gt; 0);</b>
<b class="fc">&nbsp;		java.util.TreeMap&lt;Integer, Bin_type&gt; map = m_union_bins.get(dim);</b>
<b class="fc">&nbsp;		Map.Entry&lt;Integer, Bin_type&gt; e = map.firstEntry();</b>
<b class="fc">&nbsp;		Bin_type bin = e.getValue();</b>
&nbsp;
&nbsp;		Geometry resG;
<b class="fc">&nbsp;		resG = bin.back_pair().geom;</b>
<b class="fc">&nbsp;		boolean unioned = bin.back_pair().unioned;</b>
<b class="fc">&nbsp;		map.remove(e.getKey());</b>
&nbsp;
<b class="fc">&nbsp;		if (unioned) {</b>
<b class="fc">&nbsp;			resG = OperatorSimplify.local().execute(resG, m_spatial_reference,</b>
<b class="fc">&nbsp;					false, m_progress_tracker);</b>
<b class="fc">&nbsp;			if (dim == 0 &amp;&amp; resG.getType() == Geometry.Type.Point) {// must</b>
&nbsp;																	// return
&nbsp;																	// multipoint
&nbsp;																	// for
&nbsp;																	// points
<b class="nc">&nbsp;				MultiPoint mp = new MultiPoint(resG.getDescription());</b>
<b class="nc">&nbsp;				if (!resG.isEmpty())</b>
<b class="nc">&nbsp;					mp.add((Point) resG);</b>
&nbsp;
<b class="nc">&nbsp;				resG = mp;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return resG;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry next() {
<b class="fc">&nbsp;		if (m_b_done &amp;&amp; m_current_dim == m_max_dimension)</b>
<b class="fc">&nbsp;			return null;</b>
&nbsp;
<b class="fc">&nbsp;		while (!step_()) {</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_max_dimension == -1)</b>
<b class="nc">&nbsp;			return null;// empty input cursor</b>
&nbsp;
<b class="fc">&nbsp;		if (m_b_union_all_dimensions) {</b>
<b class="nc">&nbsp;			m_current_dim++;</b>
&nbsp;			while (true) {
<b class="nc">&nbsp;				if (m_current_dim &gt; m_max_dimension || m_current_dim &lt; 0)</b>
<b class="nc">&nbsp;					throw GeometryException.GeometryInternalError();</b>
&nbsp;
<b class="nc">&nbsp;				if (m_had_geometry[m_current_dim])</b>
<b class="nc">&nbsp;					break;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			m_index++;</b>
<b class="nc">&nbsp;			return get_result_geometry(m_current_dim);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			m_index = 0;</b>
<b class="fc">&nbsp;			assert (m_max_dimension &gt;= 0);</b>
<b class="fc">&nbsp;			m_current_dim = m_max_dimension;</b>
<b class="fc">&nbsp;			return get_result_geometry(m_max_dimension);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getGeometryID() {
<b class="nc">&nbsp;		return m_index;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private boolean step_(){
<b class="fc">&nbsp;		if (m_b_done)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		Geometry geom = null;</b>
<b class="fc">&nbsp;		if (m_inputGeoms != null)</b>
&nbsp;		{
<b class="fc">&nbsp;			geom = m_inputGeoms.next();</b>
<b class="fc">&nbsp;			if (geom == null) {</b>
<b class="fc">&nbsp;				m_b_done = true;</b>
<b class="fc">&nbsp;				m_inputGeoms = null;</b>
&nbsp;			}
&nbsp;		}
&nbsp;			
<b class="fc">&nbsp;		ProgressTracker.checkAndThrow(m_progress_tracker);</b>
&nbsp;
<b class="fc">&nbsp;		if (geom != null) {</b>
<b class="fc">&nbsp;			int dim = geom.getDimension();</b>
<b class="fc">&nbsp;			m_had_geometry[dim] = true;</b>
<b class="fc">&nbsp;			if (dim &gt;= m_max_dimension &amp;&amp; !m_b_union_all_dimensions)</b>
&nbsp;			{
<b class="fc">&nbsp;	          add_geom(dim, false, geom);</b>
<b class="fc">&nbsp;	          if (dim &gt; m_max_dimension &amp;&amp; !m_b_union_all_dimensions)</b>
&nbsp;	          {
&nbsp;	            //this geometry has higher dimension than the previously processed one
&nbsp;	            //Therefore we delete all lower dimensions (unless m_b_union_all_dimensions is true).
<b class="nc">&nbsp;	            remove_all_bins_with_lower_dimension(dim);</b>
&nbsp;	          }
&nbsp;			}
&nbsp;			else
&nbsp;			{
&nbsp;				//this geometry is skipped
&nbsp;			}
&nbsp;		} else {
&nbsp;			//geom is null. do nothing
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		if (m_added_geoms &gt; 0) {</b>
<b class="fc">&nbsp;			for (int dim = 0; dim &lt;= m_max_dimension; dim++) {</b>
<b class="fc">&nbsp;				while (m_dim_geom_counts[dim] &gt; 1) {</b>
<b class="fc">&nbsp;					ArrayList&lt;Geometry&gt; batch_to_union = collect_geometries_to_union(dim);</b>
<b class="fc">&nbsp;					boolean serial_execution = true;</b>
<b class="fc">&nbsp;					if (serial_execution) {</b>
<b class="fc">&nbsp;						if (batch_to_union.size() != 0) {</b>
<b class="fc">&nbsp;							Geometry geomRes = TopologicalOperations</b>
<b class="fc">&nbsp;									.dissolveDirty(batch_to_union,</b>
<b class="fc">&nbsp;											m_spatial_reference,</b>
<b class="fc">&nbsp;											m_progress_tracker);</b>
<b class="fc">&nbsp;							add_geom(dim, true, geomRes);</b>
&nbsp;						} else {
&nbsp;							break;
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		return m_b_done;</b>
&nbsp;	}
&nbsp;	
&nbsp;	ArrayList&lt;Geometry&gt; collect_geometries_to_union(int dim) {
<b class="fc">&nbsp;		ArrayList&lt;Geometry&gt; batch_to_union = new ArrayList&lt;Geometry&gt;();</b>
<b class="fc">&nbsp;		ArrayList&lt;Map.Entry&lt;Integer, Bin_type&gt;&gt; entriesToRemove = new ArrayList&lt;Map.Entry&lt;Integer, Bin_type&gt;&gt;();</b>
<b class="fc">&nbsp;		Set&lt;Map.Entry&lt;Integer, Bin_type&gt;&gt; set = m_union_bins.get(dim)</b>
<b class="fc">&nbsp;				.entrySet();</b>
<b class="fc">&nbsp;		for (Map.Entry&lt;Integer, Bin_type&gt; e : set) {</b>
&nbsp;			//int level = e.getKey();
<b class="fc">&nbsp;			Bin_type bin = e.getValue();</b>
&nbsp;
<b class="fc">&nbsp;			final int binVertexThreshold = 10000;</b>
&nbsp;
<b class="fc">&nbsp;			if (m_b_done</b>
<b class="fc">&nbsp;					|| (bin.bin_vertex_count &gt; binVertexThreshold &amp;&amp; bin</b>
<b class="nc">&nbsp;							.geom_count() &gt; 1)) {</b>
<b class="fc">&nbsp;				m_dim_geom_counts[dim] -= bin.geom_count();</b>
<b class="fc">&nbsp;				m_added_geoms -= bin.geom_count();</b>
<b class="fc">&nbsp;				while (bin.geometries.size() &gt; 0) {</b>
&nbsp;					// empty geometries will be unioned too.
<b class="fc">&nbsp;					batch_to_union.add(bin.back_pair().geom);</b>
<b class="fc">&nbsp;					bin.pop_pair();</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				entriesToRemove.add(e);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		set.removeAll(entriesToRemove);</b>
<b class="fc">&nbsp;		return batch_to_union;</b>
&nbsp;	}
&nbsp;	
&nbsp;	private void remove_all_bins_with_lower_dimension(int dim) {
&nbsp;		// this geometry has higher dimension than the previously processed one
<b class="nc">&nbsp;		for (int i = 0; i &lt; dim; i++) {</b>
<b class="nc">&nbsp;			m_union_bins.get(i).clear();</b>
<b class="nc">&nbsp;			m_added_geoms -= m_dim_geom_counts[i];</b>
<b class="nc">&nbsp;			m_dim_geom_counts[i] = 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void add_geom(int dimension, boolean unioned, Geometry geom) {
<b class="fc">&nbsp;		Geom_pair pair = new Geom_pair();</b>
<b class="fc">&nbsp;		pair.init();</b>
<b class="fc">&nbsp;		pair.geom = geom;</b>
<b class="fc">&nbsp;		int sz = get_vertex_count_(geom);</b>
<b class="fc">&nbsp;		pair.vertex_count = sz;</b>
<b class="fc">&nbsp;		int level = get_level_(sz);</b>
<b class="fc">&nbsp;		if (dimension + 1 &gt; (int) m_union_bins.size()) {</b>
<b class="fc">&nbsp;			for (int i = 0, n = Math.max(2, dimension + 1); i &lt; n; i++) {</b>
<b class="fc">&nbsp;				m_union_bins.add(new TreeMap&lt;Integer, Bin_type&gt;());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Bin_type bin = m_union_bins.get(dimension).get(level);//return null if level is abscent</b>
<b class="fc">&nbsp;		if (bin == null) {</b>
<b class="fc">&nbsp;			bin = new Bin_type();</b>
<b class="fc">&nbsp;			m_union_bins.get(dimension).put(level, bin);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		pair.unioned = unioned;</b>
<b class="fc">&nbsp;		bin.add_pair(pair);</b>
&nbsp;
&nbsp;		// Update global cursor state
<b class="fc">&nbsp;		m_dim_geom_counts[dimension]++;</b>
<b class="fc">&nbsp;		m_added_geoms++;</b>
<b class="fc">&nbsp;		m_max_dimension = Math.max(m_max_dimension, dimension);</b>
&nbsp;	}
&nbsp;
&nbsp;	private static int get_level_(int sz) {// calculates logarithm of sz to base
&nbsp;											// 4.
<b class="fc">&nbsp;		return sz &gt; 0 ? (int) (Math.log((double) sz) / Math.log(4.0) + 0.5)</b>
<b class="fc">&nbsp;				: (int) 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static int get_vertex_count_(Geometry geom) {
<b class="fc">&nbsp;		int gt = geom.getType().value();</b>
<b class="fc">&nbsp;		if (Geometry.isMultiVertex(gt)) {</b>
<b class="fc">&nbsp;			return ((MultiVertexGeometry) geom).getPointCount();</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.GeometryType.Point) {</b>
<b class="fc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;			return 4;</b>
<b class="nc">&nbsp;		} else if (Geometry.isSegment(gt)) {</b>
<b class="nc">&nbsp;			return 2;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;	@Override
&nbsp;	public boolean tock() {
<b class="fc">&nbsp;		return step_();</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 15:02</div>
</div>
</body>
</html>
