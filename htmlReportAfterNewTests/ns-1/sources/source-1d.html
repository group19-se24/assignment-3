


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > GeoDist</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: GeoDist (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">GeoDist</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77,8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65,1%
  </span>
  <span class="absValue">
    (140/215)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.PeDouble;
&nbsp;
<b class="nc">&nbsp;final class GeoDist {</b>
&nbsp;	private static final double PE_PI = 3.14159265358979323846264;
&nbsp;	private static final double PE_PI2 = 1.57079632679489661923132;
&nbsp;	private static final double PE_2PI = 6.283185307179586476925287;
&nbsp;	private static final double PE_EPS = 3.55271367880050092935562e-15;
&nbsp;
&nbsp;	/** Get the absolute value of a number */
&nbsp;	static private double PE_ABS(double a) {
<b class="fc">&nbsp;		return (a &lt; 0) ? -a : a;</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Assign the sign of the second number to the first */
&nbsp;	static private double PE_SGN(double a, double b) {
<b class="fc">&nbsp;		return (b &gt;= 0) ? PE_ABS(a) : -PE_ABS(a);</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Determine if two doubles are equal within a default tolerance */
&nbsp;	static private boolean PE_EQ(double a, double b) {
<b class="fc">&nbsp;		return (a == b)</b>
<b class="fc">&nbsp;				|| PE_ABS(a - b) &lt;= PE_EPS * (1 + (PE_ABS(a) + PE_ABS(b)) / 2);</b>
&nbsp;	}
&nbsp;
&nbsp;	/** Determine if a double is within a given tolerance of zero */
&nbsp;	static private boolean PE_ZERO(double a) {
<b class="fc">&nbsp;		return (a == 0.0) || (PE_ABS(a) &lt;= PE_EPS);</b>
&nbsp;	}
&nbsp;
&nbsp;	static private double lam_delta(double lam) {
<b class="fc">&nbsp;		double d = Math.IEEEremainder(lam, PE_2PI);</b>
&nbsp;
<b class="fc">&nbsp;		return (PE_ABS(d) &lt;= PE_PI) ? d : ((d &lt; 0) ? d + PE_2PI : d - PE_2PI);</b>
&nbsp;	}
&nbsp;
&nbsp;	static private void lam_phi_reduction(PeDouble p_lam, PeDouble p_phi) {
<b class="fc">&nbsp;		p_lam.val = lam_delta(p_lam.val);</b>
<b class="fc">&nbsp;		p_phi.val = lam_delta(p_phi.val);</b>
&nbsp;
<b class="fc">&nbsp;		if (PE_ABS(p_phi.val) &gt; PE_PI2) {</b>
<b class="nc">&nbsp;			p_lam.val = lam_delta(p_lam.val + PE_PI);</b>
<b class="nc">&nbsp;			p_phi.val = PE_SGN(PE_PI, p_phi.val) - p_phi.val;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	static private double q90(double a, double e2) {
&nbsp;		/*
&nbsp;		 * Rapp // Geometric Geodesy (Part I) // p. 39. Adams, O.S. // Latitude
&nbsp;		 * Developments ... // pp. 122-127. Terms extended past n4 by David
&nbsp;		 * Burrows, ESRI
&nbsp;		 */
&nbsp;
&nbsp;		/* Calculate meridional arc distance from equator to pole */
&nbsp;
&nbsp;		/*
&nbsp;		 * q90 = a * PE_PI2 * (1 + 1/4 n2 + 1/64 n4 + 1/256 n6 + 25/16384 n8 +
&nbsp;		 * 49/65536 n10 + ...)/(1.0 + n)
&nbsp;		 */
&nbsp;
<b class="nc">&nbsp;		double t = Math.sqrt(1.0 - e2);</b>
<b class="nc">&nbsp;		double n = (1.0 - t) / (1.0 + t);</b>
<b class="nc">&nbsp;		double n2 = n * n;</b>
&nbsp;
<b class="nc">&nbsp;		return a / (1.0 + n)</b>
&nbsp;				* (1.0 + n2 * (1.0 / 4.0 + n2 * (1.0 / 64.0 + n2 * (1.0 / 256.0))))
&nbsp;				* PE_PI2;
&nbsp;	}
&nbsp;
&nbsp;	static public void geodesic_distance_ngs(double a, double e2, double lam1,
&nbsp;			double phi1, double lam2, double phi2, PeDouble p_dist,
&nbsp;			PeDouble p_az12, PeDouble p_az21) {
&nbsp;		/* Highly edited version (plus lots of additions) of NGS FORTRAN code */
&nbsp;
&nbsp;		/*
&nbsp;		 * inverse for long-line and antipodal cases.* latitudes may be 90
&nbsp;		 * degrees exactly.* latitude positive north, longitude positive east,
&nbsp;		 * radians.* azimuth clockwise from north, radians.* original programmed
&nbsp;		 * by thaddeus vincenty, 1975, 1976* removed back side solution option,
&nbsp;		 * debugged, revised -- 2011may01 -- dgm* this version of code is
&nbsp;		 * interim -- antipodal boundary needs work
&nbsp;		 * 
&nbsp;		 * * output (besides az12, az21, and dist):* These have been removed
&nbsp;		 * from this esri version of the ngs code* it, iteration count* sigma,
&nbsp;		 * spherical distance on auxiliary sphere* lam_sph, longitude difference
&nbsp;		 * on auxiliary sphere* kind, solution flag: kind=1, long-line; kind=2,
&nbsp;		 * antipodal
&nbsp;		 * 
&nbsp;		 * 
&nbsp;		 * All references to Rapp are Part II
&nbsp;		 */
&nbsp;
<b class="fc">&nbsp;		double tol = 1.0e-14;</b>
<b class="fc">&nbsp;		double eps = 1.0e-15;</b>
&nbsp;
<b class="fc">&nbsp;		double boa = 0.0;</b>
<b class="fc">&nbsp;		double dlam = 0.0;</b>
<b class="fc">&nbsp;		double eta1 = 0.0, sin_eta1 = 0.0, cos_eta1 = 0.0;</b>
<b class="fc">&nbsp;		double eta2 = 0.0, sin_eta2 = 0.0, cos_eta2 = 0.0;</b>
<b class="fc">&nbsp;		double prev = 0.0, test = 0.0;</b>
<b class="fc">&nbsp;		double sin_lam_sph = 0.0, cos_lam_sph = 0.0, temp = 0.0, sin_sigma = 0.0, cos_sigma = 0.0;</b>
<b class="fc">&nbsp;		double sin_azeq = 0.0, cos2_azeq = 0.0, costm = 0.0, costm2 = 0.0, c = 0.0, d = 0.0;</b>
<b class="fc">&nbsp;		double tem1 = 0.0, tem2 = 0.0, ep2 = 0.0, bige = 0.0, bigf = 0.0, biga = 0.0, bigb = 0.0, z = 0.0, dsigma = 0.0;</b>
&nbsp;		boolean q_continue_looping;
&nbsp;
<b class="fc">&nbsp;		double f = 0.0;</b>
&nbsp;
<b class="fc">&nbsp;		double az12 = 0.0, az21 = 0.0, dist = 0.0;</b>
<b class="fc">&nbsp;		double sigma = 0.0, lam_sph = 0.0;</b>
<b class="fc">&nbsp;		int it = 0, kind = 0;</b>
&nbsp;
<b class="fc">&nbsp;		PeDouble lam = new PeDouble();</b>
<b class="fc">&nbsp;		PeDouble phi = new PeDouble();</b>
&nbsp;
&nbsp;		/* Are there any values to calculate? */
<b class="fc">&nbsp;		if (p_dist == null &amp;&amp; p_az12 == null &amp;&amp; p_az21 == null) {</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		/* Normalize point 1 and 2 */
<b class="fc">&nbsp;		lam.val = lam1;</b>
<b class="fc">&nbsp;		phi.val = phi1;</b>
<b class="fc">&nbsp;		lam_phi_reduction(lam, phi);</b>
<b class="fc">&nbsp;		lam1 = lam.val;</b>
<b class="fc">&nbsp;		phi1 = phi.val;</b>
&nbsp;
<b class="fc">&nbsp;		lam.val = lam2;</b>
<b class="fc">&nbsp;		phi.val = phi2;</b>
<b class="fc">&nbsp;		lam_phi_reduction(lam, phi);</b>
<b class="fc">&nbsp;		lam2 = lam.val;</b>
<b class="fc">&nbsp;		phi2 = phi.val;</b>
&nbsp;
<b class="fc">&nbsp;		dlam = lam_delta(lam2 - lam1); /* longitude difference [-Pi, Pi] */</b>
&nbsp;
<b class="fc">&nbsp;		if (PE_EQ(phi1, phi2) &amp;&amp; (PE_ZERO(dlam) || PE_EQ(PE_ABS(phi1), PE_PI2))) {</b>
&nbsp;			/* Check that the points are not the same */
<b class="nc">&nbsp;			if (p_dist != null)</b>
<b class="nc">&nbsp;				p_dist.val = 0.0;</b>
<b class="nc">&nbsp;			if (p_az12 != null)</b>
<b class="nc">&nbsp;				p_az12.val = 0.0;</b>
<b class="nc">&nbsp;			if (p_az21 != null)</b>
<b class="nc">&nbsp;				p_az21.val = 0.0;</b>
&nbsp;
&nbsp;			return;
<b class="fc">&nbsp;		} else if (PE_EQ(phi1, -phi2)) {</b>
&nbsp;			/* Check if they are perfectly antipodal */
<b class="fc">&nbsp;			if (PE_EQ(PE_ABS(phi1), PE_PI2)) {</b>
&nbsp;				/* Check if they are at opposite poles */
<b class="nc">&nbsp;				if (p_dist != null)</b>
<b class="nc">&nbsp;					p_dist.val = 2.0 * q90(a, e2);</b>
&nbsp;
<b class="nc">&nbsp;				if (p_az12 != null)</b>
<b class="nc">&nbsp;					p_az12.val = phi1 &gt; 0.0 ? lam_delta(PE_PI - lam_delta(lam2))</b>
<b class="nc">&nbsp;							: lam_delta(lam2);</b>
&nbsp;
<b class="nc">&nbsp;				if (p_az21 != null)</b>
<b class="nc">&nbsp;					p_az21.val = phi1 &gt; 0.0 ? lam_delta(lam2) : lam_delta(PE_PI</b>
<b class="nc">&nbsp;							- lam_delta(lam2));</b>
&nbsp;
&nbsp;				return;
<b class="fc">&nbsp;			} else if (PE_EQ(PE_ABS(dlam), PE_PI)) {</b>
&nbsp;				/* Other antipodal */
<b class="nc">&nbsp;				if (p_dist != null)</b>
<b class="nc">&nbsp;					p_dist.val = 2.0 * q90(a, e2);</b>
<b class="nc">&nbsp;				if (p_az12 != null)</b>
<b class="nc">&nbsp;					p_az12.val = 0.0;</b>
<b class="nc">&nbsp;				if (p_az21 != null)</b>
<b class="nc">&nbsp;					p_az21.val = 0.0;</b>
&nbsp;				return;
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (PE_ZERO(e2)) /* Sphere */</b>
&nbsp;		{
&nbsp;			double cos_phi1, cos_phi2;
&nbsp;			double sin_phi1, sin_phi2;
&nbsp;
<b class="nc">&nbsp;			cos_phi1 = Math.cos(phi1);</b>
<b class="nc">&nbsp;			cos_phi2 = Math.cos(phi2);</b>
<b class="nc">&nbsp;			sin_phi1 = Math.sin(phi1);</b>
<b class="nc">&nbsp;			sin_phi2 = Math.sin(phi2);</b>
&nbsp;
<b class="nc">&nbsp;			if (p_dist != null) {</b>
<b class="nc">&nbsp;				tem1 = Math.sin((phi2 - phi1) / 2.0);</b>
<b class="nc">&nbsp;				tem2 = Math.sin(dlam / 2.0);</b>
<b class="nc">&nbsp;				sigma = 2.0 * Math.asin(Math.sqrt(tem1 * tem1 + cos_phi1</b>
&nbsp;						* cos_phi2 * tem2 * tem2));
<b class="nc">&nbsp;				p_dist.val = sigma * a;</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (p_az12 != null) {</b>
<b class="nc">&nbsp;				if (PE_EQ(PE_ABS(phi1), PE_PI2)) /* Origin at N or S Pole */</b>
&nbsp;				{
<b class="nc">&nbsp;					p_az12.val = phi1 &lt; 0.0 ? lam2 : lam_delta(PE_PI - lam2);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					p_az12.val = Math.atan2(cos_phi2 * Math.sin(dlam), cos_phi1</b>
<b class="nc">&nbsp;							* sin_phi2 - sin_phi1 * cos_phi2 * Math.cos(dlam));</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (p_az21 != null) {</b>
<b class="nc">&nbsp;				if (PE_EQ(PE_ABS(phi2), PE_PI2)) /* Destination at N or S Pole */</b>
&nbsp;				{
<b class="nc">&nbsp;					p_az21.val = phi2 &lt; 0.0 ? lam1 : lam_delta(PE_PI - lam1);</b>
&nbsp;				} else {
<b class="nc">&nbsp;					p_az21.val = Math.atan2(cos_phi1 * Math.sin(dlam), sin_phi2</b>
<b class="nc">&nbsp;							* cos_phi1 * Math.cos(dlam) - cos_phi2 * sin_phi1);</b>
<b class="nc">&nbsp;					p_az21.val = lam_delta(p_az21.val + PE_PI);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		f = 1.0 - Math.sqrt(1.0 - e2);</b>
<b class="fc">&nbsp;		boa = 1.0 - f;</b>
&nbsp;
<b class="fc">&nbsp;		eta1 = Math.atan(boa * Math.tan(phi1)); /* better reduced latitude */</b>
<b class="fc">&nbsp;		sin_eta1 = Math.sin(eta1);</b>
<b class="fc">&nbsp;		cos_eta1 = Math.cos(eta1);</b>
&nbsp;
<b class="fc">&nbsp;		eta2 = Math.atan(boa * Math.tan(phi2)); /* better reduced latitude */</b>
<b class="fc">&nbsp;		sin_eta2 = Math.sin(eta2);</b>
<b class="fc">&nbsp;		cos_eta2 = Math.cos(eta2);</b>
&nbsp;
<b class="fc">&nbsp;		prev = dlam;</b>
<b class="fc">&nbsp;		test = dlam;</b>
<b class="fc">&nbsp;		it = 0;</b>
<b class="fc">&nbsp;		kind = 1;</b>
<b class="fc">&nbsp;		lam_sph = dlam; /* v13 (Rapp ) */</b>
&nbsp;
&nbsp;		/* top of the long-line loop (kind = 1) */
&nbsp;
<b class="fc">&nbsp;		q_continue_looping = true;</b>
<b class="fc">&nbsp;		while (q_continue_looping &amp;&amp; it &lt; 100) {</b>
<b class="fc">&nbsp;			it = it + 1;</b>
&nbsp;
<b class="fc">&nbsp;			if (kind == 1) {</b>
<b class="fc">&nbsp;				sin_lam_sph = Math.sin(lam_sph);</b>
&nbsp;
&nbsp;				/*
&nbsp;				 * if ( PE_ABS(PE_PI - PE_ABS(dlam)) &lt; 2.0e-11 ) sin_lam_sph =
&nbsp;				 * 0.0 no--troublesome
&nbsp;				 */
&nbsp;
<b class="fc">&nbsp;				cos_lam_sph = Math.cos(lam_sph);</b>
<b class="fc">&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="fc">&nbsp;				temp = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="fc">&nbsp;				sin_sigma = Math.sqrt(tem1 * tem1 + temp * temp); /*</b>
&nbsp;																 * v14 (Rapp
&nbsp;																 * 1.87)
&nbsp;																 */
<b class="fc">&nbsp;				cos_sigma = sin_eta1 * sin_eta2 + cos_eta1 * cos_eta2</b>
&nbsp;						* cos_lam_sph; /* v15 (Rapp 1.88) */
<b class="fc">&nbsp;				sigma = Math.atan2(sin_sigma, cos_sigma); /* (Rapp 1.89) */</b>
&nbsp;
<b class="fc">&nbsp;				if (PE_ABS(sin_sigma) &lt; eps) /* avoid division by 0 */</b>
&nbsp;				{
<b class="nc">&nbsp;					sin_azeq = cos_eta1 * cos_eta2 * sin_lam_sph</b>
<b class="nc">&nbsp;							/ PE_SGN(eps, sin_sigma);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					sin_azeq = cos_eta1 * cos_eta2 * sin_lam_sph / sin_sigma;</b>
&nbsp;					/* v17 (Rapp 1.90) */
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				cos2_azeq = 1.0 - sin_azeq * sin_azeq;</b>
&nbsp;
<b class="fc">&nbsp;				if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
&nbsp;				{
<b class="fc">&nbsp;					costm = cos_sigma - 2.0</b>
<b class="fc">&nbsp;							* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
&nbsp;				} else {
<b class="fc">&nbsp;					costm = cos_sigma - 2.0 * (sin_eta1 * sin_eta2 / cos2_azeq);</b>
&nbsp;					/* v18 (Rapp 1.91) */
&nbsp;				}
<b class="fc">&nbsp;				costm2 = costm * costm;</b>
<b class="fc">&nbsp;				c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f / 16.0; /*</b>
&nbsp;																				 * v10
&nbsp;																				 * (
&nbsp;																				 * Rapp
&nbsp;																				 * 1.83
&nbsp;																				 * )
&nbsp;																				 */
&nbsp;			}
&nbsp;
&nbsp;			/* entry point of the antipodal loop (kind = 2) */
<b class="fc">&nbsp;			d = (1.0 - c)</b>
&nbsp;					* f
&nbsp;					* (sigma + c * sin_sigma
&nbsp;							* (costm + cos_sigma * c * (2.0 * costm2 - 1.0)));
&nbsp;			/* v11 (Rapp 1.84) */
&nbsp;
<b class="fc">&nbsp;			if (kind == 1) {</b>
<b class="fc">&nbsp;				lam_sph = dlam + d * sin_azeq;</b>
<b class="fc">&nbsp;				if (PE_ABS(lam_sph - test) &lt; tol) {</b>
<b class="fc">&nbsp;					q_continue_looping = false;</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (PE_ABS(lam_sph) &gt; PE_PI) {</b>
<b class="fc">&nbsp;					kind = 2;</b>
<b class="fc">&nbsp;					lam_sph = PE_PI;</b>
<b class="fc">&nbsp;					if (dlam &lt; 0.0) {</b>
<b class="fc">&nbsp;						lam_sph = -lam_sph;</b>
&nbsp;					}
<b class="fc">&nbsp;					sin_azeq = 0.0;</b>
<b class="fc">&nbsp;					cos2_azeq = 1.0;</b>
<b class="fc">&nbsp;					test = 2.0;</b>
<b class="fc">&nbsp;					prev = test;</b>
&nbsp;
<b class="fc">&nbsp;					sigma = PE_PI</b>
<b class="fc">&nbsp;							- PE_ABS(Math.atan(sin_eta1 / cos_eta1)</b>
<b class="fc">&nbsp;									+ Math.atan(sin_eta2 / cos_eta2));</b>
<b class="fc">&nbsp;					sin_sigma = Math.sin(sigma);</b>
<b class="fc">&nbsp;					cos_sigma = Math.cos(sigma);</b>
<b class="fc">&nbsp;					c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f</b>
&nbsp;							/ 16.0; /* v10 (Rapp 1.83) */
&nbsp;
<b class="fc">&nbsp;					if (PE_ABS(sin_azeq - prev) &lt; tol) {</b>
<b class="nc">&nbsp;						q_continue_looping = false;</b>
<b class="nc">&nbsp;						continue;</b>
&nbsp;					}
<b class="fc">&nbsp;					if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
&nbsp;					{
<b class="nc">&nbsp;						costm = cos_sigma</b>
&nbsp;								- 2.0
<b class="nc">&nbsp;								* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
&nbsp;					} else {
<b class="fc">&nbsp;						costm = cos_sigma - 2.0</b>
&nbsp;								* (sin_eta1 * sin_eta2 / cos2_azeq);
&nbsp;						/* v18 (Rapp 1.91) */
&nbsp;					}
<b class="fc">&nbsp;					costm2 = costm * costm;</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (((lam_sph - test) * (test - prev)) &lt; 0.0 &amp;&amp; it &gt; 5) {</b>
&nbsp;					/* refined converge */
<b class="nc">&nbsp;					lam_sph = (2.0 * lam_sph + 3.0 * test + prev) / 6.0;</b>
&nbsp;				}
<b class="fc">&nbsp;				prev = test;</b>
<b class="fc">&nbsp;				test = lam_sph;</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;			} else /* kind == 2 */
&nbsp;			{
<b class="fc">&nbsp;				sin_azeq = (lam_sph - dlam) / d;</b>
<b class="fc">&nbsp;				if (((sin_azeq - test) * (test - prev)) &lt; 0.0 &amp;&amp; it &gt; 5) {</b>
&nbsp;					/* refined converge */
<b class="fc">&nbsp;					sin_azeq = (2.0 * sin_azeq + 3.0 * test + prev) / 6.0;</b>
&nbsp;				}
<b class="fc">&nbsp;				prev = test;</b>
<b class="fc">&nbsp;				test = sin_azeq;</b>
<b class="fc">&nbsp;				cos2_azeq = 1.0 - sin_azeq * sin_azeq;</b>
<b class="fc">&nbsp;				sin_lam_sph = sin_azeq * sin_sigma / (cos_eta1 * cos_eta2);</b>
<b class="fc">&nbsp;				cos_lam_sph = -Math</b>
<b class="fc">&nbsp;						.sqrt(PE_ABS(1.0 - sin_lam_sph * sin_lam_sph));</b>
<b class="fc">&nbsp;				lam_sph = Math.atan2(sin_lam_sph, cos_lam_sph);</b>
<b class="fc">&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="fc">&nbsp;				temp = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="fc">&nbsp;				sin_sigma = Math.sqrt(tem1 * tem1 + temp * temp);</b>
<b class="fc">&nbsp;				cos_sigma = sin_eta1 * sin_eta2 + cos_eta1 * cos_eta2</b>
&nbsp;						* cos_lam_sph;
<b class="fc">&nbsp;				sigma = Math.atan2(sin_sigma, cos_sigma);</b>
<b class="fc">&nbsp;				c = ((-3.0 * cos2_azeq + 4.0) * f + 4.0) * cos2_azeq * f / 16.0; /*</b>
&nbsp;																				 * v10
&nbsp;																				 * (
&nbsp;																				 * Rapp
&nbsp;																				 * 1.83
&nbsp;																				 * )
&nbsp;																				 */
<b class="fc">&nbsp;				if (PE_ABS(sin_azeq - prev) &lt; tol) {</b>
<b class="fc">&nbsp;					q_continue_looping = false;</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;				}
<b class="fc">&nbsp;				if (PE_ABS(cos2_azeq) &lt; eps) /* avoid division by 0 */</b>
&nbsp;				{
<b class="nc">&nbsp;					costm = cos_sigma - 2.0</b>
<b class="nc">&nbsp;							* (sin_eta1 * sin_eta2 / PE_SGN(eps, cos2_azeq));</b>
&nbsp;				} else {
<b class="fc">&nbsp;					costm = cos_sigma - 2.0 * (sin_eta1 * sin_eta2 / cos2_azeq);</b>
&nbsp;					/* v18 (Rapp 1.91) */
&nbsp;				}
<b class="fc">&nbsp;				costm2 = costm * costm;</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;		} /* End of while q_continue_looping */
&nbsp;
&nbsp;		/* Convergence */
&nbsp;
<b class="fc">&nbsp;		if (p_dist != null) {</b>
&nbsp;			/*
&nbsp;			 * Helmert 1880 from Vincenty&#39;s
&nbsp;			 * &quot;Geodetic inverse solution between antipodal points&quot;
&nbsp;			 */
&nbsp;
<b class="fc">&nbsp;			ep2 = 1.0 / (boa * boa) - 1.0;</b>
<b class="fc">&nbsp;			bige = Math.sqrt(1.0 + ep2 * cos2_azeq); /* 15 */</b>
<b class="fc">&nbsp;			bigf = (bige - 1.0) / (bige + 1.0); /* 16 */</b>
<b class="fc">&nbsp;			biga = (1.0 + bigf * bigf / 4.0) / (1.0 - bigf); /* 17 */</b>
<b class="fc">&nbsp;			bigb = bigf * (1.0 - 0.375 * bigf * bigf); /* 18 */</b>
<b class="fc">&nbsp;			z = bigb / 6.0 * costm * (-3.0 + 4.0 * sin_sigma * sin_sigma)</b>
&nbsp;					* (-3.0 + 4.0 * costm2);
<b class="fc">&nbsp;			dsigma = bigb</b>
&nbsp;					* sin_sigma
&nbsp;					* (costm + bigb / 4.0
&nbsp;							* (cos_sigma * (-1.0 + 2.0 * costm2) - z)); /* 19 */
<b class="fc">&nbsp;			dist = (boa * a) * biga * (sigma - dsigma); /* 20 */</b>
&nbsp;
<b class="fc">&nbsp;			p_dist.val = dist;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (p_az12 != null || p_az21 != null) {</b>
<b class="nc">&nbsp;			if (kind == 2) /* antipodal */</b>
&nbsp;			{
<b class="nc">&nbsp;				az12 = sin_azeq / cos_eta1;</b>
<b class="nc">&nbsp;				az21 = Math.sqrt(1.0 - az12 * az12);</b>
<b class="nc">&nbsp;				if (temp &lt; 0.0) {</b>
<b class="nc">&nbsp;					az21 = -az21;</b>
&nbsp;				}
<b class="nc">&nbsp;				az12 = Math.atan2(az12, az21);</b>
<b class="nc">&nbsp;				tem1 = -sin_azeq;</b>
<b class="nc">&nbsp;				tem2 = sin_eta1 * sin_sigma - cos_eta1 * cos_sigma * az21;</b>
<b class="nc">&nbsp;				az21 = Math.atan2(tem1, tem2);</b>
&nbsp;			} else /* long-line */
&nbsp;			{
<b class="nc">&nbsp;				tem1 = cos_eta2 * sin_lam_sph;</b>
<b class="nc">&nbsp;				tem2 = cos_eta1 * sin_eta2 - sin_eta1 * cos_eta2 * cos_lam_sph;</b>
<b class="nc">&nbsp;				az12 = Math.atan2(tem1, tem2);</b>
<b class="nc">&nbsp;				tem1 = -cos_eta1 * sin_lam_sph;</b>
<b class="nc">&nbsp;				tem2 = sin_eta1 * cos_eta2 - cos_eta1 * sin_eta2 * cos_lam_sph;</b>
<b class="nc">&nbsp;				az21 = Math.atan2(tem1, tem2);</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			if (p_az12 != null) {</b>
<b class="nc">&nbsp;				p_az12.val = lam_delta(az12);</b>
&nbsp;			}
<b class="nc">&nbsp;			if (p_az21 != null) {</b>
<b class="nc">&nbsp;				p_az21.val = lam_delta(az21);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
