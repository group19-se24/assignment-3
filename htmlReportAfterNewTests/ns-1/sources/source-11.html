


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CrackAndCluster</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: CrackAndCluster (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CrackAndCluster</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (48/60)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;//Implementation of the cracking and clustering algorithm.
&nbsp;//Cracks and clusters all segments and vertices in the EditShape.
&nbsp;
<b class="fc">&nbsp;final class CrackAndCluster {</b>
<b class="fc">&nbsp;	private EditShape m_shape = null;</b>
<b class="fc">&nbsp;	private ProgressTracker m_progressTracker = null;</b>
&nbsp;	private double m_tolerance;
<b class="fc">&nbsp;	private boolean m_filter_degenerate_segments = true;</b>
&nbsp;
<b class="fc">&nbsp;	private CrackAndCluster(ProgressTracker progressTracker) {</b>
<b class="fc">&nbsp;		m_progressTracker = progressTracker;</b>
&nbsp;	}
&nbsp;
&nbsp;    static boolean non_empty_points_need_to_cluster(double tolerance, Point pt1, Point pt2)
&nbsp;    {
<b class="nc">&nbsp;      double tolerance_for_clustering = InternalUtils.adjust_tolerance_for_TE_clustering(tolerance);</b>
<b class="nc">&nbsp;      return Clusterer.isClusterCandidate_(pt1.getX(), pt1.getY(), pt2.getX(), pt2.getY(), MathUtils.sqr(tolerance_for_clustering));</b>
&nbsp;    }
&nbsp;
&nbsp;    static Point cluster_non_empty_points(Point pt1, Point pt2, double w1, int rank1, double w2, int rank2)
&nbsp;    {
<b class="nc">&nbsp;      if (rank1 &gt; rank2)</b>
&nbsp;      {
<b class="nc">&nbsp;        return pt1;</b>
&nbsp;      }
<b class="nc">&nbsp;      else if (rank2 &lt; rank1)</b>
&nbsp;      {
<b class="nc">&nbsp;        return pt2;</b>
&nbsp;      }
&nbsp;
<b class="nc">&nbsp;      int [] rank = null;</b>
<b class="nc">&nbsp;      double [] w = null;</b>
<b class="nc">&nbsp;      Point pt = new Point();</b>
<b class="nc">&nbsp;      Clusterer.mergeVertices(pt1, pt2, w1, rank1, w2, rank2, pt, w, rank);</b>
<b class="nc">&nbsp;      return pt;</b>
&nbsp;    }
&nbsp;	
&nbsp;	public static boolean execute(EditShape shape, double tolerance,
&nbsp;			ProgressTracker progressTracker, boolean filter_degenerate_segments) {
<b class="fc">&nbsp;		CrackAndCluster cracker = new CrackAndCluster(progressTracker);</b>
<b class="fc">&nbsp;		cracker.m_shape = shape;</b>
<b class="fc">&nbsp;		cracker.m_tolerance = tolerance;</b>
<b class="fc">&nbsp;		cracker.m_filter_degenerate_segments = filter_degenerate_segments;</b>
<b class="fc">&nbsp;		return cracker._do();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean _cluster(double toleranceCluster) {
<b class="fc">&nbsp;		boolean res = Clusterer.executeNonReciprocal(m_shape, toleranceCluster);</b>
<b class="fc">&nbsp;		return res;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean _crack(double tolerance_for_cracking) {
<b class="fc">&nbsp;		boolean res = Cracker.execute(m_shape, tolerance_for_cracking, m_progressTracker);</b>
<b class="fc">&nbsp;		return res;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean _do() {
<b class="fc">&nbsp;		double tol = m_tolerance;</b>
&nbsp;
&nbsp;		// Use same tolerances as ArcObjects (2 * sqrt(2) * tolerance for
&nbsp;		// clustering)
&nbsp;		// sqrt(2) * tolerance for cracking.
&nbsp;		// Also, inflate the tolerances slightly to insure the simplified result
&nbsp;		// would not change after small rounding issues.
&nbsp;
<b class="fc">&nbsp;		final double c_factor = 1e-5;</b>
<b class="fc">&nbsp;		final double c_factor_for_needs_cracking = 1e-6;</b>
<b class="fc">&nbsp;		double tolerance_for_clustering = InternalUtils</b>
<b class="fc">&nbsp;				.adjust_tolerance_for_TE_clustering(tol);</b>
<b class="fc">&nbsp;		double tolerance_for_needs_cracking = InternalUtils</b>
<b class="fc">&nbsp;				.adjust_tolerance_for_TE_cracking(tol);</b>
<b class="fc">&nbsp;		double tolerance_for_cracking = tolerance_for_needs_cracking</b>
&nbsp;				* (1.0 + c_factor);
<b class="fc">&nbsp;		tolerance_for_needs_cracking *= (1.0 + c_factor_for_needs_cracking);</b>
&nbsp;
&nbsp;		// Require tolerance_for_clustering &gt; tolerance_for_cracking &gt;
&nbsp;		// tolerance_for_needs_cracking
<b class="fc">&nbsp;		assert (tolerance_for_clustering &gt; tolerance_for_cracking);</b>
<b class="fc">&nbsp;		assert (tolerance_for_cracking &gt; tolerance_for_needs_cracking);</b>
&nbsp;
&nbsp;		// double toleranceCluster = m_tolerance * Math.sqrt(2.0) * 1.00001;
<b class="fc">&nbsp;		boolean bChanged = false;</b>
<b class="fc">&nbsp;		int max_iter = m_shape.getTotalPointCount() + 10 &gt; 30 ? 1000 : (m_shape</b>
<b class="fc">&nbsp;				.getTotalPointCount() + 10)</b>
<b class="fc">&nbsp;				* (m_shape.getTotalPointCount() + 10);</b>
<b class="fc">&nbsp;		int iter = 0;</b>
<b class="fc">&nbsp;		boolean has_point_features = m_shape.hasPointFeatures();</b>
<b class="fc">&nbsp;		for (;; iter++) {</b>
<b class="fc">&nbsp;			if (iter &gt; max_iter)</b>
<b class="nc">&nbsp;				throw new GeometryException(</b>
&nbsp;						&quot;Internal Error: max number of iterations exceeded&quot;);// too
&nbsp;																				// many
&nbsp;																				// iterations
&nbsp;
<b class="fc">&nbsp;			boolean bClustered = _cluster(tolerance_for_clustering); // find</b>
&nbsp;																		// close
&nbsp;			// vertices and
&nbsp;			// clamp them
&nbsp;			// together.
<b class="fc">&nbsp;			bChanged |= bClustered;</b>
&nbsp;			
<b class="fc">&nbsp;			if (m_filter_degenerate_segments) {</b>
<b class="fc">&nbsp;				boolean bFiltered = (m_shape.filterClosePoints(</b>
&nbsp;						tolerance_for_clustering, true, false) != 0); // remove all
&nbsp;																// degenerate
&nbsp;																// segments.
<b class="fc">&nbsp;				bChanged |= bFiltered;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			boolean b_cracked = false;</b>
<b class="fc">&nbsp;			if (iter == 0</b>
&nbsp;					|| has_point_features
<b class="fc">&nbsp;					|| Cracker.needsCracking(true, m_shape,</b>
&nbsp;							tolerance_for_needs_cracking, null,
&nbsp;							m_progressTracker)) {
&nbsp;				// Cracks only if shape contains segments.
<b class="fc">&nbsp;				b_cracked = _crack(tolerance_for_cracking); // crack all</b>
&nbsp;															// segments at
&nbsp;															// intersection
&nbsp;															// points and touch
&nbsp;															// points. If
&nbsp;															// Cracked, then the
&nbsp;															// iteration will be
&nbsp;															// repeated.
<b class="fc">&nbsp;				bChanged |= b_cracked;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (!b_cracked)</b>
<b class="fc">&nbsp;				break;// was not cracked, so we can bail out.</b>
&nbsp;			else {
&nbsp;				// Loop while cracking happens.
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			ProgressTracker.checkAndThrow(m_progressTracker);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return bChanged;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
