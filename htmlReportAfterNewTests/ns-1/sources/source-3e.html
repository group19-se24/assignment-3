


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MultiPointImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: MultiPointImpl (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MultiPointImpl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62,1%
  </span>
  <span class="absValue">
    (18/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68,4%
  </span>
  <span class="absValue">
    (93/136)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.VertexDescription.Semantics;
&nbsp;
&nbsp;import static com.esri.core.geometry.SizeOf.SIZE_OF_MULTI_POINT_IMPL;
&nbsp;
&nbsp;/**
&nbsp; * The MultiPoint is a collection of points.
&nbsp; */
&nbsp;final class MultiPointImpl extends MultiVertexGeometryImpl {
&nbsp;	public MultiPointImpl() {
<b class="fc">&nbsp;		super();</b>
<b class="fc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="fc">&nbsp;		m_pointCount = 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	public MultiPointImpl(VertexDescription description) {
<b class="fc">&nbsp;		super();</b>
<b class="fc">&nbsp;		if (description == null)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		m_description = description;</b>
<b class="fc">&nbsp;		m_pointCount = 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry createInstance() {
<b class="nc">&nbsp;		return new MultiPoint(m_description);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds a Point to this MultiPoint.
&nbsp;	 */
&nbsp;	public void add(Point point) {
<b class="fc">&nbsp;		resize(m_pointCount + 1);</b>
<b class="fc">&nbsp;		setPoint(m_pointCount - 1, point);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds a Point to this MultiPoint with given x, y coordinates.
&nbsp;	 */
&nbsp;	public void add(double x, double y) {
<b class="fc">&nbsp;		resize(m_pointCount + 1);</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;		pt.setCoords(x, y);</b>
<b class="fc">&nbsp;		setXY(m_pointCount - 1, pt);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Adds a Point to this MultiPoint with given x, y, z coordinates.
&nbsp;	 */
&nbsp;	public void add(double x, double y, double z) {
<b class="fc">&nbsp;		resize(m_pointCount + 1);</b>
<b class="fc">&nbsp;		Point3D pt = new Point3D();</b>
<b class="fc">&nbsp;		pt.setCoords(x, y, z);</b>
<b class="fc">&nbsp;		setXYZ(m_pointCount - 1, pt);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Appends points from another MultiVertexGeometryImpl at the end of this
&nbsp;	 * one.
&nbsp;	 * 
&nbsp;	 * @param src
&nbsp;	 *            The source MultiVertexGeometryImpl
&nbsp;	 */
&nbsp;	public void add(MultiVertexGeometryImpl src, int beginIndex, int endIndex) {
<b class="fc">&nbsp;		int endIndexC = endIndex &lt; 0 ? src.getPointCount() : endIndex;</b>
<b class="fc">&nbsp;		if (beginIndex &lt; 0 || beginIndex &gt; src.getPointCount()</b>
&nbsp;				|| endIndexC &lt; beginIndex)
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		if (beginIndex == endIndexC)</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		mergeVertexDescription(src.getDescription());</b>
<b class="fc">&nbsp;		int count = endIndexC - beginIndex;</b>
<b class="fc">&nbsp;		int oldPointCount = m_pointCount;</b>
<b class="fc">&nbsp;		resize(m_pointCount + count);</b>
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		for (int iattrib = 0, nattrib = src.getDescription()</b>
<b class="fc">&nbsp;				.getAttributeCount(); iattrib &lt; nattrib; iattrib++) {</b>
<b class="fc">&nbsp;			int semantics = src.getDescription()._getSemanticsImpl(iattrib);</b>
<b class="fc">&nbsp;			int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;			AttributeStreamBase stream = getAttributeStreamRef(semantics);</b>
<b class="fc">&nbsp;			AttributeStreamBase srcStream = src</b>
<b class="fc">&nbsp;					.getAttributeStreamRef(semantics);</b>
<b class="fc">&nbsp;			stream.insertRange(oldPointCount * ncomps, srcStream, beginIndex</b>
&nbsp;					* ncomps, count * ncomps, true, 1, oldPointCount * ncomps);
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void addPoints(Point2D[] points) {
<b class="nc">&nbsp;		int count = points.length;</b>
<b class="nc">&nbsp;		int oldPointCount = m_pointCount;</b>
<b class="nc">&nbsp;		resize(m_pointCount + count);</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; count; i++)</b>
<b class="nc">&nbsp;			setXY(oldPointCount + i, points[i]);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void insertPoint(int beforePointIndex, Point pt) {
<b class="fc">&nbsp;		if (beforePointIndex &gt; getPointCount())</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds&quot;);</b>
&nbsp;
<b class="fc">&nbsp;		if (beforePointIndex &lt; 0)</b>
<b class="nc">&nbsp;			beforePointIndex = getPointCount();</b>
&nbsp;
<b class="fc">&nbsp;		mergeVertexDescription(pt.getDescription());</b>
<b class="fc">&nbsp;		int oldPointCount = m_pointCount;</b>
<b class="fc">&nbsp;		_resizeImpl(m_pointCount + 1);</b>
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
<b class="fc">&nbsp;		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</b>
<b class="fc">&nbsp;			int semantics = m_description._getSemanticsImpl(iattr);</b>
<b class="fc">&nbsp;			int comp = VertexDescription.getComponentCount(semantics);</b>
&nbsp;
<b class="fc">&nbsp;			AttributeStreamBase stream = AttributeStreamBase</b>
<b class="fc">&nbsp;					.createAttributeStreamWithSemantics(semantics, 1);</b>
<b class="fc">&nbsp;			if (pt.hasAttribute(semantics)) {</b>
<b class="fc">&nbsp;				m_vertexAttributes[iattr]</b>
<b class="fc">&nbsp;						.insertAttributes(comp * beforePointIndex, pt,</b>
&nbsp;								semantics, comp * oldPointCount);
&nbsp;			} else {
&nbsp;				// Need to make room for the attribute, so we copy a default
&nbsp;				// value in
&nbsp;
<b class="nc">&nbsp;				double v = VertexDescription.getDefaultValue(semantics);</b>
<b class="nc">&nbsp;				m_vertexAttributes[iattr].insertRange(comp * beforePointIndex,</b>
&nbsp;						v, comp, comp * oldPointCount);
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	void removePoint(int pointIndex) {
<b class="fc">&nbsp;		if (pointIndex &lt; 0 || pointIndex &gt;= getPointCount())</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds&quot;);</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
&nbsp;		// Remove the attribute value for the path
<b class="fc">&nbsp;		for (int iattr = 0, nattr = m_description.getAttributeCount(); iattr &lt; nattr; iattr++) {</b>
<b class="fc">&nbsp;			if (m_vertexAttributes[iattr] != null) {</b>
<b class="fc">&nbsp;				int semantics = m_description._getSemanticsImpl(iattr);</b>
<b class="fc">&nbsp;				int comp = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;				m_vertexAttributes[iattr].eraseRange(comp * pointIndex, comp,</b>
&nbsp;						comp * m_pointCount);
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		m_pointCount--;</b>
<b class="fc">&nbsp;		m_reservedPointCount--;</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Resizes the MultiPoint to have the given size.
&nbsp;	 */
&nbsp;	public void resize(int pointCount) {
<b class="fc">&nbsp;		_resizeImpl(pointCount);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	void _copyToImpl(MultiVertexGeometryImpl mvg) {
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public void setEmpty() {
<b class="fc">&nbsp;		super._setEmptyImpl();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void applyTransformation(Transformation2D transform) {
<b class="fc">&nbsp;		if (isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		Point2D pt2 = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		for (int ipoint = 0; ipoint &lt; m_pointCount; ipoint++) {</b>
<b class="fc">&nbsp;			pt2.x = points.read(ipoint * 2);</b>
<b class="fc">&nbsp;			pt2.y = points.read(ipoint * 2 + 1);</b>
&nbsp;
<b class="fc">&nbsp;			transform.transform(pt2, pt2);</b>
<b class="fc">&nbsp;			points.write(ipoint * 2, pt2.x);</b>
<b class="fc">&nbsp;			points.write(ipoint * 2 + 1, pt2.y);</b>
&nbsp;		}
&nbsp;
&nbsp;		// REFACTOR: reset the exact envelope only and transform the loose
&nbsp;		// envelope
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	void applyTransformation(Transformation3D transform) {
<b class="nc">&nbsp;		if (isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="nc">&nbsp;		_verifyAllStreams();</b>
<b class="nc">&nbsp;		addAttribute(Semantics.Z);</b>
<b class="nc">&nbsp;		_verifyAllStreams();</b>
<b class="nc">&nbsp;		AttributeStreamOfDbl points = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="nc">&nbsp;		AttributeStreamOfDbl zs = (AttributeStreamOfDbl) m_vertexAttributes[1];</b>
<b class="nc">&nbsp;		Point3D pt3 = new Point3D();</b>
<b class="nc">&nbsp;		for (int ipoint = 0; ipoint &lt; m_pointCount; ipoint++) {</b>
<b class="nc">&nbsp;			pt3.x = points.read(ipoint * 2);</b>
<b class="nc">&nbsp;			pt3.y = points.read(ipoint * 2 + 1);</b>
<b class="nc">&nbsp;			pt3.z = zs.read(ipoint);</b>
&nbsp;
<b class="nc">&nbsp;			Point3D res = transform.transform(pt3);</b>
<b class="nc">&nbsp;			points.write(ipoint * 2, res.x);</b>
<b class="nc">&nbsp;			points.write(ipoint * 2 + 1, res.y);</b>
<b class="nc">&nbsp;			zs.write(ipoint, res.z);</b>
&nbsp;		}
&nbsp;
&nbsp;		// REFACTOR: reset the exact envelope only and transform the loose
&nbsp;		// envelope
<b class="nc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getDimension() {
<b class="nc">&nbsp;		return 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public long estimateMemorySize()
&nbsp;	{
<b class="fc">&nbsp;		long size = SIZE_OF_MULTI_POINT_IMPL + (m_envelope != null ? m_envelope.estimateMemorySize() : 0);</b>
&nbsp;
<b class="fc">&nbsp;		if (m_vertexAttributes != null) {</b>
<b class="fc">&nbsp;			for (int i = 0; i &lt; m_vertexAttributes.length; i++) {</b>
<b class="fc">&nbsp;				size += m_vertexAttributes[i].estimateMemorySize();</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return size;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry.Type getType() {
<b class="fc">&nbsp;		return Type.MultiPoint;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public double calculateArea2D() {
<b class="nc">&nbsp;		return 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public double calculateLength2D() {
<b class="nc">&nbsp;		return 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Object _getImpl() {
<b class="nc">&nbsp;		return this;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean equals(Object other) {
<b class="fc">&nbsp;		if (other == this)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (!(other instanceof MultiPointImpl))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return super.equals(other);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void addPoints(Point[] points) {
<b class="nc">&nbsp;		int count = points.length;</b>
&nbsp;		// int oldPointCount = m_pointCount;
<b class="nc">&nbsp;		resize(m_pointCount + count);</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; count; i++)</b>
<b class="nc">&nbsp;			setPoint(i, points[i]);</b>
&nbsp;	}
&nbsp;
&nbsp;	public int queryCoordinates(Point2D[] dst, int dstSize, int beginIndex,
&nbsp;			int endIndex) {
<b class="fc">&nbsp;		int endIndexC = endIndex &lt; 0 ? m_pointCount : endIndex;</b>
<b class="fc">&nbsp;		endIndexC = Math.min(endIndexC, beginIndex + dstSize);</b>
&nbsp;
<b class="fc">&nbsp;		if (beginIndex &lt; 0 || beginIndex &gt;= m_pointCount</b>
&nbsp;				|| endIndexC &lt; beginIndex || dst.length != dstSize)
<b class="nc">&nbsp;			throw new IllegalArgumentException();// GEOMTHROW(invalid_argument);</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</b>
<b class="fc">&nbsp;		int pointCountToRead = endIndexC - beginIndex;</b>
<b class="fc">&nbsp;		double[] dstArray = new double[pointCountToRead * 2];</b>
<b class="fc">&nbsp;		xy.readRange(2 * beginIndex, pointCountToRead * 2, dstArray, 0, true);</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCountToRead; i++) {</b>
<b class="fc">&nbsp;			dst[i] = new Point2D(dstArray[i * 2], dstArray[i * 2 + 1]);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return endIndexC;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void _notifyModifiedAllImpl() {
&nbsp;		// TODO Auto-generated method stub
&nbsp;
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	protected void _verifyStreamsImpl() {
&nbsp;		// TODO Auto-generated method stub
&nbsp;
<b class="fc">&nbsp;	}</b>
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean _buildRasterizedGeometryAccelerator(double toleranceXY,
&nbsp;			GeometryAccelerationDegree accelDegree) {
&nbsp;		// TODO Auto-generated method stub
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean _buildQuadTreeAccelerator(GeometryAccelerationDegree accelDegree) {
&nbsp;		// TODO Auto-generated method stub
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;	
&nbsp;	// @Override
&nbsp;	// void _notifyModifiedAllImpl() {
&nbsp;	// // TODO Auto-generated method stub
&nbsp;	//
&nbsp;	// }
&nbsp;
&nbsp;	// @Override
&nbsp;	// protected void _verifyStreamsImpl() {
&nbsp;	// // TODO Auto-generated method stub
&nbsp;	//
&nbsp;	// }
&nbsp;
&nbsp;    @Override
&nbsp;    public Geometry getBoundary() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:42</div>
</div>
</body>
</html>
