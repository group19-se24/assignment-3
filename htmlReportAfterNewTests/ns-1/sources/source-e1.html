


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Treap</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: Treap (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Treap</td>
<td class="coverageStat">
  <span class="percent">
    94%
  </span>
  <span class="absValue">
    (63/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94,6%
  </span>
  <span class="absValue">
    (404/427)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Treap$Comparator</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    56,2%
  </span>
  <span class="absValue">
    (9/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Treap$MonikerComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88,5%
  </span>
  <span class="absValue">
    (69/78)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93,2%
  </span>
  <span class="absValue">
    (414/444)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
<b class="fc">&nbsp;final class Treap {</b>
&nbsp;	static abstract class Comparator {
<b class="fc">&nbsp;		Comparator() {</b>
<b class="fc">&nbsp;			m_b_notify_on_actions = false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Comparator(boolean bNotifyOnActions) {</b>
<b class="fc">&nbsp;			m_b_notify_on_actions = bNotifyOnActions;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Compares the element elm to the element contained in the given node
&nbsp;		abstract int compare(Treap treap, int elm, int node);
&nbsp;
&nbsp;		// These virtual methods are called only when Comparator(true) ctro has
&nbsp;		// been used.
&nbsp;		void onDelete(int elm) {
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		void onSet(int elm) {
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		void onEndSearch(int elm) {
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		void onAddUniqueElementFailed(int elm) {
<b class="nc">&nbsp;		}</b>
&nbsp;
&nbsp;		private boolean m_b_notify_on_actions;
&nbsp;
&nbsp;		// void operator=(const Comparator&amp;); // do not allow operator =
&nbsp;		void onDeleteImpl_(Treap treap, int node) {
<b class="fc">&nbsp;			if (m_b_notify_on_actions)</b>
<b class="fc">&nbsp;				onDelete(treap.getElement(node));</b>
&nbsp;		}
&nbsp;
&nbsp;		void onSetImpl_(Treap treap, int node) {
<b class="fc">&nbsp;			if (m_b_notify_on_actions)</b>
<b class="nc">&nbsp;				onSet(treap.getElement(node));</b>
&nbsp;		}
&nbsp;
&nbsp;		void onAddUniqueElementFailedImpl_(int elm) {
<b class="fc">&nbsp;			if (m_b_notify_on_actions)</b>
<b class="fc">&nbsp;				onAddUniqueElementFailed(elm);</b>
&nbsp;		}
&nbsp;
&nbsp;		void onEndSearchImpl_(int elm) {
<b class="nc">&nbsp;			if (m_b_notify_on_actions)</b>
<b class="nc">&nbsp;				onEndSearch(elm);</b>
&nbsp;		}
&nbsp;	};
&nbsp;
<b class="fc">&nbsp;	static abstract class MonikerComparator {</b>
&nbsp;		// Compares the moniker, contained in the MonikerComparator with the
&nbsp;		// element contained in the given node.
&nbsp;		abstract int compare(Treap treap, int node);
&nbsp;	};
&nbsp;
<b class="fc">&nbsp;	public Treap() {</b>
<b class="fc">&nbsp;		m_random = 124234251;</b>
<b class="fc">&nbsp;		m_b_balancing = true;</b>
<b class="fc">&nbsp;		m_touchFlag = 0;</b>
<b class="fc">&nbsp;		m_defaultTreap = nullNode();</b>
<b class="fc">&nbsp;		m_treapData = new StridedIndexTypeCollection(7);</b>
<b class="fc">&nbsp;		m_comparator = null;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Sets the comparator
&nbsp;	public void setComparator(Comparator comparator) {
<b class="fc">&nbsp;		m_comparator = comparator;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the comparator
&nbsp;	public Comparator getComparator() {
<b class="nc">&nbsp;		return m_comparator;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Stops auto-balancing
&nbsp;	public void disableBalancing() {
<b class="fc">&nbsp;		m_b_balancing = false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Reserves memory for nodes givne number of nodes
&nbsp;	public void setCapacity(int capacity) {
<b class="fc">&nbsp;		m_treapData.setCapacity(capacity);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Create a new treap and returns the treap handle.
&nbsp;	public int createTreap(int treap_data) {
<b class="fc">&nbsp;		int treap = m_treapData.newElement();</b>
<b class="fc">&nbsp;		setSize_(0, treap);</b>
<b class="fc">&nbsp;		setTreapData_(treap_data, treap);</b>
<b class="fc">&nbsp;		return treap;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Deletes the treap at the given treap handle.
&nbsp;	public void deleteTreap(int treap) {
<b class="fc">&nbsp;		m_treapData.deleteElement(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Adds new element to the treap. Allows duplicates to be added.
&nbsp;	public int addElement(int element, int treap) {
&nbsp;		int treap_;
<b class="fc">&nbsp;		if (treap == -1) {</b>
<b class="fc">&nbsp;			if (m_defaultTreap == nullNode())</b>
<b class="fc">&nbsp;				m_defaultTreap = createTreap(-1);</b>
<b class="fc">&nbsp;			treap_ = m_defaultTreap;</b>
&nbsp;		} else {
<b class="fc">&nbsp;			treap_ = treap;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return addElement_(element, 0, treap_);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Adds new element to the treap if it is not equal to other elements.
&nbsp;	// If the return value is -1, then get_duplicate_element reutrns the node of
&nbsp;	// the already existing element equal to element.
&nbsp;	public int addUniqueElement(int element, int treap) {
&nbsp;		int treap_;
<b class="fc">&nbsp;		if (treap == -1) {</b>
<b class="fc">&nbsp;			if (m_defaultTreap == nullNode())</b>
<b class="fc">&nbsp;				m_defaultTreap = createTreap(-1);</b>
<b class="fc">&nbsp;			treap_ = m_defaultTreap;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			treap_ = treap;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return addElement_(element, 1, treap_);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Adds a new element to the treap that is known to be bigger or equal of
&nbsp;	// all elements already in the treap.
&nbsp;	// Use this method when adding elements from a sorted list for maximum
&nbsp;	// performance (it does not call the treap comparator).
&nbsp;	public int addBiggestElement(int element, int treap) {
&nbsp;		int treap_;
<b class="fc">&nbsp;		if (treap == -1) {</b>
<b class="fc">&nbsp;			if (m_defaultTreap == nullNode())</b>
<b class="fc">&nbsp;				m_defaultTreap = createTreap(-1);</b>
<b class="fc">&nbsp;			treap_ = m_defaultTreap;</b>
&nbsp;		} else {
<b class="nc">&nbsp;			treap_ = treap;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (getRoot_(treap_) == nullNode()) {</b>
<b class="fc">&nbsp;			int newNode = newNode_(element);</b>
<b class="fc">&nbsp;			setRoot_(newNode, treap_);</b>
<b class="fc">&nbsp;			addToList_(-1, newNode, treap_);</b>
<b class="fc">&nbsp;			return newNode;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int cur = getLast_(treap_);</b>
<b class="fc">&nbsp;		int newNode = newNode_(element);</b>
<b class="fc">&nbsp;		setRight_(cur, newNode);</b>
<b class="fc">&nbsp;		setParent_(newNode, cur);</b>
<b class="fc">&nbsp;		assert (m_b_balancing);// don&#39;t use this method for unbalanced tree, or</b>
&nbsp;								// the performance will be bad.
<b class="fc">&nbsp;		bubbleUp_(newNode);</b>
<b class="fc">&nbsp;		if (getParent(newNode) == nullNode())</b>
<b class="fc">&nbsp;			setRoot_(newNode, treap_);</b>
&nbsp;
<b class="fc">&nbsp;		addToList_(-1, newNode, treap_);</b>
<b class="fc">&nbsp;		return newNode;</b>
&nbsp;	}
&nbsp;
&nbsp;	// template &lt;class Iterator&gt; void build_from_sorted(const Iterator&amp; begin,
&nbsp;	// const Iterator&amp; end);
&nbsp;	// Adds new element to the treap at the known position, thus avoiding a call
&nbsp;	// to the comparator.
&nbsp;	// If bCallCompare is True, the comparator will be called at most twice,
&nbsp;	// once to compare with prevElement and once to compare with nextElement.
&nbsp;	// When bUnique is true, if the return value is -1, then
&nbsp;	// get_duplicate_element reutrns the node of the already existing element.
&nbsp;	public int addElementAtPosition(int prevNode, int nextNode, int element,
&nbsp;			boolean bUnique, boolean bCallCompare, int treap) {
<b class="fc">&nbsp;		int treap_ = treap;</b>
<b class="fc">&nbsp;		if (treap_ == -1) {</b>
<b class="fc">&nbsp;			if (m_defaultTreap == nullNode())</b>
<b class="nc">&nbsp;				m_defaultTreap = createTreap(-1);</b>
<b class="fc">&nbsp;			treap_ = m_defaultTreap;</b>
&nbsp;		}
&nbsp;
&nbsp;		// dbg_check_(m_root);
<b class="fc">&nbsp;		if (getRoot_(treap_) == nullNode()) {</b>
<b class="fc">&nbsp;			assert (nextNode == nullNode() &amp;&amp; prevNode == nullNode());</b>
<b class="fc">&nbsp;			int root = newNode_(element);</b>
<b class="fc">&nbsp;			setRoot_(root, treap_);</b>
<b class="fc">&nbsp;			addToList_(-1, root, treap_);</b>
<b class="fc">&nbsp;			return root;</b>
&nbsp;		}
&nbsp;
&nbsp;		int cmpNext;
&nbsp;		int cmpPrev;
<b class="fc">&nbsp;		if (bCallCompare) {</b>
<b class="fc">&nbsp;			cmpNext = nextNode != nullNode() ? m_comparator.compare(this,</b>
<b class="fc">&nbsp;					element, nextNode) : -1;</b>
<b class="fc">&nbsp;			assert (cmpNext &lt;= 0);</b>
<b class="fc">&nbsp;			cmpPrev = prevNode != nullNode() ? m_comparator.compare(this,</b>
<b class="fc">&nbsp;					element, prevNode) : 1;</b>
&nbsp;			// cmpPrev can be negative in plane sweep when intersection is
&nbsp;			// detected.
&nbsp;		} else {
<b class="fc">&nbsp;			cmpNext = -1;</b>
<b class="fc">&nbsp;			cmpPrev = 1;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (bUnique &amp;&amp; (cmpNext == 0 || cmpPrev == 0)) {</b>
<b class="nc">&nbsp;			m_comparator.onAddUniqueElementFailedImpl_(element);</b>
<b class="nc">&nbsp;			int cur = cmpNext == 0 ? nextNode : prevNode;</b>
<b class="nc">&nbsp;			setDuplicateElement_(cur, treap_);</b>
<b class="nc">&nbsp;			return -1;// return negative value.</b>
&nbsp;		}
&nbsp;
&nbsp;		int cur;
&nbsp;		int cmp;
&nbsp;		boolean bNext;
<b class="fc">&nbsp;		if (nextNode != nullNode() &amp;&amp; prevNode != nullNode()) {</b>
&nbsp;			// randomize the the cost to insert a node.
<b class="fc">&nbsp;			bNext = m_random &gt; NumberUtils.nextRand(m_random) &gt;&gt; 1;</b>
&nbsp;		} else
<b class="fc">&nbsp;			bNext = nextNode != nullNode();</b>
&nbsp;
<b class="fc">&nbsp;		if (bNext) {</b>
<b class="fc">&nbsp;			cmp = cmpNext;</b>
<b class="fc">&nbsp;			cur = nextNode;</b>
&nbsp;		} else {
<b class="fc">&nbsp;			cmp = cmpPrev;</b>
<b class="fc">&nbsp;			cur = prevNode;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int newNode = -1;</b>
<b class="fc">&nbsp;		int before = -1;</b>
<b class="fc">&nbsp;		boolean b_first = true;</b>
&nbsp;		for (;;) {
<b class="fc">&nbsp;			if (cmp &lt; 0) {</b>
<b class="fc">&nbsp;				int left = getLeft(cur);</b>
<b class="fc">&nbsp;				if (left != nullNode())</b>
<b class="fc">&nbsp;					cur = left;</b>
&nbsp;				else {
<b class="fc">&nbsp;					before = cur;</b>
<b class="fc">&nbsp;					newNode = newNode_(element);</b>
<b class="fc">&nbsp;					setLeft_(cur, newNode);</b>
<b class="fc">&nbsp;					setParent_(newNode, cur);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;			} else {</b>
<b class="fc">&nbsp;				int right = getRight(cur);</b>
<b class="fc">&nbsp;				if (right != nullNode())</b>
<b class="fc">&nbsp;					cur = right;</b>
&nbsp;				else {
<b class="fc">&nbsp;					before = getNext(cur);</b>
<b class="fc">&nbsp;					newNode = newNode_(element);</b>
<b class="fc">&nbsp;					setRight_(cur, newNode);</b>
<b class="fc">&nbsp;					setParent_(newNode, cur);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (b_first) {</b>
<b class="fc">&nbsp;				cmp *= -1;</b>
<b class="fc">&nbsp;				b_first = false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		bubbleUp_(newNode);</b>
<b class="fc">&nbsp;		if (getParent(newNode) == nullNode())</b>
<b class="fc">&nbsp;			setRoot_(newNode, treap_);</b>
&nbsp;
<b class="fc">&nbsp;		addToList_(before, newNode, treap_);</b>
&nbsp;		// dbg_check_(m_root);
<b class="fc">&nbsp;		return newNode;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Get duplicate element
&nbsp;	public int getDuplicateElement(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return getDuplicateElement_(m_defaultTreap);</b>
&nbsp;
<b class="nc">&nbsp;		return getDuplicateElement_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Removes a node from the treap. Throws if doesn&#39;t exist.
&nbsp;	public void deleteNode(int treap_node_index, int treap) {
<b class="fc">&nbsp;		touch_();</b>
&nbsp;		// assert(isValidNode(treap_node_index));
<b class="fc">&nbsp;		if (m_comparator != null)</b>
<b class="fc">&nbsp;			m_comparator.onDeleteImpl_(this, treap_node_index);</b>
&nbsp;
&nbsp;		int treap_;
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			treap_ = m_defaultTreap;</b>
&nbsp;		else
<b class="fc">&nbsp;			treap_ = treap;</b>
&nbsp;
<b class="fc">&nbsp;		if (!m_b_balancing) {</b>
<b class="fc">&nbsp;			unbalancedDelete_(treap_node_index, treap_);</b>
&nbsp;		} else
<b class="fc">&nbsp;			deleteNode_(treap_node_index, treap_);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Finds an element in the treap and returns its node or -1.
&nbsp;	public int search(int data, int treap) {
<b class="fc">&nbsp;		int cur = getRoot(treap);</b>
<b class="fc">&nbsp;		while (cur != nullNode()) {</b>
<b class="fc">&nbsp;			int res = m_comparator.compare(this, data, cur);</b>
<b class="fc">&nbsp;			if (res == 0)</b>
<b class="fc">&nbsp;				return cur;</b>
<b class="fc">&nbsp;			else if (res &lt; 0)</b>
<b class="fc">&nbsp;				cur = getLeft(cur);</b>
&nbsp;			else
<b class="fc">&nbsp;				cur = getRight(cur);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="nc">&nbsp;		m_comparator.onEndSearchImpl_(data);</b>
<b class="nc">&nbsp;		return nullNode();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Find a first node in the treap which is less or equal the moniker.
&nbsp;	// Returns closest smaller (Comparator::compare returns -1) or any equal.
&nbsp;	public int searchLowerBound(MonikerComparator moniker, int treap) {
<b class="fc">&nbsp;		int cur = getRoot(treap);</b>
<b class="fc">&nbsp;		int bound = -1;</b>
<b class="fc">&nbsp;		while (cur != nullNode()) {</b>
<b class="fc">&nbsp;			int res = moniker.compare(this, cur);</b>
<b class="fc">&nbsp;			if (res == 0)</b>
<b class="nc">&nbsp;				return cur;</b>
<b class="fc">&nbsp;			else if (res &lt; 0)</b>
<b class="fc">&nbsp;				cur = getLeft(cur);</b>
&nbsp;			else {
<b class="fc">&nbsp;				bound = cur;</b>
<b class="fc">&nbsp;				cur = getRight(cur);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return bound;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Find a first node in the treap which is greater or equal the moniker.
&nbsp;	// Returns closest greater (Comparator::compare returns 1) or any equal.
&nbsp;	public int searchUpperBound(MonikerComparator moniker, int treap) {
<b class="fc">&nbsp;		int cur = getRoot(treap);</b>
<b class="fc">&nbsp;		int bound = -1;</b>
<b class="fc">&nbsp;		while (cur != nullNode()) {</b>
<b class="fc">&nbsp;			int res = moniker.compare(this, cur);</b>
<b class="fc">&nbsp;			if (res == 0)</b>
<b class="fc">&nbsp;				return cur;</b>
<b class="fc">&nbsp;			else if (res &lt; 0) {</b>
<b class="fc">&nbsp;				bound = cur;</b>
<b class="fc">&nbsp;				cur = getLeft(cur);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				cur = getRight(cur);</b>
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return bound;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns treap node data (element) from the given node index.
&nbsp;	public int getElement(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 3);// no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	// Returns treap node for the left node for the given treap node index
&nbsp;	public int getLeft(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 0);// no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	// Returns treap index for the right node for the given treap node index
&nbsp;	public int getRight(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 1);// no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	// Returns treap index for the parent node for the given treap node index
&nbsp;	public int getParent(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 2);// no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	// Returns next treap index. Allows to navigate Treap in the sorted order
&nbsp;	public int getNext(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 6);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns prev treap index. Allows to navigate Treap in the sorted order
&nbsp;	// backwards
&nbsp;	public int getPrev(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 5);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the first element in the treap (least one). Used together with
&nbsp;	// get_next to write a loop
&nbsp;	public int getFirst(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return getFirst_(m_defaultTreap);</b>
&nbsp;
<b class="fc">&nbsp;		return getFirst_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the last element in the treap (greatest one). Used together with
&nbsp;	// get_prev to write a loop
&nbsp;	public int getLast(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return getLast_(m_defaultTreap);</b>
&nbsp;
<b class="fc">&nbsp;		return getLast_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Gets the treap data associated with the treap.
&nbsp;	public int getTreapData(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="nc">&nbsp;			return getTreapData_(m_defaultTreap);</b>
&nbsp;
<b class="fc">&nbsp;		return getTreapData_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Change the element value. Note: do not call this method if setting the
&nbsp;	// element will change the sorted order.
&nbsp;	public void setElement(int treap_node_index, int newElement) {
<b class="fc">&nbsp;		if (m_comparator != null)</b>
<b class="fc">&nbsp;			m_comparator.onSetImpl_(this, treap_node_index);</b>
<b class="fc">&nbsp;		setElement_(treap_node_index, newElement);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the root of the treap.
&nbsp;	public int getRoot(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return getRoot_(m_defaultTreap);</b>
&nbsp;
<b class="fc">&nbsp;		return getRoot_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Check if the node is Null (does not exist).
&nbsp;	public static int nullNode() {
<b class="fc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Clears all nodes
&nbsp;	public void clear() {
<b class="fc">&nbsp;		m_treapData.deleteAll(false);</b>
<b class="fc">&nbsp;		m_defaultTreap = nullNode();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Total number of nodes
&nbsp;	public int size(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return getSize_(m_defaultTreap);</b>
&nbsp;
<b class="fc">&nbsp;		return getSize_(treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the maximum depth of this Treap at given moment
&nbsp;	public int getMaxDepth(int treap) {
<b class="nc">&nbsp;		return getMaxDepthHelper_(getRoot(treap));</b>
&nbsp;	}
&nbsp;
&nbsp;	public int getStateFlag() {
<b class="nc">&nbsp;		m_touchFlag &amp;= 0x7FFFFFFF;</b>
<b class="nc">&nbsp;		return m_touchFlag;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int m_defaultTreap;
&nbsp;	private int m_random;
&nbsp;	private Treap.Comparator m_comparator;// comparator used to arrange the
&nbsp;											// nodes
&nbsp;	private StridedIndexTypeCollection m_treapData; // m_left (0), m_right (1),
&nbsp;													// m_parent (2), m_element
&nbsp;													// (3), m_priority (4),
&nbsp;													// m_prev (5), m_next (6)
&nbsp;													// (optional: m_root (0),
&nbsp;													// m_first (1), m_last (2),
&nbsp;													// m_duplicate_element (3),
&nbsp;													// m_treap_size (4),
&nbsp;													// m_treapData (5))
&nbsp;	private int m_touchFlag;
&nbsp;	private boolean m_b_balancing;
&nbsp;
&nbsp;	private void touch_() {
<b class="fc">&nbsp;		if (m_touchFlag &gt;= 0) {</b>
<b class="fc">&nbsp;			m_touchFlag += 0x80000001;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int getPriority_(int treap_node_index) {
<b class="fc">&nbsp;		return m_treapData.getField(treap_node_index, 4);// no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	private void bubbleDown_(int treap_node_index) {
<b class="fc">&nbsp;		int left = getLeft(treap_node_index);</b>
<b class="fc">&nbsp;		int right = getRight(treap_node_index);</b>
<b class="fc">&nbsp;		int priority = getPriority_(treap_node_index);</b>
<b class="fc">&nbsp;		while (left != nullNode() || right != nullNode()) {</b>
<b class="fc">&nbsp;			int lcprior = left != nullNode() ? getPriority_(left) : NumberUtils</b>
<b class="fc">&nbsp;					.intMax();</b>
<b class="fc">&nbsp;			int rcprior = right != nullNode() ? getPriority_(right)</b>
<b class="fc">&nbsp;					: NumberUtils.intMax();</b>
<b class="fc">&nbsp;			int minprior = Math.min(lcprior, rcprior);</b>
&nbsp;
<b class="fc">&nbsp;			if (priority &lt;= minprior)</b>
&nbsp;				return;
&nbsp;
<b class="fc">&nbsp;			if (lcprior &lt;= rcprior)</b>
<b class="fc">&nbsp;				rotateRight_(left);</b>
&nbsp;			else
<b class="fc">&nbsp;				rotateLeft_(treap_node_index);</b>
&nbsp;
<b class="fc">&nbsp;			left = getLeft(treap_node_index);</b>
<b class="fc">&nbsp;			right = getRight(treap_node_index);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	private void bubbleUp_(int node) {
<b class="fc">&nbsp;		if (!m_b_balancing)</b>
&nbsp;			return;
<b class="fc">&nbsp;		int priority = getPriority_(node);</b>
<b class="fc">&nbsp;		int parent = getParent(node);</b>
<b class="fc">&nbsp;		while (parent != nullNode() &amp;&amp; getPriority_(parent) &gt; priority) {</b>
<b class="fc">&nbsp;			if (getLeft(parent) == node)</b>
<b class="fc">&nbsp;				rotateRight_(node);</b>
&nbsp;			else
<b class="fc">&nbsp;				rotateLeft_(parent);</b>
&nbsp;
<b class="fc">&nbsp;			parent = getParent(node);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void rotateLeft_(int treap_node_index) {
<b class="fc">&nbsp;		int px = treap_node_index;</b>
<b class="fc">&nbsp;		int py = getRight(treap_node_index);</b>
&nbsp;		int ptemp;
<b class="fc">&nbsp;		setParent_(py, getParent(px));</b>
<b class="fc">&nbsp;		setParent_(px, py);</b>
&nbsp;
<b class="fc">&nbsp;		ptemp = getLeft(py);</b>
<b class="fc">&nbsp;		setRight_(px, ptemp);</b>
&nbsp;
<b class="fc">&nbsp;		if (ptemp != nullNode())</b>
<b class="fc">&nbsp;			setParent_(ptemp, px);</b>
&nbsp;
<b class="fc">&nbsp;		setLeft_(py, px);</b>
&nbsp;
<b class="fc">&nbsp;		ptemp = getParent(py);</b>
<b class="fc">&nbsp;		if (ptemp != nullNode()) {</b>
<b class="fc">&nbsp;			if (getLeft(ptemp) == px)</b>
<b class="fc">&nbsp;				setLeft_(ptemp, py);</b>
&nbsp;			else {
<b class="fc">&nbsp;				assert (getRight(ptemp) == px);</b>
<b class="fc">&nbsp;				setRight_(ptemp, py);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void rotateRight_(int treap_node_index) {
<b class="fc">&nbsp;		int py = getParent(treap_node_index);</b>
<b class="fc">&nbsp;		int px = treap_node_index;</b>
&nbsp;		int ptemp;
&nbsp;
<b class="fc">&nbsp;		setParent_(px, getParent(py));</b>
<b class="fc">&nbsp;		setParent_(py, px);</b>
&nbsp;
<b class="fc">&nbsp;		ptemp = getRight(px);</b>
<b class="fc">&nbsp;		setLeft_(py, ptemp);</b>
&nbsp;
<b class="fc">&nbsp;		if (ptemp != nullNode())</b>
<b class="fc">&nbsp;			setParent_(ptemp, py);</b>
&nbsp;
<b class="fc">&nbsp;		setRight_(px, py);</b>
&nbsp;
<b class="fc">&nbsp;		ptemp = getParent(px);</b>
<b class="fc">&nbsp;		if (ptemp != nullNode()) {</b>
<b class="fc">&nbsp;			if (getLeft(ptemp) == py)</b>
<b class="fc">&nbsp;				setLeft_(ptemp, px);</b>
&nbsp;			else {
<b class="fc">&nbsp;				assert (getRight(ptemp) == py);</b>
<b class="fc">&nbsp;				setRight_(ptemp, px);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private void setParent_(int treap_node_index, int new_parent) {
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 2, new_parent); // no error</b>
&nbsp;																// checking here
&nbsp;	}
&nbsp;
&nbsp;	private void setLeft_(int treap_node_index, int new_left) {
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 0, new_left); // no error</b>
&nbsp;																// checking here
&nbsp;	}
&nbsp;
&nbsp;	private void setRight_(int treap_node_index, int new_right) {
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 1, new_right); // no error</b>
&nbsp;																// checking here
&nbsp;	}
&nbsp;
&nbsp;	private void setPriority_(int treap_node_index, int new_priority) {
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 4, new_priority); // no error</b>
&nbsp;																	// checking
&nbsp;																	// here
&nbsp;	}
&nbsp;
&nbsp;	private void setPrev_(int treap_node_index, int prev) {
<b class="fc">&nbsp;		assert (prev != treap_node_index);</b>
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 5, prev); // no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	private void setNext_(int treap_node_index, int next) {
<b class="fc">&nbsp;		assert (next != treap_node_index);</b>
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 6, next); // no error checking</b>
&nbsp;															// here
&nbsp;	}
&nbsp;
&nbsp;	private void setRoot_(int root, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 0, root);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setFirst_(int first, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 1, first);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setLast_(int last, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 2, last);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setDuplicateElement_(int duplicate_element, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 3, duplicate_element);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setSize_(int size, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 4, size);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setTreapData_(int treap_data, int treap) {
<b class="fc">&nbsp;		m_treapData.setField(treap, 5, treap_data);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getRoot_(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return nullNode();</b>
&nbsp;
<b class="fc">&nbsp;		return m_treapData.getField(treap, 0);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getFirst_(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="nc">&nbsp;			return nullNode();</b>
&nbsp;
<b class="fc">&nbsp;		return m_treapData.getField(treap, 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getLast_(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="nc">&nbsp;			return nullNode();</b>
&nbsp;
<b class="fc">&nbsp;		return m_treapData.getField(treap, 2);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getDuplicateElement_(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="nc">&nbsp;			return nullNode();</b>
&nbsp;
<b class="fc">&nbsp;		return m_treapData.getField(treap, 3);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getSize_(int treap) {
<b class="fc">&nbsp;		if (treap == -1)</b>
<b class="fc">&nbsp;			return 0;</b>
&nbsp;
<b class="fc">&nbsp;		return m_treapData.getField(treap, 4);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getTreapData_(int treap) {
<b class="fc">&nbsp;		return m_treapData.getField(treap, 5);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int newNode_(int element) {
<b class="fc">&nbsp;		touch_();</b>
<b class="fc">&nbsp;		int newNode = m_treapData.newElement();</b>
<b class="fc">&nbsp;		setPriority_(newNode, generatePriority_());</b>
<b class="fc">&nbsp;		setElement_(newNode, element);</b>
<b class="fc">&nbsp;		return newNode;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void freeNode_(int treap_node_index, int treap) {
<b class="fc">&nbsp;		if (treap_node_index == nullNode())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		m_treapData.deleteElement(treap_node_index);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int generatePriority_() {
<b class="fc">&nbsp;		m_random = NumberUtils.nextRand(m_random);</b>
<b class="fc">&nbsp;		return m_random &amp; (NumberUtils.intMax() &gt;&gt; 1);</b>
&nbsp;	}
&nbsp;
&nbsp;	private int getMaxDepthHelper_(int node) {
<b class="nc">&nbsp;		if (node == nullNode())</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;
<b class="nc">&nbsp;		return 1 + Math.max(getMaxDepthHelper_(getLeft(node)),</b>
<b class="nc">&nbsp;				getMaxDepthHelper_(getRight(node)));</b>
&nbsp;	}
&nbsp;
&nbsp;	private int addElement_(int element, int kind, int treap) {
&nbsp;		// dbg_check_(m_root);
<b class="fc">&nbsp;		if (getRoot_(treap) == nullNode()) {</b>
<b class="fc">&nbsp;			int newNode = newNode_(element);</b>
<b class="fc">&nbsp;			setRoot_(newNode, treap);</b>
<b class="fc">&nbsp;			addToList_(-1, newNode, treap);</b>
<b class="fc">&nbsp;			return newNode;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int cur = getRoot_(treap);</b>
<b class="fc">&nbsp;		int newNode = -1;</b>
<b class="fc">&nbsp;		int before = -1;</b>
&nbsp;
&nbsp;		for (;;) {
<b class="fc">&nbsp;			int cmp = kind == -1 ? 1 : m_comparator.compare(this, element, cur);</b>
<b class="fc">&nbsp;			if (cmp &lt; 0) {</b>
<b class="fc">&nbsp;				int left = getLeft(cur);</b>
<b class="fc">&nbsp;				if (left != nullNode())</b>
<b class="fc">&nbsp;					cur = left;</b>
&nbsp;				else {
<b class="fc">&nbsp;					before = cur;</b>
<b class="fc">&nbsp;					newNode = newNode_(element);</b>
<b class="fc">&nbsp;					setLeft_(cur, newNode);</b>
<b class="fc">&nbsp;					setParent_(newNode, cur);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
<b class="fc">&nbsp;			} else {</b>
<b class="fc">&nbsp;				if (kind == 1 &amp;&amp; cmp == 0) {</b>
<b class="fc">&nbsp;					m_comparator.onAddUniqueElementFailedImpl_(element);</b>
<b class="fc">&nbsp;					setDuplicateElement_(cur, treap);</b>
<b class="fc">&nbsp;					return -1;// return negative value.</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				int right = getRight(cur);</b>
<b class="fc">&nbsp;				if (right != nullNode())</b>
<b class="fc">&nbsp;					cur = right;</b>
&nbsp;				else {
<b class="fc">&nbsp;					before = getNext(cur);</b>
<b class="fc">&nbsp;					newNode = newNode_(element);</b>
<b class="fc">&nbsp;					setRight_(cur, newNode);</b>
<b class="fc">&nbsp;					setParent_(newNode, cur);</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		bubbleUp_(newNode);</b>
<b class="fc">&nbsp;		if (getParent(newNode) == nullNode())</b>
<b class="fc">&nbsp;			setRoot_(newNode, treap);</b>
&nbsp;
<b class="fc">&nbsp;		addToList_(before, newNode, treap);</b>
&nbsp;		// dbg_check_(m_root);
<b class="fc">&nbsp;		return newNode;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void addToList_(int before, int node, int treap) {
<b class="fc">&nbsp;		assert (before != node);</b>
&nbsp;		int prev;
<b class="fc">&nbsp;		if (before != -1) {</b>
<b class="fc">&nbsp;			prev = getPrev(before);</b>
<b class="fc">&nbsp;			setPrev_(before, node);</b>
&nbsp;		} else
<b class="fc">&nbsp;			prev = getLast_(treap);</b>
&nbsp;
<b class="fc">&nbsp;		setPrev_(node, prev);</b>
<b class="fc">&nbsp;		if (prev != -1)</b>
<b class="fc">&nbsp;			setNext_(prev, node);</b>
<b class="fc">&nbsp;		setNext_(node, before);</b>
&nbsp;
<b class="fc">&nbsp;		if (before == getFirst_(treap)) {</b>
<b class="fc">&nbsp;			setFirst_(node, treap);</b>
&nbsp;		}
<b class="fc">&nbsp;		if (before == -1) {</b>
<b class="fc">&nbsp;			setLast_(node, treap);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		setSize_(getSize_(treap) + 1, treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void removeFromList_(int node, int treap) {
<b class="fc">&nbsp;		int prev = getPrev(node);</b>
<b class="fc">&nbsp;		int next = getNext(node);</b>
<b class="fc">&nbsp;		if (prev != -1)</b>
<b class="fc">&nbsp;			setNext_(prev, next);</b>
&nbsp;		else
<b class="fc">&nbsp;			setFirst_(next, treap);</b>
&nbsp;
<b class="fc">&nbsp;		if (next != -1)</b>
<b class="fc">&nbsp;			setPrev_(next, prev);</b>
&nbsp;		else
<b class="fc">&nbsp;			setLast_(prev, treap);</b>
&nbsp;
<b class="fc">&nbsp;		setSize_(getSize_(treap) - 1, treap);</b>
&nbsp;	}
&nbsp;
&nbsp;	private void unbalancedDelete_(int treap_node_index, int treap) {
<b class="fc">&nbsp;		assert (!m_b_balancing);</b>
&nbsp;		// dbg_check_(m_root);
<b class="fc">&nbsp;		removeFromList_(treap_node_index, treap);</b>
<b class="fc">&nbsp;		int left = getLeft(treap_node_index);</b>
<b class="fc">&nbsp;		int right = getRight(treap_node_index);</b>
<b class="fc">&nbsp;		int parent = getParent(treap_node_index);</b>
<b class="fc">&nbsp;		int x = treap_node_index;</b>
<b class="fc">&nbsp;		if (left != -1 &amp;&amp; right != -1) {</b>
<b class="fc">&nbsp;			m_random = NumberUtils.nextRand(m_random);</b>
&nbsp;			int R;
<b class="fc">&nbsp;			if (m_random &gt; (NumberUtils.intMax() &gt;&gt; 1))</b>
<b class="fc">&nbsp;				R = getNext(treap_node_index);</b>
&nbsp;			else
<b class="fc">&nbsp;				R = getPrev(treap_node_index);</b>
&nbsp;
<b class="fc">&nbsp;			assert (R != -1);// cannot be NULL becaus the node has left and</b>
&nbsp;								// right
&nbsp;
<b class="fc">&nbsp;			boolean bFixMe = getParent(R) == treap_node_index;</b>
&nbsp;
&nbsp;			// swap left, right, and parent
<b class="fc">&nbsp;			m_treapData.swapField(treap_node_index, R, 0);</b>
<b class="fc">&nbsp;			m_treapData.swapField(treap_node_index, R, 1);</b>
<b class="fc">&nbsp;			m_treapData.swapField(treap_node_index, R, 2);</b>
&nbsp;
<b class="fc">&nbsp;			if (parent != -1) {</b>
&nbsp;				// Connect ex-parent of int to R.
<b class="fc">&nbsp;				if (getLeft(parent) == treap_node_index) {</b>
<b class="fc">&nbsp;					setLeft_(parent, R);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					assert (getRight(parent) == treap_node_index);</b>
<b class="fc">&nbsp;					setRight_(parent, R);</b>
&nbsp;				}
&nbsp;			} else {// int was the root. Make R the Root.
<b class="fc">&nbsp;				setRoot_(R, treap);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (bFixMe) {// R was a child of int</b>
<b class="fc">&nbsp;				if (left == R) {</b>
<b class="fc">&nbsp;					setLeft_(R, treap_node_index);</b>
<b class="fc">&nbsp;					setParent_(right, R);</b>
<b class="fc">&nbsp;				} else if (right == R) {</b>
<b class="fc">&nbsp;					setRight_(R, treap_node_index);</b>
<b class="fc">&nbsp;					setParent_(left, R);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				setParent_(treap_node_index, R);</b>
<b class="fc">&nbsp;				parent = R;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				setParent_(left, R);</b>
<b class="fc">&nbsp;				setParent_(right, R);</b>
<b class="fc">&nbsp;				parent = getParent(treap_node_index);</b>
<b class="fc">&nbsp;				x = R;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			assert (parent != -1);</b>
<b class="fc">&nbsp;			left = getLeft(treap_node_index);</b>
<b class="fc">&nbsp;			right = getRight(treap_node_index);</b>
<b class="fc">&nbsp;			if (left != -1)</b>
<b class="fc">&nbsp;				setParent_(left, treap_node_index);</b>
<b class="fc">&nbsp;			if (right != -1)</b>
<b class="fc">&nbsp;				setParent_(right, treap_node_index);</b>
&nbsp;
<b class="fc">&nbsp;			assert (left == -1 || right == -1);</b>
&nbsp;		}
&nbsp;
&nbsp;		// At most one child is not NULL.
<b class="fc">&nbsp;		int child = left != -1 ? left : right;</b>
&nbsp;
<b class="fc">&nbsp;		if (parent == -1) {</b>
<b class="fc">&nbsp;			setRoot_(child, treap);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			if (getLeft(parent) == x) {</b>
<b class="fc">&nbsp;				setLeft_(parent, child);</b>
&nbsp;			} else {
<b class="fc">&nbsp;				assert (getRight(parent) == x);</b>
<b class="fc">&nbsp;				setRight_(parent, child);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (child != -1)</b>
<b class="fc">&nbsp;			setParent_(child, parent);</b>
&nbsp;
<b class="fc">&nbsp;		freeNode_(treap_node_index, treap);</b>
&nbsp;		// dbg_check_(m_root);
&nbsp;	}
&nbsp;
&nbsp;	private void deleteNode_(int treap_node_index, int treap) {
<b class="fc">&nbsp;		assert (m_b_balancing);</b>
<b class="fc">&nbsp;		setPriority_(treap_node_index, NumberUtils.intMax()); // set the node</b>
&nbsp;																// priority high
<b class="fc">&nbsp;		int prl = nullNode();</b>
<b class="fc">&nbsp;		int prr = nullNode();</b>
<b class="fc">&nbsp;		int root = getRoot_(treap);</b>
<b class="fc">&nbsp;		boolean isroot = (root == treap_node_index);</b>
&nbsp;
<b class="fc">&nbsp;		if (isroot) {</b>
&nbsp;			// remember children of the root node, if the root node is to be
&nbsp;			// deleted
<b class="fc">&nbsp;			prl = getLeft(root);</b>
<b class="fc">&nbsp;			prr = getRight(root);</b>
&nbsp;
<b class="fc">&nbsp;			if (prl == nullNode() &amp;&amp; prr == nullNode()) {</b>
<b class="fc">&nbsp;				removeFromList_(root, treap);</b>
<b class="fc">&nbsp;				freeNode_(root, treap);</b>
<b class="fc">&nbsp;				setRoot_(nullNode(), treap);</b>
&nbsp;				return;
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		bubbleDown_(treap_node_index); // let the node to slide to the leaves of</b>
&nbsp;										// tree
&nbsp;
<b class="fc">&nbsp;		int p = getParent(treap_node_index);</b>
&nbsp;
<b class="fc">&nbsp;		if (p != nullNode()) {</b>
<b class="fc">&nbsp;			if (getLeft(p) == treap_node_index)</b>
<b class="fc">&nbsp;				setLeft_(p, nullNode());</b>
&nbsp;			else
<b class="fc">&nbsp;				setRight_(p, nullNode());</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		removeFromList_(treap_node_index, treap);</b>
<b class="fc">&nbsp;		freeNode_(treap_node_index, treap);</b>
&nbsp;
<b class="fc">&nbsp;		if (isroot) // if the root node is deleted, assign new root</b>
<b class="fc">&nbsp;			setRoot_((prl == nullNode() || getParent(prl) != nullNode()) ? prr</b>
<b class="fc">&nbsp;					: prl, treap);</b>
&nbsp;
<b class="fc">&nbsp;		assert (getParent(getRoot(treap)) == nullNode());</b>
&nbsp;	}
&nbsp;
&nbsp;	private void setElement_(int treap_node_index, int newElement) {
<b class="fc">&nbsp;		touch_();</b>
<b class="fc">&nbsp;		m_treapData.setField(treap_node_index, 3, newElement);// no error</b>
&nbsp;																// checking here
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
