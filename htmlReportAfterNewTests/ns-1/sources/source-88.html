


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > OperatorImportFromJsonCursor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: OperatorImportFromJsonCursor (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OperatorImportFromJsonCursor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (6/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,3%
  </span>
  <span class="absValue">
    (274/329)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2017 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.MultiVertexGeometryImpl.DirtyFlags;
&nbsp;import com.esri.core.geometry.VertexDescription.Semantics;
&nbsp;
<b class="fc">&nbsp;class OperatorImportFromJsonCursor extends MapGeometryCursor {</b>
&nbsp;	JsonReaderCursor m_inputJsonParsers;
&nbsp;
&nbsp;	int m_type;
&nbsp;
&nbsp;	int m_index;
&nbsp;
<b class="nc">&nbsp;	public OperatorImportFromJsonCursor(int type, JsonReaderCursor jsonParsers) {</b>
<b class="nc">&nbsp;		m_index = -1;</b>
<b class="nc">&nbsp;		if (jsonParsers == null)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		m_type = type;</b>
<b class="nc">&nbsp;		m_inputJsonParsers = jsonParsers;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getGeometryID() {
<b class="nc">&nbsp;		return m_index;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public MapGeometry next() {
&nbsp;		JsonReader jsonParser;
<b class="nc">&nbsp;		if ((jsonParser = m_inputJsonParsers.next()) != null) {</b>
<b class="nc">&nbsp;			m_index = m_inputJsonParsers.getID();</b>
<b class="nc">&nbsp;			return importFromJsonParser(m_type, jsonParser);</b>
&nbsp;		}
<b class="nc">&nbsp;		return null;</b>
&nbsp;	}
&nbsp;
&nbsp;	static MapGeometry importFromJsonParser(int gt, JsonReader parser) {
&nbsp;		MapGeometry mp;
&nbsp;
&nbsp;		try {
<b class="fc">&nbsp;			if (!JSONUtils.isObjectStart(parser))</b>
<b class="nc">&nbsp;				return null;</b>
&nbsp;
<b class="fc">&nbsp;			boolean bFoundSpatial_reference = false;</b>
<b class="fc">&nbsp;			boolean bFoundHasZ = false;</b>
<b class="fc">&nbsp;			boolean bFoundHasM = false;</b>
<b class="fc">&nbsp;			boolean bFoundPolygon = false;</b>
<b class="fc">&nbsp;			boolean bFoundPolyline = false;</b>
<b class="fc">&nbsp;			boolean bFoundMultiPoint = false;</b>
<b class="fc">&nbsp;			boolean bFoundX = false;</b>
<b class="fc">&nbsp;			boolean bFoundY = false;</b>
<b class="fc">&nbsp;			boolean bFoundZ = false;</b>
<b class="fc">&nbsp;			boolean bFoundM = false;</b>
<b class="fc">&nbsp;			boolean bFoundXMin = false;</b>
<b class="fc">&nbsp;			boolean bFoundYMin = false;</b>
<b class="fc">&nbsp;			boolean bFoundXMax = false;</b>
<b class="fc">&nbsp;			boolean bFoundYMax = false;</b>
<b class="fc">&nbsp;			boolean bFoundZMin = false;</b>
<b class="fc">&nbsp;			boolean bFoundZMax = false;</b>
<b class="fc">&nbsp;			boolean bFoundMMin = false;</b>
<b class="fc">&nbsp;			boolean bFoundMMax = false;</b>
<b class="fc">&nbsp;			double x = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double y = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double z = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double m = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double xmin = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double ymin = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double xmax = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double ymax = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double zmin = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double zmax = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double mmin = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			double mmax = NumberUtils.NaN();</b>
<b class="fc">&nbsp;			boolean bHasZ = false;</b>
<b class="fc">&nbsp;			boolean bHasM = false;</b>
<b class="fc">&nbsp;			AttributeStreamOfDbl as = (AttributeStreamOfDbl) AttributeStreamBase</b>
<b class="fc">&nbsp;					.createDoubleStream(0);</b>
<b class="fc">&nbsp;			AttributeStreamOfDbl bs = (AttributeStreamOfDbl) AttributeStreamBase</b>
<b class="fc">&nbsp;					.createDoubleStream(0);</b>
&nbsp;
<b class="fc">&nbsp;			Geometry geometry = null;</b>
<b class="fc">&nbsp;			SpatialReference spatial_reference = null;</b>
&nbsp;
<b class="fc">&nbsp;			while (parser.nextToken() != JsonReader.Token.END_OBJECT) {</b>
<b class="fc">&nbsp;				String name = parser.currentString();</b>
<b class="fc">&nbsp;				parser.nextToken();</b>
&nbsp;
<b class="fc">&nbsp;				if (!bFoundSpatial_reference &amp;&amp; name.equals(&quot;spatialReference&quot;)) {</b>
<b class="fc">&nbsp;					bFoundSpatial_reference = true;</b>
&nbsp;
<b class="fc">&nbsp;					if (parser.currentToken() == JsonReader.Token.START_OBJECT) {</b>
<b class="fc">&nbsp;						spatial_reference = SpatialReference.fromJson(parser);</b>
&nbsp;					} else {
<b class="nc">&nbsp;						if (parser.currentToken() != JsonReader.Token.VALUE_NULL)</b>
<b class="nc">&nbsp;							throw new GeometryException(</b>
&nbsp;									&quot;failed to parse spatial reference: object or null is expected&quot;);
&nbsp;					}
<b class="fc">&nbsp;				} else if (!bFoundHasZ &amp;&amp; name.equals(&quot;hasZ&quot;)) {</b>
<b class="nc">&nbsp;					bFoundHasZ = true;</b>
<b class="nc">&nbsp;					bHasZ = (parser.currentToken() == JsonReader.Token.VALUE_TRUE);</b>
<b class="fc">&nbsp;				} else if (!bFoundHasM &amp;&amp; name.equals(&quot;hasM&quot;)) {</b>
<b class="nc">&nbsp;					bFoundHasM = true;</b>
<b class="nc">&nbsp;					bHasM = (parser.currentToken() == JsonReader.Token.VALUE_TRUE);</b>
<b class="fc">&nbsp;				} else if (!bFoundPolygon</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;rings&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Polygon)) {
<b class="fc">&nbsp;					bFoundPolygon = true;</b>
<b class="fc">&nbsp;					geometry = importFromJsonMultiPath(true, parser, as, bs);</b>
<b class="fc">&nbsp;					continue;</b>
<b class="fc">&nbsp;				} else if (!bFoundPolyline</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;paths&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Polyline)) {
<b class="fc">&nbsp;					bFoundPolyline = true;</b>
<b class="fc">&nbsp;					geometry = importFromJsonMultiPath(false, parser, as, bs);</b>
<b class="fc">&nbsp;					continue;</b>
<b class="fc">&nbsp;				} else if (!bFoundMultiPoint</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;points&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.MultiPoint)) {
<b class="fc">&nbsp;					bFoundMultiPoint = true;</b>
<b class="fc">&nbsp;					geometry = importFromJsonMultiPoint(parser, as, bs);</b>
<b class="fc">&nbsp;					continue;</b>
<b class="fc">&nbsp;				} else if (!bFoundX</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;x&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<b class="fc">&nbsp;					bFoundX = true;</b>
<b class="fc">&nbsp;					x = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundY</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;y&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<b class="fc">&nbsp;					bFoundY = true;</b>
<b class="fc">&nbsp;					y = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundZ</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;z&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<b class="fc">&nbsp;					bFoundZ = true;</b>
<b class="fc">&nbsp;					z = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundM</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;m&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Point)) {
<b class="nc">&nbsp;					bFoundM = true;</b>
<b class="nc">&nbsp;					m = readDouble(parser);</b>
&nbsp;				}
<b class="fc">&nbsp;				if (!bFoundXMin</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;xmin&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="fc">&nbsp;					bFoundXMin = true;</b>
<b class="fc">&nbsp;					xmin = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundYMin</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;ymin&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="fc">&nbsp;					bFoundYMin = true;</b>
<b class="fc">&nbsp;					ymin = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundMMin</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;mmin&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="nc">&nbsp;					bFoundMMin = true;</b>
<b class="nc">&nbsp;					mmin = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundZMin</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;zmin&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="nc">&nbsp;					bFoundZMin = true;</b>
<b class="nc">&nbsp;					zmin = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundXMax</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;xmax&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="fc">&nbsp;					bFoundXMax = true;</b>
<b class="fc">&nbsp;					xmax = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundYMax</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;ymax&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="fc">&nbsp;					bFoundYMax = true;</b>
<b class="fc">&nbsp;					ymax = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundMMax</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;mmax&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="nc">&nbsp;					bFoundMMax = true;</b>
<b class="nc">&nbsp;					mmax = readDouble(parser);</b>
<b class="fc">&nbsp;				} else if (!bFoundZMax</b>
<b class="fc">&nbsp;						&amp;&amp; name.equals(&quot;zmax&quot;)</b>
&nbsp;						&amp;&amp; (gt == Geometry.GeometryType.Unknown || gt == Geometry.GeometryType.Envelope)) {
<b class="nc">&nbsp;					bFoundZMax = true;</b>
<b class="nc">&nbsp;					zmax = readDouble(parser);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					windup(parser);</b>
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="fc">&nbsp;			if (bFoundPolygon || bFoundPolyline || bFoundMultiPoint) {</b>
<b class="fc">&nbsp;				assert (geometry != null);</b>
<b class="fc">&nbsp;				MultiVertexGeometryImpl mvImpl = (MultiVertexGeometryImpl) geometry</b>
<b class="fc">&nbsp;						._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;				AttributeStreamBase zs = null;</b>
<b class="fc">&nbsp;				AttributeStreamBase ms = null;</b>
&nbsp;
<b class="fc">&nbsp;				if (bHasZ) {</b>
<b class="nc">&nbsp;					geometry.addAttribute(Semantics.Z);</b>
<b class="nc">&nbsp;					zs = as;</b>
&nbsp;				}
<b class="fc">&nbsp;				if (bHasM) {</b>
<b class="nc">&nbsp;					geometry.addAttribute(Semantics.M);</b>
<b class="nc">&nbsp;					ms = !bHasZ ? as : bs;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (bHasZ &amp;&amp; zs != null) {</b>
<b class="nc">&nbsp;					mvImpl.setAttributeStreamRef(Semantics.Z, zs);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (bHasM &amp;&amp; ms != null) {</b>
<b class="nc">&nbsp;					mvImpl.setAttributeStreamRef(Semantics.M, ms);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				mvImpl.notifyModified(DirtyFlags.DirtyAll);</b>
<b class="fc">&nbsp;			} else if (bFoundX || bFoundY || bFoundY || bFoundZ) {</b>
<b class="fc">&nbsp;				if (NumberUtils.isNaN(y))</b>
<b class="fc">&nbsp;					x = NumberUtils.NaN();</b>
&nbsp;
<b class="fc">&nbsp;				Point p = new Point(x, y);</b>
&nbsp;
<b class="fc">&nbsp;				if (bFoundZ)</b>
<b class="fc">&nbsp;					p.setZ(z);</b>
&nbsp;
<b class="fc">&nbsp;				if (bFoundM)</b>
<b class="nc">&nbsp;					p.setM(m);</b>
&nbsp;
<b class="fc">&nbsp;				geometry = p;</b>
<b class="fc">&nbsp;			} else if (bFoundXMin || bFoundYMin || bFoundXMax || bFoundYMax</b>
&nbsp;					|| bFoundZMin || bFoundZMax || bFoundMMin || bFoundMMax) {
<b class="fc">&nbsp;				if (NumberUtils.isNaN(ymin) || NumberUtils.isNaN(xmax)</b>
<b class="fc">&nbsp;						|| NumberUtils.isNaN(ymax))</b>
<b class="fc">&nbsp;					xmin = NumberUtils.NaN();</b>
&nbsp;
<b class="fc">&nbsp;				Envelope e = new Envelope(xmin, ymin, xmax, ymax);</b>
&nbsp;
<b class="fc">&nbsp;				if (bFoundZMin &amp;&amp; bFoundZMax)</b>
<b class="nc">&nbsp;					e.setInterval(Semantics.Z, 0, zmin, zmax);</b>
&nbsp;
<b class="fc">&nbsp;				if (bFoundMMin &amp;&amp; bFoundMMax)</b>
<b class="nc">&nbsp;					e.setInterval(Semantics.M, 0, mmin, mmax);</b>
&nbsp;
<b class="fc">&nbsp;				geometry = e;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			mp = new MapGeometry(geometry, spatial_reference);</b>
&nbsp;
<b class="nc">&nbsp;		} catch (Exception e) {</b>
<b class="nc">&nbsp;			return null;</b>
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		return mp;</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToUnknown(JsonReader parser)
&nbsp;			throws Exception {
&nbsp;
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.Unknown, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToEnvelope(JsonReader parser)
&nbsp;			throws Exception {
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.Envelope, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToPoint(JsonReader parser)
&nbsp;			throws Exception {
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.Point, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToPolygon(JsonReader parser)
&nbsp;			throws Exception {
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.Polygon, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToPolyline(JsonReader parser)
&nbsp;			throws Exception {
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.Polyline, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	public static MapGeometry fromJsonToMultiPoint(JsonReader parser)
&nbsp;			throws Exception {
<b class="nc">&nbsp;		return importFromJsonParser(Geometry.GeometryType.MultiPoint, parser);</b>
&nbsp;	}
&nbsp;
&nbsp;	private static void windup(JsonReader parser) {
<b class="fc">&nbsp;		parser.skipChildren();</b>
&nbsp;	}
&nbsp;
&nbsp;	private static double readDouble(JsonReader parser) {
<b class="fc">&nbsp;		if (parser.currentToken() == JsonReader.Token.VALUE_NULL</b>
<b class="fc">&nbsp;				|| parser.currentToken() == JsonReader.Token.VALUE_STRING</b>
<b class="nc">&nbsp;				&amp;&amp; parser.currentString().equals(&quot;NaN&quot;))</b>
<b class="fc">&nbsp;			return NumberUtils.NaN();</b>
&nbsp;		else
<b class="fc">&nbsp;			return parser.currentDoubleValue();</b>
&nbsp;	}
&nbsp;
&nbsp;	private static Geometry importFromJsonMultiPoint(JsonReader parser,
&nbsp;			AttributeStreamOfDbl as, AttributeStreamOfDbl bs) throws Exception {
<b class="fc">&nbsp;		if (parser.currentToken() != JsonReader.Token.START_ARRAY)</b>
<b class="nc">&nbsp;			throw new GeometryException(</b>
&nbsp;					&quot;failed to parse multipoint: array of vertices is expected&quot;);
&nbsp;
<b class="fc">&nbsp;		int point_count = 0;</b>
&nbsp;		MultiPoint multipoint;
&nbsp;
<b class="fc">&nbsp;		multipoint = new MultiPoint();</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfDbl position = (AttributeStreamOfDbl) (AttributeStreamBase</b>
<b class="fc">&nbsp;				.createDoubleStream(2, 0));</b>
&nbsp;
&nbsp;		// At start of rings
&nbsp;		int sz;
<b class="fc">&nbsp;		double[] buf = new double[4];</b>
<b class="fc">&nbsp;		while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</b>
<b class="fc">&nbsp;			if (parser.currentToken() != JsonReader.Token.START_ARRAY)</b>
<b class="nc">&nbsp;				throw new GeometryException(</b>
&nbsp;						&quot;failed to parse multipoint: array is expected, multipoint vertices consist of arrays of cooridinates&quot;);
&nbsp;
<b class="fc">&nbsp;			sz = 0;</b>
<b class="fc">&nbsp;			while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</b>
<b class="fc">&nbsp;				buf[sz++] = readDouble(parser);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (sz &lt; 2)</b>
<b class="nc">&nbsp;				throw new GeometryException(</b>
&nbsp;						&quot;failed to parse multipoint: each vertex array has to have at least 2 elements&quot;);
&nbsp;
<b class="fc">&nbsp;			if (position.size() == 2 * point_count) {</b>
<b class="fc">&nbsp;				int c = point_count * 3;</b>
<b class="fc">&nbsp;				if (c % 2 != 0)</b>
<b class="fc">&nbsp;					c++;// have to be even</b>
<b class="fc">&nbsp;				position.resize(c);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			position.write(2 * point_count, buf[0]);</b>
<b class="fc">&nbsp;			position.write(2 * point_count + 1, buf[1]);</b>
&nbsp;
<b class="fc">&nbsp;			if (as.size() == point_count) {</b>
<b class="fc">&nbsp;				int c = (point_count * 3) / 2;</b>
<b class="fc">&nbsp;				if (c &lt; 4)</b>
<b class="fc">&nbsp;					c = 4;</b>
<b class="fc">&nbsp;				else if (c &lt; 16)</b>
<b class="fc">&nbsp;					c = 16;</b>
&nbsp;
<b class="fc">&nbsp;				as.resize(c);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (sz &gt; 2) {</b>
<b class="fc">&nbsp;				as.write(point_count, buf[2]);</b>
&nbsp;			} else
<b class="fc">&nbsp;				as.write(point_count, NumberUtils.NaN());</b>
&nbsp;
<b class="fc">&nbsp;			if (bs.size() == point_count) {</b>
<b class="fc">&nbsp;				int c = (point_count * 3) / 2;</b>
<b class="fc">&nbsp;				if (c &lt; 4)</b>
<b class="fc">&nbsp;					c = 4;</b>
<b class="fc">&nbsp;				else if (c &lt; 16)</b>
<b class="fc">&nbsp;					c = 16;</b>
&nbsp;
<b class="fc">&nbsp;				bs.resize(c);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (sz &gt; 3) {</b>
<b class="nc">&nbsp;				bs.write(point_count, buf[3]);</b>
&nbsp;			} else
<b class="fc">&nbsp;				bs.write(point_count, NumberUtils.NaN());</b>
&nbsp;
<b class="fc">&nbsp;			point_count++;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (point_count != 0) {</b>
<b class="fc">&nbsp;			MultiPointImpl mp_impl = (MultiPointImpl) multipoint._getImpl();</b>
<b class="fc">&nbsp;			mp_impl.resize(point_count);</b>
<b class="fc">&nbsp;			mp_impl.setAttributeStreamRef(Semantics.POSITION, position);</b>
&nbsp;		}
<b class="fc">&nbsp;		return multipoint;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static Geometry importFromJsonMultiPath(boolean b_polygon,
&nbsp;			JsonReader parser, AttributeStreamOfDbl as, AttributeStreamOfDbl bs)
&nbsp;			throws Exception {
<b class="fc">&nbsp;		if (parser.currentToken() != JsonReader.Token.START_ARRAY)</b>
<b class="nc">&nbsp;			throw new GeometryException(</b>
&nbsp;					&quot;failed to parse multipath: array of array of vertices is expected&quot;);
&nbsp;
&nbsp;		MultiPath multipath;
&nbsp;
<b class="fc">&nbsp;		if (b_polygon)</b>
<b class="fc">&nbsp;			multipath = new Polygon();</b>
&nbsp;		else
<b class="fc">&nbsp;			multipath = new Polyline();</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt32 parts = (AttributeStreamOfInt32) AttributeStreamBase</b>
<b class="fc">&nbsp;				.createIndexStream(0);</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl position = (AttributeStreamOfDbl) AttributeStreamBase</b>
<b class="fc">&nbsp;				.createDoubleStream(2, 0);</b>
<b class="fc">&nbsp;		AttributeStreamOfInt8 pathFlags = (AttributeStreamOfInt8) AttributeStreamBase</b>
<b class="fc">&nbsp;				.createByteStream(0);</b>
&nbsp;
&nbsp;		// set up min max variables
<b class="fc">&nbsp;		double[] buf = new double[4];</b>
<b class="fc">&nbsp;		double[] start = new double[4];</b>
&nbsp;
<b class="fc">&nbsp;		int point_count = 0;</b>
<b class="fc">&nbsp;		int path_count = 0;</b>
<b class="fc">&nbsp;		byte pathFlag = b_polygon ? (byte) PathFlags.enumClosed : 0;</b>
<b class="fc">&nbsp;		int requiredSize = b_polygon ? 3 : 2;</b>
&nbsp;
&nbsp;		// At start of rings
<b class="fc">&nbsp;		while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</b>
<b class="fc">&nbsp;			if (parser.currentToken() != JsonReader.Token.START_ARRAY)</b>
<b class="nc">&nbsp;				throw new GeometryException(</b>
&nbsp;						&quot;failed to parse multipath: ring/path array is expected&quot;);
&nbsp;
<b class="fc">&nbsp;			int pathPointCount = 0;</b>
<b class="fc">&nbsp;			boolean b_first = true;</b>
<b class="fc">&nbsp;			int sz = 0;</b>
<b class="fc">&nbsp;			int szstart = 0;</b>
&nbsp;
<b class="fc">&nbsp;			parser.nextToken();</b>
<b class="fc">&nbsp;			while (parser.currentToken() != JsonReader.Token.END_ARRAY) {</b>
<b class="fc">&nbsp;				if (parser.currentToken() != JsonReader.Token.START_ARRAY)</b>
<b class="nc">&nbsp;					throw new GeometryException(</b>
&nbsp;							&quot;failed to parse multipath: array is expected, rings/paths vertices consist of arrays of cooridinates&quot;);
&nbsp;
<b class="fc">&nbsp;				sz = 0;</b>
<b class="fc">&nbsp;				while (parser.nextToken() != JsonReader.Token.END_ARRAY) {</b>
<b class="fc">&nbsp;					buf[sz++] = readDouble(parser);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (sz &lt; 2)</b>
<b class="nc">&nbsp;					throw new GeometryException(</b>
&nbsp;							&quot;failed to parse multipath: each vertex array has to have at least 2 elements&quot;);
&nbsp;
<b class="fc">&nbsp;				parser.nextToken();</b>
&nbsp;
&nbsp;				do {
<b class="fc">&nbsp;					if (position.size() == point_count * 2) {</b>
<b class="fc">&nbsp;						int c = point_count * 3;</b>
&nbsp;
<b class="fc">&nbsp;						if (c % 2 != 0)</b>
<b class="fc">&nbsp;							c++;// have to be even</b>
<b class="fc">&nbsp;						if (c &lt; 8)</b>
<b class="fc">&nbsp;							c = 8;</b>
<b class="fc">&nbsp;						else if (c &lt; 32)</b>
<b class="fc">&nbsp;							c = 32;</b>
&nbsp;
<b class="fc">&nbsp;						position.resize(c);</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					position.write(2 * point_count, buf[0]);</b>
<b class="fc">&nbsp;					position.write(2 * point_count + 1, buf[1]);</b>
&nbsp;
<b class="fc">&nbsp;					if (as.size() == point_count) {</b>
<b class="fc">&nbsp;						int c = (point_count * 3) / 2;// have to be even</b>
<b class="fc">&nbsp;						if (c &lt; 4)</b>
<b class="fc">&nbsp;							c = 4;</b>
<b class="fc">&nbsp;						else if (c &lt; 16)</b>
<b class="fc">&nbsp;							c = 16;</b>
<b class="fc">&nbsp;						as.resize(c);</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if (sz &gt; 2) {</b>
<b class="fc">&nbsp;						as.write(point_count, buf[2]);</b>
&nbsp;					} else
<b class="fc">&nbsp;						as.write(point_count, NumberUtils.NaN());</b>
&nbsp;
<b class="fc">&nbsp;					if (bs.size() == point_count) {</b>
<b class="fc">&nbsp;						int c = (point_count * 3) / 2;// have to be even</b>
<b class="fc">&nbsp;						if (c &lt; 4)</b>
<b class="fc">&nbsp;							c = 4;</b>
<b class="fc">&nbsp;						else if (c &lt; 16)</b>
<b class="fc">&nbsp;							c = 16;</b>
<b class="fc">&nbsp;						bs.resize(c);</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if (sz &gt; 3) {</b>
<b class="fc">&nbsp;						bs.write(point_count, buf[3]);</b>
&nbsp;					} else
<b class="fc">&nbsp;						bs.write(point_count, NumberUtils.NaN());</b>
&nbsp;
<b class="fc">&nbsp;					if (b_first) {</b>
<b class="fc">&nbsp;						path_count++;</b>
<b class="fc">&nbsp;						parts.add(point_count);</b>
<b class="fc">&nbsp;						pathFlags.add(pathFlag);</b>
<b class="fc">&nbsp;						b_first = false;</b>
<b class="fc">&nbsp;						szstart = sz;</b>
<b class="fc">&nbsp;						start[0] = buf[0];</b>
<b class="fc">&nbsp;						start[1] = buf[1];</b>
<b class="fc">&nbsp;						start[2] = buf[2];</b>
<b class="fc">&nbsp;						start[3] = buf[3];</b>
&nbsp;					}
<b class="fc">&nbsp;					point_count++;</b>
<b class="fc">&nbsp;					pathPointCount++;</b>
<b class="fc">&nbsp;				} while (pathPointCount &lt; requiredSize</b>
<b class="fc">&nbsp;						&amp;&amp; parser.currentToken() == JsonReader.Token.END_ARRAY);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (b_polygon &amp;&amp; pathPointCount &gt; requiredSize &amp;&amp; sz == szstart</b>
&nbsp;					&amp;&amp; start[0] == buf[0] &amp;&amp; start[1] == buf[1]
&nbsp;					&amp;&amp; start[2] == buf[2] &amp;&amp; start[3] == buf[3]) {
&nbsp;				// remove the end point that is equal to the start point.
<b class="fc">&nbsp;				point_count--;</b>
<b class="fc">&nbsp;				pathPointCount--;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (pathPointCount == 0)</b>
<b class="nc">&nbsp;				continue;// skip empty paths</b>
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		if (point_count != 0) {</b>
<b class="fc">&nbsp;			parts.resize(path_count);</b>
<b class="fc">&nbsp;			pathFlags.resize(path_count);</b>
&nbsp;
<b class="fc">&nbsp;			if (point_count &gt; 0) {</b>
<b class="fc">&nbsp;				parts.add(point_count);</b>
<b class="fc">&nbsp;				pathFlags.add((byte) 0);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			MultiPathImpl mp_impl = (MultiPathImpl) multipath._getImpl();</b>
<b class="fc">&nbsp;			mp_impl.setAttributeStreamRef(Semantics.POSITION, position);</b>
<b class="fc">&nbsp;			mp_impl.setPathFlagsStreamRef(pathFlags);</b>
<b class="fc">&nbsp;			mp_impl.setPathStreamRef(parts);</b>
&nbsp;		}
<b class="fc">&nbsp;		return multipath;</b>
&nbsp;	}
&nbsp;
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
