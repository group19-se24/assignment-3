


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Envelope</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: Envelope (com.esri.core.geometry)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Envelope</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64,6%
  </span>
  <span class="absValue">
    (53/82)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54,2%
  </span>
  <span class="absValue">
    (217/400)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2018 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.VertexDescription.Semantics;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;
&nbsp;import static com.esri.core.geometry.SizeOf.SIZE_OF_ENVELOPE;
&nbsp;
&nbsp;/**
&nbsp; * An envelope is an axis-aligned rectangle.
&nbsp; */
<b class="fc">&nbsp;public class Envelope extends Geometry implements Serializable {</b>
&nbsp;	//We are using writeReplace instead.
&nbsp;	//private static final long serialVersionUID = 2L;
&nbsp;
<b class="fc">&nbsp;	Envelope2D m_envelope = new Envelope2D();</b>
&nbsp;
&nbsp;	double[] m_attributes;// use doubles to store everything
&nbsp;
&nbsp;	/**
&nbsp;	 * Creates an envelope by defining its center, width, and height.
&nbsp;	 * 
&nbsp;	 * @param center
&nbsp;	 *            The center point of the envelope.
&nbsp;	 * @param width
&nbsp;	 *            The width of the envelope.
&nbsp;	 * @param height
&nbsp;	 *            The height of the envelope.
&nbsp;	 */
<b class="fc">&nbsp;	public Envelope(Point center, double width, double height) {</b>
<b class="fc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="fc">&nbsp;		m_envelope.setEmpty();</b>
<b class="fc">&nbsp;		if (center.isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		_setFromPoint(center, width, height);</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	public Envelope(Envelope2D env2D) {</b>
<b class="fc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="fc">&nbsp;		m_envelope.setCoords(env2D);</b>
<b class="fc">&nbsp;		m_envelope.normalize();</b>
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	public Envelope(VertexDescription vd) {</b>
<b class="fc">&nbsp;		if (vd == null)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;		
<b class="fc">&nbsp;		m_description = vd;</b>
<b class="fc">&nbsp;		m_envelope.setEmpty();</b>
<b class="fc">&nbsp;		_ensureAttributes();</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	public Envelope(VertexDescription vd, Envelope2D env2D) {</b>
<b class="nc">&nbsp;		if (vd == null)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;		
<b class="nc">&nbsp;		m_description = vd;</b>
<b class="nc">&nbsp;		m_envelope.setCoords(env2D);</b>
<b class="nc">&nbsp;		m_envelope.normalize();</b>
<b class="nc">&nbsp;		_ensureAttributes();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructs an empty envelope.
&nbsp;	 */
<b class="fc">&nbsp;	public Envelope() {</b>
<b class="fc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="fc">&nbsp;		m_envelope.setEmpty();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructs an envelope that covers the given point. The coordinates of
&nbsp;	 * the point are used to set the extent of the envelope.
&nbsp;	 * 
&nbsp;	 * @param point The point that the envelope covers.
&nbsp;	 */
<b class="nc">&nbsp;	public Envelope(Point point) {</b>
<b class="nc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="nc">&nbsp;		m_envelope.setEmpty();</b>
<b class="nc">&nbsp;		if (point.isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="nc">&nbsp;		_setFromPoint(point);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Constructs an envelope with the specified X and Y extents.
&nbsp;	 * 
&nbsp;	 * @param xmin
&nbsp;	 *            The minimum x-coordinate of the envelope.
&nbsp;	 * @param ymin
&nbsp;	 *            The minimum y-coordinate of the envelope.
&nbsp;	 * @param xmax
&nbsp;	 *            The maximum x-coordinate of the envelope.
&nbsp;	 * @param ymax
&nbsp;	 *            The maximum y-coordinate of the envelope.
&nbsp;	 */
<b class="fc">&nbsp;	public Envelope(double xmin, double ymin, double xmax, double ymax) {</b>
<b class="fc">&nbsp;		m_description = VertexDescriptionDesignerImpl.getDefaultDescriptor2D();</b>
<b class="fc">&nbsp;		setCoords(xmin, ymin, xmax, ymax);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the 2-dimensional extents of the envelope.
&nbsp;	 * 
&nbsp;	 * @param xmin
&nbsp;	 *            The minimum x-coordinate of the envelope.
&nbsp;	 * @param ymin
&nbsp;	 *            The minimum y-coordinate of the envelope.
&nbsp;	 * @param xmax
&nbsp;	 *            The maximum x-coordinate of the envelope.
&nbsp;	 * @param ymax
&nbsp;	 *            The maximum y-coordinate of the envelope.
&nbsp;	 */
&nbsp;	public void setCoords(double xmin, double ymin, double xmax, double ymax) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.setCoords(xmin, ymin, xmax, ymax);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the envelope from the array of points. The result envelope is a
&nbsp;	 * bounding box of all the points in the array. If the array has zero
&nbsp;	 * length, the envelope will be empty.
&nbsp;	 * 
&nbsp;	 * @param points
&nbsp;	 *            The point array.
&nbsp;	 */
&nbsp;	void setCoords(Point[] points) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		setEmpty();</b>
<b class="nc">&nbsp;		for (int i = 0, n = points.length; i &lt; n; i++)</b>
<b class="nc">&nbsp;			merge(points[i]);</b>
&nbsp;	}
&nbsp;
&nbsp;	void setEnvelope2D(Envelope2D e2d) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		if (!e2d.isValid())</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		m_envelope.setCoords(e2d);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Removes all points from this geometry.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public void setEmpty() {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.setEmpty();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Indicates whether this envelope contains any points.
&nbsp;	 * 
&nbsp;	 * @return boolean Returns true if the envelope is empty.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public boolean isEmpty() {
<b class="fc">&nbsp;		return m_envelope.isEmpty();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The width of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The width of the envelope.
&nbsp;	 */
&nbsp;
&nbsp;	public double getWidth() {
<b class="fc">&nbsp;		return m_envelope.getWidth();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The height of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The height of the envelope.
&nbsp;	 */
&nbsp;	public double getHeight() {
<b class="fc">&nbsp;		return m_envelope.getHeight();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The x-coordinate of the center of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The x-coordinate of the center of the envelope.
&nbsp;	 */
&nbsp;	public double getCenterX() {
<b class="fc">&nbsp;		return m_envelope.getCenterX();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The y-coordinate of center of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The y-coordinate of center of the envelope.
&nbsp;	 */
&nbsp;	public double getCenterY() {
<b class="fc">&nbsp;		return m_envelope.getCenterY();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The x and y-coordinates of the center of the envelope.
&nbsp;	 * 
&nbsp;	 * @return A point whose x and y-coordinates are that of the center of the envelope.
&nbsp;	 */
&nbsp;	public Point2D getCenterXY() {
<b class="fc">&nbsp;		return m_envelope.getCenter();</b>
&nbsp;	}
&nbsp;
&nbsp;	public void getCenter(Point point_out) {
<b class="fc">&nbsp;		point_out.assignVertexDescription(m_description);</b>
<b class="fc">&nbsp;		if (isEmpty()) {</b>
<b class="fc">&nbsp;			point_out.setEmpty();</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int nattrib = m_description.getAttributeCount();</b>
<b class="fc">&nbsp;		for (int i = 1; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;			int semantics = m_description.getSemantics(i);</b>
<b class="nc">&nbsp;			int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int iord = 0; iord &lt; ncomp; iord++) {</b>
<b class="nc">&nbsp;				double v = 0.5 * (getAttributeAsDblImpl_(0, semantics, iord) + getAttributeAsDblImpl_(</b>
&nbsp;						1, semantics, iord));
<b class="nc">&nbsp;				point_out.setAttribute(semantics, iord, v);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		point_out.setXY(m_envelope.getCenter());</b>
&nbsp;	}
&nbsp;
&nbsp;	public void merge(Point2D pt) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.merge(pt);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Merges this envelope with the extent of the given envelope. If this
&nbsp;	 * envelope is empty, the coordinates of the given envelope 
&nbsp;	 * are assigned. If the given envelope is empty, this envelope is unchanged.
&nbsp;	 * 
&nbsp;	 * @param other
&nbsp;	 *            The envelope to merge.
&nbsp;	 */
&nbsp;	public void merge(Envelope other) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		if (other.isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		VertexDescription otherVD = other.m_description;</b>
<b class="fc">&nbsp;		if (otherVD != m_description)</b>
<b class="nc">&nbsp;			mergeVertexDescription(otherVD);</b>
<b class="fc">&nbsp;		m_envelope.merge(other.m_envelope);</b>
<b class="fc">&nbsp;		for (int iattrib = 1, nattrib = otherVD.getAttributeCount(); iattrib &lt; nattrib; iattrib++) {</b>
<b class="nc">&nbsp;			int semantics = otherVD.getSemantics(iattrib);</b>
<b class="nc">&nbsp;			int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int iord = 0; iord &lt; ncomps; iord++) {</b>
<b class="nc">&nbsp;				Envelope1D intervalOther = other.queryInterval(semantics, iord);</b>
<b class="nc">&nbsp;				Envelope1D interval = queryInterval(semantics, iord);</b>
<b class="nc">&nbsp;				interval.merge(intervalOther);</b>
<b class="nc">&nbsp;				setInterval(semantics, iord, interval);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Merges this envelope with the point. The boundary of the envelope is
&nbsp;	 * increased to include the point. If the envelope is empty, the coordinates
&nbsp;	 * of the point to merge are assigned. If the point is empty, the original
&nbsp;	 * envelope is unchanged.
&nbsp;	 * 
&nbsp;	 * @param point
&nbsp;	 *            The point to be merged.
&nbsp;	 */
&nbsp;	public void merge(Point point) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		if (point.isEmptyImpl())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		VertexDescription pointVD = point.m_description;</b>
<b class="fc">&nbsp;		if (m_description != pointVD)</b>
<b class="nc">&nbsp;			mergeVertexDescription(pointVD);</b>
&nbsp;
<b class="fc">&nbsp;		if (isEmpty()) {</b>
<b class="fc">&nbsp;			_setFromPoint(point);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		m_envelope.merge(point.getXY());</b>
<b class="fc">&nbsp;		for (int iattrib = 1, nattrib = pointVD.getAttributeCount(); iattrib &lt; nattrib; iattrib++) {</b>
<b class="nc">&nbsp;			int semantics = pointVD._getSemanticsImpl(iattrib);</b>
<b class="nc">&nbsp;			int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int iord = 0; iord &lt; ncomps; iord++) {</b>
<b class="nc">&nbsp;				double v = point.getAttributeAsDbl(semantics, iord);</b>
<b class="nc">&nbsp;				Envelope1D interval = queryInterval(semantics, iord);</b>
<b class="nc">&nbsp;				interval.merge(v);</b>
<b class="nc">&nbsp;				setInterval(semantics, iord, interval);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	void _setFromPoint(Point centerPoint, double width, double height) {
<b class="fc">&nbsp;		m_envelope.setCoords(centerPoint.getXY(), width, height);</b>
<b class="fc">&nbsp;		VertexDescription pointVD = centerPoint.m_description;</b>
<b class="fc">&nbsp;		for (int iattrib = 1, nattrib = pointVD.getAttributeCount(); iattrib &lt; nattrib; iattrib++) {</b>
<b class="nc">&nbsp;			int semantics = pointVD._getSemanticsImpl(iattrib);</b>
<b class="nc">&nbsp;			int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int iord = 0; iord &lt; ncomps; iord++) {</b>
<b class="nc">&nbsp;				double v = centerPoint.getAttributeAsDbl(semantics, iord);</b>
<b class="nc">&nbsp;				setInterval(semantics, iord, v, v);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	void _setFromPoint(Point centerPoint) {
<b class="fc">&nbsp;		mergeVertexDescription(centerPoint.getDescription());</b>
<b class="fc">&nbsp;		m_envelope.setCoords(centerPoint.getX(), centerPoint.getY());</b>
<b class="fc">&nbsp;		VertexDescription pointVD = centerPoint.m_description;</b>
<b class="fc">&nbsp;		for (int iattrib = 1, nattrib = pointVD.getAttributeCount(); iattrib &lt; nattrib; iattrib++) {</b>
<b class="fc">&nbsp;			int semantics = pointVD._getSemanticsImpl(iattrib);</b>
<b class="fc">&nbsp;			int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;			for (int iord = 0; iord &lt; ncomps; iord++) {</b>
<b class="fc">&nbsp;				double v = centerPoint.getAttributeAsDbl(semantics, iord);</b>
<b class="fc">&nbsp;				setInterval(semantics, iord, v, v);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void merge(Envelope2D other) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		m_envelope.merge(other);</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setInterval(int semantics, int ordinate, double vmin,
&nbsp;			double vmax) {
<b class="fc">&nbsp;		setInterval(semantics, ordinate, new Envelope1D(vmin, vmax));</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Re-aspects this envelope to fit within the specified width and height.
&nbsp;	 * 
&nbsp;	 * @param arWidth
&nbsp;	 *            The width within which to fit the envelope.
&nbsp;	 * @param arHeight
&nbsp;	 *            The height within which to fit the envelope.
&nbsp;	 */
&nbsp;	public void reaspect(double arWidth, double arHeight) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		m_envelope.reaspect(arWidth, arHeight);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Changes the dimensions of the envelope while preserving the center. New width
&nbsp;	 * is Width + 2 * dx, new height is Height + 2 * dy. If the result envelope
&nbsp;	 * width or height becomes negative, the envelope is set to be empty.
&nbsp;	 * 
&nbsp;	 * @param dx
&nbsp;	 *            The inflation along the x-axis.
&nbsp;	 * @param dy
&nbsp;	 *            The inflation along the y-axis.
&nbsp;	 */
&nbsp;	public void inflate(double dx, double dy) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.inflate(dx, dy);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void applyTransformation(Transformation2D transform) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		transform.transform(m_envelope);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	void applyTransformation(Transformation3D transform) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		if (!m_envelope.isEmpty()) {</b>
<b class="nc">&nbsp;			Envelope3D env = new Envelope3D();</b>
<b class="nc">&nbsp;			queryEnvelope3D(env);</b>
<b class="nc">&nbsp;			if (env.isEmptyZ())</b>
<b class="nc">&nbsp;				env.setEmpty(); // Z components is empty, the</b>
&nbsp;								// AffineTransformation3D makes the whole
&nbsp;								// envelope empty. Consider
&nbsp;			// throwing an assert instead.
&nbsp;			else
<b class="nc">&nbsp;				transform.transform(env);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void copyTo(Geometry dst) {
<b class="fc">&nbsp;		if (dst.getType() != getType())</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		Envelope envDst = (Envelope) dst;</b>
<b class="fc">&nbsp;		dst._touch();</b>
<b class="fc">&nbsp;		envDst.m_description = m_description;</b>
<b class="fc">&nbsp;		envDst.m_envelope.setCoords(m_envelope);</b>
<b class="fc">&nbsp;		envDst.m_attributes = null;</b>
<b class="fc">&nbsp;		if (m_attributes != null)</b>
&nbsp;		{
<b class="fc">&nbsp;			envDst._ensureAttributes();</b>
<b class="fc">&nbsp;			System.arraycopy(m_attributes, 0, envDst.m_attributes, 0,</b>
<b class="fc">&nbsp;					(m_description.getTotalComponentCount() - 2) * 2);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry createInstance() {
<b class="fc">&nbsp;		return new Envelope(m_description);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public double calculateArea2D() {
<b class="fc">&nbsp;		return m_envelope.getArea();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public double calculateLength2D() {
<b class="nc">&nbsp;		return m_envelope.getLength();</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry.Type getType() {
<b class="fc">&nbsp;		return Type.Envelope;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public int getDimension() {
<b class="fc">&nbsp;		return 2;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public long estimateMemorySize()
&nbsp;	{
<b class="fc">&nbsp;		return SIZE_OF_ENVELOPE + m_envelope.estimateMemorySize() + estimateMemorySize(m_attributes);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void queryEnvelope(Envelope env) {
<b class="fc">&nbsp;		copyTo(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void queryEnvelope2D(Envelope2D env) {
<b class="fc">&nbsp;		env.xmin = m_envelope.xmin;</b>
<b class="fc">&nbsp;		env.ymin = m_envelope.ymin;</b>
<b class="fc">&nbsp;		env.xmax = m_envelope.xmax;</b>
<b class="fc">&nbsp;		env.ymax = m_envelope.ymax;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	void queryEnvelope3D(Envelope3D env) {
<b class="nc">&nbsp;		env.xmin = m_envelope.xmin;</b>
<b class="nc">&nbsp;		env.ymin = m_envelope.ymin;</b>
<b class="nc">&nbsp;		env.xmax = m_envelope.xmax;</b>
<b class="nc">&nbsp;		env.ymax = m_envelope.ymax;</b>
<b class="nc">&nbsp;		env.setCoords(m_envelope.xmin, m_envelope.ymin,</b>
<b class="nc">&nbsp;				_getAttributeAsDbl(0, Semantics.Z, 0), m_envelope.xmax,</b>
<b class="nc">&nbsp;				m_envelope.ymax, _getAttributeAsDbl(1, Semantics.Z, 0));</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Envelope1D queryInterval(int semantics, int ordinate) {
<b class="fc">&nbsp;		Envelope1D env = new Envelope1D();</b>
<b class="fc">&nbsp;		env.setCoords(_getAttributeAsDbl(0, semantics, ordinate),</b>
<b class="fc">&nbsp;				_getAttributeAsDbl(1, semantics, ordinate));</b>
<b class="fc">&nbsp;		return env;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setInterval(int semantics, int ordinate, Envelope1D env) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		if (semantics == Semantics.POSITION) {</b>
<b class="nc">&nbsp;			if (ordinate == 0) {</b>
<b class="nc">&nbsp;				m_envelope.xmin = env.vmin;</b>
<b class="nc">&nbsp;				m_envelope.xmax = env.vmax;</b>
<b class="nc">&nbsp;			} else if (ordinate == 1) {</b>
<b class="nc">&nbsp;				m_envelope.ymin = env.vmin;</b>
<b class="nc">&nbsp;				m_envelope.ymax = env.vmax;</b>
&nbsp;			} else
<b class="nc">&nbsp;				throw new IndexOutOfBoundsException();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			_setAttributeAsDbl(0, semantics, ordinate, env.vmin);</b>
<b class="fc">&nbsp;			_setAttributeAsDbl(1, semantics, ordinate, env.vmax);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void queryCoordinates(Point2D[] dst) {
<b class="nc">&nbsp;		if (dst == null || dst.length &lt; 4 || m_envelope.isEmpty())</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		m_envelope.queryCorners(dst);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the point&#39;s coordinates to the coordinates of the envelope at the
&nbsp;	 * given corner.
&nbsp;	 * 
&nbsp;	 * @param index
&nbsp;	 *            The index of the envelope&#39;s corners from 0 to 3.
&nbsp;	 *            &lt;p&gt;
&nbsp;	 *            0 = lower left corner
&nbsp;	 *            &lt;p&gt;
&nbsp;	 *            1 = top-left corner
&nbsp;	 *            &lt;p&gt;
&nbsp;	 *            2 = top right corner
&nbsp;	 *            &lt;p&gt;
&nbsp;	 *            3 = bottom right corner
&nbsp;	 * @param ptDst
&nbsp;	 *            The point whose coordinates are used to set the envelope&#39;s
&nbsp;	 *            coordinate at a specified corner.
&nbsp;	 */
&nbsp;	public void queryCornerByVal(int index, Point ptDst) {
<b class="fc">&nbsp;		ptDst.assignVertexDescription(m_description);</b>
<b class="fc">&nbsp;		int nattrib = getDescription().getAttributeCount() - 1;</b>
<b class="fc">&nbsp;		switch (index) {</b>
&nbsp;		case 0: {
<b class="fc">&nbsp;			for (int i = 0; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;				int semantics = m_description.getSemantics(i);</b>
<b class="nc">&nbsp;				int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;				for (int iord = 0; iord &lt; ncomp; iord++)</b>
<b class="nc">&nbsp;					ptDst.setAttribute(semantics, iord,</b>
<b class="nc">&nbsp;							_getAttributeAsDbl(0, semantics, iord));</b>
&nbsp;			}
<b class="fc">&nbsp;			ptDst.setXY(m_envelope.xmin, m_envelope.ymin);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
&nbsp;		case 1: {
<b class="fc">&nbsp;			for (int i = 0; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;				int semantics = m_description.getSemantics(i);</b>
<b class="nc">&nbsp;				int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;				for (int iord = 0; iord &lt; ncomp; iord++)</b>
<b class="nc">&nbsp;					ptDst.setAttribute(semantics, iord,</b>
<b class="nc">&nbsp;							_getAttributeAsDbl(1, semantics, iord));</b>
&nbsp;			}
<b class="fc">&nbsp;			ptDst.setXY(m_envelope.xmin, m_envelope.ymax);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;		case 2: {
<b class="fc">&nbsp;			for (int i = 0; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;				int semantics = m_description.getSemantics(i);</b>
<b class="nc">&nbsp;				int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;				for (int iord = 0; iord &lt; ncomp; iord++)</b>
<b class="nc">&nbsp;					ptDst.setAttribute(semantics, iord,</b>
<b class="nc">&nbsp;							_getAttributeAsDbl(0, semantics, iord));</b>
&nbsp;			}
<b class="fc">&nbsp;			ptDst.setXY(m_envelope.xmax, m_envelope.ymax);</b>
&nbsp;
&nbsp;			return;
&nbsp;		}
&nbsp;		case 3: {
<b class="fc">&nbsp;			for (int i = 0; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;				int semantics = m_description.getSemantics(i);</b>
<b class="nc">&nbsp;				int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;				for (int iord = 0; iord &lt; ncomp; iord++)</b>
<b class="nc">&nbsp;					ptDst.setAttribute(semantics, iord,</b>
<b class="nc">&nbsp;							_getAttributeAsDbl(1, semantics, iord));</b>
&nbsp;			}
<b class="fc">&nbsp;			ptDst.setXY(m_envelope.xmax, m_envelope.ymin);</b>
&nbsp;			return;
&nbsp;		}
&nbsp;		default:
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public void queryCorner(int index, Point2D ptDst) {
<b class="fc">&nbsp;		Point2D p = m_envelope.queryCorner(index);</b>
<b class="fc">&nbsp;		ptDst.setCoords(p.x, p.y);</b>
&nbsp;	}
&nbsp;
&nbsp;	int getEndPointOffset(VertexDescription descr, int end_point) {
<b class="nc">&nbsp;		return end_point * (descr.getTotalComponentCount() - 2);</b>
&nbsp;	}
&nbsp;
&nbsp;	double getAttributeAsDblImpl_(int end_point, int semantics, int ordinate) {
<b class="nc">&nbsp;		if (m_envelope.isEmpty())</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;empty geometry&quot;);</b>
&nbsp;
<b class="nc">&nbsp;		assert (end_point == 0 || end_point == 1);</b>
&nbsp;
<b class="nc">&nbsp;		if (semantics == VertexDescription.Semantics.POSITION) {</b>
<b class="nc">&nbsp;			if (end_point != 0) {</b>
<b class="nc">&nbsp;				return ordinate != 0 ? m_envelope.ymax : m_envelope.xmax;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				return ordinate != 0 ? m_envelope.ymin : m_envelope.xmin;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		int attribute_index = m_description.getAttributeIndex(semantics);</b>
<b class="nc">&nbsp;		if (attribute_index &gt;= 0) {</b>
<b class="nc">&nbsp;			return m_attributes[getEndPointOffset(m_description, end_point)</b>
<b class="nc">&nbsp;					+ m_description.getPointAttributeOffset_(attribute_index)</b>
&nbsp;					- 2 + ordinate];
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return VertexDescription.getDefaultValue(semantics);</b>
&nbsp;	}
&nbsp;
&nbsp;	void setAttributeAsDblImpl_(int end_point, int semantics, int ordinate,
&nbsp;			double value) {
<b class="nc">&nbsp;		assert (end_point == 0 || end_point == 1);</b>
&nbsp;
<b class="nc">&nbsp;		if (semantics == VertexDescription.Semantics.POSITION) {</b>
<b class="nc">&nbsp;			if (end_point != 0) {</b>
<b class="nc">&nbsp;				if (ordinate != 0)</b>
<b class="nc">&nbsp;					m_envelope.ymax = value;</b>
&nbsp;				else
<b class="nc">&nbsp;					m_envelope.xmax = value;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				if (ordinate != 0)</b>
<b class="nc">&nbsp;					m_envelope.ymin = value;</b>
&nbsp;				else
<b class="nc">&nbsp;					m_envelope.xmin = value;</b>
&nbsp;			}
&nbsp;			
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		addAttribute(semantics);</b>
<b class="nc">&nbsp;		int attribute_index = m_description.getAttributeIndex(semantics);</b>
<b class="nc">&nbsp;		m_attributes[getEndPointOffset(m_description, end_point)</b>
<b class="nc">&nbsp;				+ m_description.getPointAttributeOffset_(attribute_index) - 2</b>
&nbsp;				+ ordinate] = value;
&nbsp;	}
&nbsp;
&nbsp;	void _ensureAttributes() {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		if (m_attributes == null &amp;&amp; m_description.getTotalComponentCount() &gt; 2) {</b>
<b class="fc">&nbsp;			int halfLength = m_description.getTotalComponentCount() - 2;</b>
<b class="fc">&nbsp;			m_attributes = new double[halfLength * 2];</b>
<b class="fc">&nbsp;			int offset0 = _getEndPointOffset(m_description, 0);</b>
<b class="fc">&nbsp;			int offset1 = _getEndPointOffset(m_description, 1);</b>
<b class="fc">&nbsp;			System.arraycopy(m_description._getDefaultPointAttributes(), 2, m_attributes, offset0, halfLength);</b>
<b class="fc">&nbsp;			System.arraycopy(m_description._getDefaultPointAttributes(), 2, m_attributes, offset1, halfLength);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void _assignVertexDescriptionImpl(VertexDescription newDescription) {
<b class="fc">&nbsp;		if (newDescription.getTotalComponentCount() &gt; 2) {</b>
<b class="fc">&nbsp;			int[] mapping = VertexDescriptionDesignerImpl.mapAttributes(newDescription, m_description);</b>
&nbsp;			
<b class="fc">&nbsp;			double[] newAttributes = new double[(newDescription.getTotalComponentCount() - 2) * 2];</b>
&nbsp;			
<b class="fc">&nbsp;			int old_offset0 = _getEndPointOffset(m_description, 0);</b>
<b class="fc">&nbsp;			int old_offset1 = _getEndPointOffset(m_description, 1);</b>
&nbsp;	
<b class="fc">&nbsp;			int new_offset0 = _getEndPointOffset(newDescription, 0);</b>
<b class="fc">&nbsp;			int new_offset1 = _getEndPointOffset(newDescription, 1);</b>
&nbsp;			
<b class="fc">&nbsp;			int j = 0;</b>
<b class="fc">&nbsp;			for (int i = 1, n = newDescription.getAttributeCount(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;				int semantics = newDescription.getSemantics(i);</b>
<b class="fc">&nbsp;				int nords = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;				if (mapping[i] == -1)</b>
&nbsp;				{
<b class="fc">&nbsp;					double d = VertexDescription.getDefaultValue(semantics);</b>
<b class="fc">&nbsp;					for (int ord = 0; ord &lt; nords; ord++)</b>
&nbsp;					{
<b class="fc">&nbsp;						newAttributes[new_offset0 + j] = d;</b>
<b class="fc">&nbsp;						newAttributes[new_offset1 + j] = d;</b>
<b class="fc">&nbsp;						j++;</b>
&nbsp;					}
<b class="fc">&nbsp;				}</b>
&nbsp;				else {
<b class="fc">&nbsp;					int m = mapping[i];</b>
<b class="fc">&nbsp;					int offset = m_description._getPointAttributeOffset(m) - 2;</b>
<b class="fc">&nbsp;					for (int ord = 0; ord &lt; nords; ord++)</b>
&nbsp;					{
<b class="fc">&nbsp;						newAttributes[new_offset0 + j] = m_attributes[old_offset0 + offset];</b>
<b class="fc">&nbsp;						newAttributes[new_offset1 + j] = m_attributes[old_offset1 + offset];</b>
<b class="fc">&nbsp;						j++;</b>
<b class="fc">&nbsp;						offset++;</b>
&nbsp;					}
&nbsp;				}
&nbsp;					 
&nbsp;			}
&nbsp;			
<b class="fc">&nbsp;			m_attributes = newAttributes;</b>
<b class="fc">&nbsp;		}</b>
&nbsp;		else {
<b class="nc">&nbsp;			m_attributes = null;</b>
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		m_description = newDescription;</b>
&nbsp;	}
&nbsp;
&nbsp;	double _getAttributeAsDbl(int endPoint, int semantics, int ordinate) {
<b class="fc">&nbsp;		if (m_envelope.isEmpty())</b>
<b class="nc">&nbsp;			throw new GeometryException(</b>
&nbsp;					&quot;This operation was performed on an Empty Geometry.&quot;);
&nbsp;
<b class="fc">&nbsp;		if (semantics == Semantics.POSITION) {</b>
<b class="fc">&nbsp;			if (endPoint != 0) {</b>
<b class="fc">&nbsp;				return ordinate != 0 ? m_envelope.ymax : m_envelope.xmax;</b>
&nbsp;			} else {
<b class="fc">&nbsp;				return ordinate != 0 ? m_envelope.ymin : m_envelope.xmin;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
<b class="fc">&nbsp;		if (attributeIndex &gt;= 0) {</b>
<b class="fc">&nbsp;			return m_attributes[_getEndPointOffset(m_description, endPoint)</b>
<b class="fc">&nbsp;					+ m_description._getPointAttributeOffset(attributeIndex)</b>
&nbsp;					- 2 + ordinate];
&nbsp;		} else
<b class="fc">&nbsp;			return VertexDescription.getDefaultValue(semantics);</b>
&nbsp;	}
&nbsp;
&nbsp;	void _setAttributeAsDbl(int endPoint, int semantics, int ordinate,
&nbsp;			double value) {
<b class="fc">&nbsp;		_touch();</b>
&nbsp;		// _ASSERT(endPoint == 0 || endPoint == 1);
&nbsp;
<b class="fc">&nbsp;		if (semantics == Semantics.POSITION) {</b>
<b class="nc">&nbsp;			if (endPoint != 0) {</b>
<b class="nc">&nbsp;				if (ordinate != 0)</b>
<b class="nc">&nbsp;					m_envelope.ymax = value;</b>
&nbsp;				else
<b class="nc">&nbsp;					m_envelope.xmax = value;</b>
&nbsp;			} else {
<b class="nc">&nbsp;				if (ordinate != 0)</b>
<b class="nc">&nbsp;					m_envelope.ymin = value;</b>
&nbsp;				else
<b class="nc">&nbsp;					m_envelope.xmin = value;</b>
&nbsp;			}
&nbsp;			
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		if (!hasAttribute(semantics)) {</b>
<b class="fc">&nbsp;			addAttribute(semantics);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
<b class="fc">&nbsp;		m_attributes[_getEndPointOffset(m_description, endPoint)</b>
<b class="fc">&nbsp;				+ m_description._getPointAttributeOffset(attributeIndex) - 2</b>
&nbsp;				+ ordinate] = value;
&nbsp;	}
&nbsp;
&nbsp;	int _getAttributeAsInt(int endPoint, int semantics, int ordinate) {
<b class="nc">&nbsp;		return (int) _getAttributeAsDbl(endPoint, semantics, ordinate);</b>
&nbsp;	}
&nbsp;
&nbsp;	static int _getEndPointOffset(VertexDescription vd, int endPoint) {
<b class="fc">&nbsp;		return endPoint * (vd.getTotalComponentCount() - 2);</b>
&nbsp;	}
&nbsp;
&nbsp;	public boolean isIntersecting(Envelope2D other) {
<b class="nc">&nbsp;		return m_envelope.isIntersecting(other);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Changes this envelope to be the intersection of itself with the other
&nbsp;	 * envelope.
&nbsp;	 * 
&nbsp;	 * @param other
&nbsp;	 *            The envelope to intersect.
&nbsp;	 * @return Returns true if the result is not empty.
&nbsp;	 */
&nbsp;	public boolean intersect(Envelope other) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		Envelope2D e2d = new Envelope2D();</b>
<b class="fc">&nbsp;		other.queryEnvelope2D(e2d);</b>
<b class="fc">&nbsp;		return m_envelope.intersect(e2d);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns true if the envelope and the other given envelope intersect.
&nbsp;	 * 
&nbsp;	 * @param other
&nbsp;	 *            The envelope to with which to test intersection.
&nbsp;	 * @return Returns true if the two envelopes intersect.
&nbsp;	 */
&nbsp;	public boolean isIntersecting(Envelope other) {// TODO: attributes.
<b class="nc">&nbsp;		return m_envelope.isIntersecting(other.m_envelope);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the envelope&#39;s corners to be centered around the specified point,
&nbsp;	 * using its center, width, and height.
&nbsp;	 * 
&nbsp;	 * @param c
&nbsp;	 *            The point around which to center the envelope.
&nbsp;	 * @param w
&nbsp;	 *            The width to be set for the envelope.
&nbsp;	 * @param h
&nbsp;	 *            The height to be set for this envelope.
&nbsp;	 */
&nbsp;	public void centerAt(Point c, double w, double h) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		if (c.isEmpty()) {</b>
<b class="nc">&nbsp;			setEmpty();</b>
&nbsp;			return;
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		_setFromPoint(c, w, h);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Offsets the envelope by the specified distances along x and y-coordinates.
&nbsp;	 * 
&nbsp;	 * @param dx
&nbsp;	 *            The X offset to be applied.
&nbsp;	 * @param dy
&nbsp;	 *            The Y offset to be applied.
&nbsp;	 */
&nbsp;	public void offset(double dx, double dy) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		m_envelope.offset(dx, dy);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Normalizes envelopes if the minimum dimension is larger than the
&nbsp;	 * maximum dimension.
&nbsp;	 */
&nbsp;	public void normalize() {// TODO: attributes
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		m_envelope.normalize();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Gets the center point of the envelope. The center point occurs at: ((XMin
&nbsp;	 * + XMax) / 2, (YMin + YMax) / 2).
&nbsp;	 * 
&nbsp;	 * @return The center point of the envelope.
&nbsp;	 */
&nbsp;	public Point2D getCenter2D() {
<b class="nc">&nbsp;		return m_envelope.getCenter();</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the center point of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The center point of the envelope.
&nbsp;	 */
&nbsp;	public Point getCenter() {
<b class="fc">&nbsp;		Point pointOut = new Point(m_description);</b>
<b class="fc">&nbsp;		if (isEmpty()) {</b>
<b class="nc">&nbsp;			return pointOut;</b>
&nbsp;		}
<b class="fc">&nbsp;		int nattrib = m_description.getAttributeCount();</b>
<b class="fc">&nbsp;		for (int i = 1; i &lt; nattrib; i++) {</b>
<b class="nc">&nbsp;			int semantics = m_description._getSemanticsImpl(i);</b>
<b class="nc">&nbsp;			int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int iord = 0; iord &lt; ncomp; iord++) {</b>
<b class="nc">&nbsp;				double v = 0.5 * (_getAttributeAsDbl(0, semantics, iord) + _getAttributeAsDbl(</b>
&nbsp;						1, semantics, iord));
<b class="nc">&nbsp;				pointOut.setAttribute(semantics, iord, v);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		pointOut.setXY(m_envelope.getCenterX(), m_envelope.getCenterY());</b>
<b class="fc">&nbsp;		return pointOut;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Centers the envelope around the specified point preserving the envelope&#39;s
&nbsp;	 * width and height.
&nbsp;	 * 
&nbsp;	 * @param c
&nbsp;	 *            The new center point.
&nbsp;	 */
&nbsp;	public void centerAt(Point c) {
<b class="nc">&nbsp;		_touch();</b>
<b class="nc">&nbsp;		if (c.isEmpty()) {</b>
<b class="nc">&nbsp;			setEmpty();</b>
&nbsp;			return;
&nbsp;		}
<b class="nc">&nbsp;		m_envelope.centerAt(c.getX(), c.getY());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the envelope&#39;s lower left corner point.
&nbsp;	 * 
&nbsp;	 * @return Returns the lower left corner point.
&nbsp;	 */
&nbsp;	public Point getLowerLeft() {
<b class="nc">&nbsp;		return new Point(m_envelope.getLowerLeft());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the envelope&#39;s upper right corner point.
&nbsp;	 * 
&nbsp;	 * @return Returns the upper right corner point.
&nbsp;	 */
&nbsp;	public Point getUpperRight() {
<b class="nc">&nbsp;		return new Point(m_envelope.getUpperRight());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the envelope&#39;s lower right corner point.
&nbsp;	 * 
&nbsp;	 * @return Returns the lower right corner point.
&nbsp;	 */
&nbsp;	public Point getLowerRight() {
<b class="nc">&nbsp;		return new Point(m_envelope.getLowerRight());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the envelope&#39;s upper left corner point.
&nbsp;	 * 
&nbsp;	 * @return Returns the upper left corner point.
&nbsp;	 */
&nbsp;	public Point getUpperLeft() {
<b class="nc">&nbsp;		return new Point(m_envelope.getUpperLeft());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if this envelope contains (covers) the specified point.
&nbsp;	 * 
&nbsp;	 * @param p
&nbsp;	 *            The Point to be tested for coverage.
&nbsp;	 * @return TRUE if this envelope contains (covers) the specified point.
&nbsp;	 */
&nbsp;	public boolean contains(Point p) {
<b class="nc">&nbsp;		if (p.isEmpty())</b>
<b class="nc">&nbsp;			return false;</b>
<b class="nc">&nbsp;		return m_envelope.contains(p.getX(), p.getY());</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if this envelope contains (covers) other envelope.
&nbsp;	 * 
&nbsp;	 * @param env
&nbsp;	 *            The envelope to be tested for coverage.
&nbsp;	 * @return TRUE if this envelope contains (covers) the specified envelope.
&nbsp;	 */
&nbsp;	public boolean contains(Envelope env) {
<b class="nc">&nbsp;		return m_envelope.contains(env.m_envelope);</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns TRUE when this geometry has exactly same type, properties, and
&nbsp;	 * coordinates as the other geometry.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public boolean equals(Object _other) {
<b class="fc">&nbsp;		if (_other == this)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (!(_other instanceof Envelope))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		Envelope other = (Envelope) _other;</b>
&nbsp;
<b class="fc">&nbsp;		if (m_description != other.m_description)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (isEmpty())</b>
<b class="nc">&nbsp;			if (other.isEmpty())</b>
<b class="nc">&nbsp;				return true;</b>
&nbsp;			else
<b class="nc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (!this.m_envelope.equals(other.m_envelope))</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0, n = (m_description.getTotalComponentCount() - 2) * 2; i &lt; n; i++)</b>
<b class="fc">&nbsp;			if (!NumberUtils.isEqualNonIEEE(m_attributes[i], other.m_attributes[i]))</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns a hash code value for this envelope.
&nbsp;	 * 
&nbsp;	 * @return A hash code value for this envelope.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="nc">&nbsp;		int hashCode = m_description.hashCode();</b>
<b class="nc">&nbsp;		hashCode = NumberUtils.hash(hashCode, m_envelope.hashCode());</b>
<b class="nc">&nbsp;		if (!isEmpty()) {</b>
<b class="nc">&nbsp;			for (int i = 0, n = (m_description.getTotalComponentCount() - 2) * 2; i &lt; n; i++) {</b>
<b class="nc">&nbsp;				hashCode = NumberUtils.hash(hashCode, m_attributes[i]);</b>
&nbsp;			}
&nbsp;		}
<b class="nc">&nbsp;		return hashCode;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the X coordinate of the left corners of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The X coordinate of the left corners.
&nbsp;	 */
&nbsp;	public final double getXMin() {
<b class="fc">&nbsp;		return m_envelope.xmin;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the Y coordinate of the bottom corners of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The Y coordinate of the bottom corners.
&nbsp;	 */
&nbsp;	public final double getYMin() {
<b class="fc">&nbsp;		return m_envelope.ymin;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the X coordinate of the right corners of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The X coordinate of the right corners.
&nbsp;	 */
&nbsp;	public final double getXMax() {
<b class="fc">&nbsp;		return m_envelope.xmax;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the Y coordinate of the top corners of the envelope.
&nbsp;	 * 
&nbsp;	 * @return The Y coordinate of the top corners.
&nbsp;	 */
&nbsp;	public final double getYMax() {
<b class="fc">&nbsp;		return m_envelope.ymax;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the left X coordinate.
&nbsp;	 * 
&nbsp;	 * @param x
&nbsp;	 *            The X coordinate of the left corner
&nbsp;	 */
&nbsp;	public void setXMin(double x) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.xmin = x;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the right X coordinate.
&nbsp;	 * 
&nbsp;	 * @param x
&nbsp;	 *            The X coordinate of the right corner.
&nbsp;	 */
&nbsp;	public void setXMax(double x) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.xmax = x;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the bottom Y coordinate.
&nbsp;	 * 
&nbsp;	 * @param y
&nbsp;	 *            the Y coordinate of the bottom corner.
&nbsp;	 */
&nbsp;	public void setYMin(double y) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.ymin = y;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets the top Y coordinate.
&nbsp;	 * 
&nbsp;	 * @param y
&nbsp;	 *            The Y coordinate of the top corner.
&nbsp;	 */
&nbsp;	public void setYMax(double y) {
<b class="fc">&nbsp;		_touch();</b>
<b class="fc">&nbsp;		m_envelope.ymax = y;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Geometry getBoundary() {
<b class="nc">&nbsp;		return Boundary.calculate(this, null);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void replaceNaNs(int semantics, double value) {
<b class="fc">&nbsp;		addAttribute(semantics);</b>
<b class="fc">&nbsp;		if (isEmpty())</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; ncomps; i++) {</b>
<b class="fc">&nbsp;			Envelope1D interval = queryInterval(semantics, i);</b>
<b class="fc">&nbsp;			if (interval.isEmpty()) {</b>
<b class="fc">&nbsp;				interval.vmin = value;</b>
<b class="fc">&nbsp;				interval.vmax = value;</b>
<b class="fc">&nbsp;				setInterval(semantics, i, interval);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * The output of this method can be only used for debugging. It is subject to change without notice. 
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="fc">&nbsp;		if (isEmpty())</b>
<b class="nc">&nbsp;			return &quot;Envelope: []&quot;;</b>
&nbsp;		
<b class="fc">&nbsp;		String s = &quot;Envelope: [&quot; + m_envelope.xmin + &quot;, &quot; + m_envelope.ymin + &quot;, &quot; + m_envelope.xmax + &quot;, &quot; + m_envelope.ymax +&quot;]&quot;; </b>
<b class="fc">&nbsp;		return s;</b>
&nbsp;	}
&nbsp;    
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:42</div>
</div>
</body>
</html>
