


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > OperatorSimplifyLocalHelper</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: OperatorSimplifyLocalHelper (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OperatorSimplifyLocalHelper</td>
<td class="coverageStat">
  <span class="percent">
    97,1%
  </span>
  <span class="absValue">
    (34/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86,3%
  </span>
  <span class="absValue">
    (908/1052)
  </span>
</td>
</tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$ClusterTestComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$Edge</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$EdgeComparerForSelfIntersection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$IndexSorter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$MultiPointVertexComparer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$MultiPointVertexComparer2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$RingOrientationTestComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96,2%
  </span>
  <span class="absValue">
    (25/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$Vertex_info</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$Vertex_info_pg</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$Vertex_info_pl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">OperatorSimplifyLocalHelper$VertexComparer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    94,9%
  </span>
  <span class="absValue">
    (56/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86,9%
  </span>
  <span class="absValue">
    (978/1125)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Comparator;
&nbsp;
&nbsp;import com.esri.core.geometry.MultiVertexGeometryImpl.GeometryXSimple;
&nbsp;
<b class="fc">&nbsp;class OperatorSimplifyLocalHelper {</b>
&nbsp;	private static final class Edge {
<b class="fc">&nbsp;		Edge() {</b>
<b class="fc">&nbsp;			m_flags = 0;</b>
&nbsp;			// m_segment.createInstance();
&nbsp;		}
&nbsp;
&nbsp;		Segment m_segment;
&nbsp;		int m_vertexIndex;
&nbsp;		int m_pathIndex;
&nbsp;		int m_flags;
&nbsp;
&nbsp;		void setReversed(boolean bYesNo) {
<b class="fc">&nbsp;			m_flags &amp;= (~1);</b>
<b class="fc">&nbsp;			m_flags = m_flags | (bYesNo ? 1 : 0);</b>
&nbsp;		}
&nbsp;
&nbsp;		// The value returned by GetReversed is interpreted differently in
&nbsp;		// checkSelfIntersections_ and checkValidRingOrientation_
&nbsp;		boolean getReversed() /* const */
&nbsp;		{
<b class="fc">&nbsp;			return (m_flags &amp; 1) != 0;</b>
&nbsp;		}
&nbsp;
&nbsp;		int getRightSide() /* const */
&nbsp;		{
<b class="fc">&nbsp;			return getReversed() ? 0 : 1; // 0 means there should be an</b>
&nbsp;											// emptiness on the right side of
&nbsp;											// the edge, 1 means there is
&nbsp;											// interior
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private final VertexDescription m_description;
&nbsp;	private Geometry m_geometry;
&nbsp;	private SpatialReferenceImpl m_sr;
&nbsp;	private int m_dbgCounter; // debugging counter(for breakpoints)
&nbsp;	private double m_toleranceIsSimple;
&nbsp;	private double m_toleranceSimplify;
&nbsp;	// private double m_toleranceCluster; //cluster tolerance needs to be
&nbsp;	// sqrt(2) times larger than the tolerance of the other simplify processes.
&nbsp;	private int m_knownSimpleResult;
&nbsp;	private int m_attributeCount;
&nbsp;
&nbsp;	private ArrayList&lt;Edge&gt; m_edges;
&nbsp;	private AttributeStreamOfInt32 m_FreeEdges;
&nbsp;	private ArrayList&lt;Edge&gt; m_lineEdgesRecycle;
&nbsp;	private AttributeStreamOfInt32 m_newEdges;
&nbsp;	private SegmentIteratorImpl m_recycledSegIter;
&nbsp;	private IndexMultiDCList m_crossOverHelperList;
&nbsp;	private AttributeStreamOfInt32 m_paths_for_OGC_tests;
&nbsp;
&nbsp;	private ProgressTracker m_progressTracker;
&nbsp;
&nbsp;	private Treap m_AET;
&nbsp;	private AttributeStreamOfInt32 m_xyToNode1; // for each vertex, contains -1,
&nbsp;												// or the edge node.
&nbsp;	private AttributeStreamOfInt32 m_xyToNode2; // for each vertex, contains -1,
&nbsp;												// or the edge node.
&nbsp;	private AttributeStreamOfInt32 m_pathOrientations; // 0 if undefined, -1 for
&nbsp;														// counterclockwise, 1
&nbsp;														// for clockwise.
&nbsp;	private AttributeStreamOfInt32 m_pathParentage;
&nbsp;	private int m_unknownOrientationPathCount;
&nbsp;	private double m_yScanline;
&nbsp;
&nbsp;	private AttributeStreamOfDbl m_xy;
&nbsp;	private AttributeStreamOfInt32 m_pairs;
&nbsp;	private AttributeStreamOfInt32 m_pairIndices;
&nbsp;
&nbsp;	private EditShape m_editShape;
&nbsp;	private boolean m_bOGCRestrictions;
&nbsp;	private boolean m_bPlanarSimplify;
&nbsp;
&nbsp;	private int isSimplePlanarImpl_() {
<b class="fc">&nbsp;		m_bPlanarSimplify = true;</b>
<b class="fc">&nbsp;		if (Geometry.isMultiPath(m_geometry.getType().value())) {</b>
<b class="fc">&nbsp;			if (!checkStructure_()) // check structure of geometry(no zero</b>
&nbsp;									// length paths, etc)
<b class="fc">&nbsp;				return 0;</b>
&nbsp;
<b class="fc">&nbsp;			if (!checkDegenerateSegments_(false)) // check for degenerate</b>
&nbsp;													// segments(only 2D,no zs or
&nbsp;													// other attributes)
<b class="fc">&nbsp;				return 0;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!checkClustering_()) // check clustering(points are either</b>
&nbsp;									// coincident,or further than tolerance)
<b class="fc">&nbsp;			return 0;</b>
&nbsp;
<b class="fc">&nbsp;		if (!Geometry.isMultiPath(m_geometry.getType().value()))</b>
<b class="fc">&nbsp;			return 2; // multipoint is simple</b>
&nbsp;
<b class="fc">&nbsp;		if (!checkCracking_()) // check that there are no self intersections and</b>
&nbsp;								// overlaps among segments.
<b class="fc">&nbsp;			return 0;</b>
&nbsp;
<b class="fc">&nbsp;		if (m_geometry.getType() == Geometry.Type.Polyline) {</b>
<b class="fc">&nbsp;			if (!checkSelfIntersectionsPolylinePlanar_())</b>
<b class="fc">&nbsp;				return 0;</b>
&nbsp;
<b class="fc">&nbsp;			return 2; // polyline is simple</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!checkSelfIntersections_()) // check that there are no other self</b>
&nbsp;										// intersections (for the cases of
&nbsp;										// several segments connect in a point)
<b class="fc">&nbsp;			return 0;</b>
&nbsp;
&nbsp;		// check that every hole is counterclockwise, and every exterior is
&nbsp;		// clockwise.
&nbsp;		// for the strong simple also check that exterior rings are followed by
&nbsp;		// the interior rings.
<b class="fc">&nbsp;		return checkValidRingOrientation_();</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean testToleranceDistance_(int xyindex1, int xyindex2) {
<b class="fc">&nbsp;		double x1 = m_xy.read(2 * xyindex1);</b>
<b class="fc">&nbsp;		double y1 = m_xy.read(2 * xyindex1 + 1);</b>
<b class="fc">&nbsp;		double x2 = m_xy.read(2 * xyindex2);</b>
<b class="fc">&nbsp;		double y2 = m_xy.read(2 * xyindex2 + 1);</b>
<b class="fc">&nbsp;		boolean b = !Clusterer.isClusterCandidate_(x1, y1, x2, y2,</b>
&nbsp;				m_toleranceIsSimple * m_toleranceIsSimple);
<b class="fc">&nbsp;		if (!b) {</b>
<b class="fc">&nbsp;			if (m_geometry.getDimension() == 0)</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;
<b class="fc">&nbsp;			return (x1 == x2 &amp;&amp; y1 == y2); // points either coincide or</b>
&nbsp;											// further,than the tolerance
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return b;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkStructure_() {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
<b class="fc">&nbsp;		int minsize = multiPathImpl.m_bPolygon ? 3 : 2;</b>
<b class="fc">&nbsp;		for (int ipath = 0, npath = multiPathImpl.getPathCount(); ipath &lt; npath; ipath++) {</b>
<b class="fc">&nbsp;			if (multiPathImpl.getPathSize(ipath) &lt; minsize) {</b>
<b class="fc">&nbsp;				m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;						NonSimpleResult.Reason.Structure, ipath, 0);
<b class="fc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkDegenerateSegments_(boolean bTestZs) {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIter = multiPathImpl.querySegmentIterator();</b>
&nbsp;		// Envelope2D env2D;
<b class="fc">&nbsp;		boolean bHasZ = multiPathImpl</b>
<b class="fc">&nbsp;				.hasAttribute(VertexDescription.Semantics.Z);</b>
<b class="fc">&nbsp;		double ztolerance = !bHasZ ? 0 : InternalUtils</b>
<b class="nc">&nbsp;				.calculateZToleranceFromGeometry(m_sr, multiPathImpl, false);</b>
<b class="fc">&nbsp;		while (segIter.nextPath()) {</b>
<b class="fc">&nbsp;			while (segIter.hasNextSegment()) {</b>
<b class="fc">&nbsp;				/* const */Segment seg = segIter.nextSegment();</b>
<b class="fc">&nbsp;				double length = seg.calculateLength2D();</b>
<b class="fc">&nbsp;				if (length &gt; m_toleranceIsSimple)</b>
<b class="fc">&nbsp;					continue;</b>
&nbsp;
<b class="fc">&nbsp;				if (bTestZs &amp;&amp; bHasZ) {</b>
<b class="nc">&nbsp;					double z0 = seg.getStartAttributeAsDbl(</b>
&nbsp;							VertexDescription.Semantics.Z, 0);
<b class="nc">&nbsp;					double z1 = seg.getStartAttributeAsDbl(</b>
&nbsp;							VertexDescription.Semantics.Z, 0);
<b class="nc">&nbsp;					if (Math.abs(z1 - z0) &gt; ztolerance)</b>
<b class="nc">&nbsp;						continue;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;						NonSimpleResult.Reason.DegenerateSegments,
<b class="fc">&nbsp;						segIter.getStartPointIndex(), -1);</b>
<b class="fc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkClustering_() {
<b class="fc">&nbsp;		MultiVertexGeometryImpl multiVertexImpl = (MultiVertexGeometryImpl) m_geometry</b>
<b class="fc">&nbsp;				._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = null;</b>
<b class="fc">&nbsp;		if (Geometry.isMultiPath(m_geometry.getType().value()))</b>
<b class="fc">&nbsp;			multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		boolean get_paths = (m_bPlanarSimplify || m_bOGCRestrictions)</b>
&nbsp;				&amp;&amp; multiPathImpl != null;
&nbsp;
<b class="fc">&nbsp;		int pointCount = multiVertexImpl.getPointCount();</b>
<b class="fc">&nbsp;		m_xy = (AttributeStreamOfDbl) multiVertexImpl</b>
<b class="fc">&nbsp;				.getAttributeStreamRef(VertexDescription.Semantics.POSITION);</b>
<b class="fc">&nbsp;		m_pairs = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		m_pairs.reserve(pointCount * 2);</b>
<b class="fc">&nbsp;		m_pairIndices = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		m_pairIndices.reserve(pointCount * 2);</b>
<b class="fc">&nbsp;		if (get_paths) {</b>
<b class="fc">&nbsp;			if (m_paths_for_OGC_tests == null)</b>
<b class="fc">&nbsp;				m_paths_for_OGC_tests = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;			m_paths_for_OGC_tests.reserve(pointCount);</b>
&nbsp;		}
<b class="fc">&nbsp;		int ipath = 0;</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			m_pairs.add(2 * i); // y - tol(BOTTOM)</b>
<b class="fc">&nbsp;			m_pairs.add(2 * i + 1); // y + tol(TOP)</b>
<b class="fc">&nbsp;			m_pairIndices.add(2 * i);</b>
<b class="fc">&nbsp;			m_pairIndices.add(2 * i + 1);</b>
<b class="fc">&nbsp;			if (get_paths) {</b>
<b class="fc">&nbsp;				while (i &gt;= multiPathImpl.getPathEnd(ipath))</b>
<b class="fc">&nbsp;					ipath++;</b>
&nbsp;
<b class="fc">&nbsp;				m_paths_for_OGC_tests.add(ipath);</b>
&nbsp;			}
&nbsp;
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		BucketSort sorter = new BucketSort();</b>
<b class="fc">&nbsp;		sorter.sort(m_pairIndices, 0, 2 * pointCount, new IndexSorter(this,</b>
&nbsp;				get_paths));
&nbsp;
<b class="fc">&nbsp;		m_AET.clear();</b>
<b class="fc">&nbsp;		m_AET.setComparator(new ClusterTestComparator(this));</b>
<b class="fc">&nbsp;		m_AET.setCapacity(pointCount);</b>
<b class="fc">&nbsp;		for (int index = 0, n = pointCount * 2; index &lt; n; index++) {</b>
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(index);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1; // k = 2n or 2n + 1 represent a vertical</b>
&nbsp;										// segment for the same vertex.
&nbsp;										// Therefore, k / 2 represents a vertex
&nbsp;										// index
&nbsp;			// Points need to be either exactly equal or further than 2 *
&nbsp;			// tolerance apart.
<b class="fc">&nbsp;			if ((pair &amp; 1) == 0) {// bottom element</b>
<b class="fc">&nbsp;				int aetNode = m_AET.addElement(xyindex, -1);</b>
&nbsp;				// add it to the AET,end test it against its left and right
&nbsp;				// neighbours.
<b class="fc">&nbsp;				int leftneighbour = m_AET.getPrev(aetNode);</b>
<b class="fc">&nbsp;				if (leftneighbour != Treap.nullNode()</b>
<b class="fc">&nbsp;						&amp;&amp; !testToleranceDistance_(</b>
<b class="fc">&nbsp;								m_AET.getElement(leftneighbour), xyindex)) {</b>
<b class="fc">&nbsp;					m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;							NonSimpleResult.Reason.Clustering, xyindex,
<b class="fc">&nbsp;							m_AET.getElement(leftneighbour));</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;				}
<b class="fc">&nbsp;				int rightneighbour = m_AET.getNext(aetNode);</b>
<b class="fc">&nbsp;				if (rightneighbour != Treap.nullNode()</b>
<b class="fc">&nbsp;						&amp;&amp; !testToleranceDistance_(</b>
<b class="fc">&nbsp;								m_AET.getElement(rightneighbour), xyindex)) {</b>
<b class="fc">&nbsp;					m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;							NonSimpleResult.Reason.Clustering, xyindex,
<b class="fc">&nbsp;							m_AET.getElement(rightneighbour));</b>
<b class="fc">&nbsp;					return false;</b>
&nbsp;				}
<b class="fc">&nbsp;			} else { // top</b>
&nbsp;						// get left and right neighbours, and remove the element
&nbsp;						// from AET. Then test the neighbours with the
&nbsp;						// tolerance.
<b class="fc">&nbsp;				int aetNode = m_AET.search(xyindex, -1);</b>
<b class="fc">&nbsp;				int leftneighbour = m_AET.getPrev(aetNode);</b>
<b class="fc">&nbsp;				int rightneighbour = m_AET.getNext(aetNode);</b>
<b class="fc">&nbsp;				m_AET.deleteNode(aetNode, -1);</b>
<b class="fc">&nbsp;				if (leftneighbour != Treap.nullNode()</b>
<b class="fc">&nbsp;						&amp;&amp; rightneighbour != Treap.nullNode()</b>
<b class="fc">&nbsp;						&amp;&amp; !testToleranceDistance_(</b>
<b class="fc">&nbsp;								m_AET.getElement(leftneighbour),</b>
<b class="fc">&nbsp;								m_AET.getElement(rightneighbour))) {</b>
<b class="nc">&nbsp;					m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;							NonSimpleResult.Reason.Clustering,
<b class="nc">&nbsp;							m_AET.getElement(leftneighbour),</b>
<b class="nc">&nbsp;							m_AET.getElement(rightneighbour));</b>
<b class="nc">&nbsp;					return false;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkCracking_() {
<b class="fc">&nbsp;		MultiVertexGeometryImpl multiVertexImpl = (MultiVertexGeometryImpl) m_geometry</b>
<b class="fc">&nbsp;				._getImpl();</b>
<b class="fc">&nbsp;		int pointCount = multiVertexImpl.getPointCount();</b>
<b class="fc">&nbsp;		if (pointCount &lt; 10)// use brute force for smaller polygons</b>
&nbsp;		{
<b class="fc">&nbsp;			return checkCrackingBrute_();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			return checkCrackingPlanesweep_();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkCrackingPlanesweep_() // cracker,that uses planesweep
&nbsp;												// algorithm.
&nbsp;	{
<b class="fc">&nbsp;		EditShape editShape = new EditShape();</b>
<b class="fc">&nbsp;		editShape.addGeometry(m_geometry);</b>
<b class="fc">&nbsp;		NonSimpleResult result = new NonSimpleResult();</b>
<b class="fc">&nbsp;		boolean bNonSimple = Cracker.needsCracking(false, editShape,</b>
&nbsp;				m_toleranceIsSimple, result, m_progressTracker);
<b class="fc">&nbsp;		if (bNonSimple) {</b>
<b class="fc">&nbsp;			result.m_vertexIndex1 = editShape</b>
<b class="fc">&nbsp;					.getVertexIndex(result.m_vertexIndex1);</b>
<b class="fc">&nbsp;			result.m_vertexIndex2 = editShape</b>
<b class="fc">&nbsp;					.getVertexIndex(result.m_vertexIndex2);</b>
<b class="fc">&nbsp;			m_nonSimpleResult.Assign(result);</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;		} else
<b class="fc">&nbsp;			return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkCrackingBrute_() // cracker, that uses brute force (a
&nbsp;											// double loop) to find segment
&nbsp;											// intersections.
&nbsp;	{
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
&nbsp;		// Implementation without a QuadTreeImpl accelerator
<b class="fc">&nbsp;		SegmentIteratorImpl segIter1 = multiPathImpl.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIter2 = multiPathImpl.querySegmentIterator();</b>
&nbsp;		// Envelope2D env2D;
<b class="fc">&nbsp;		while (segIter1.nextPath()) {</b>
<b class="fc">&nbsp;			while (segIter1.hasNextSegment()) {</b>
<b class="fc">&nbsp;				/* const */Segment seg1 = segIter1.nextSegment();</b>
<b class="fc">&nbsp;				if (!segIter1.isLastSegmentInPath() || !segIter1.isLastPath()) {</b>
<b class="fc">&nbsp;					segIter2.resetTo(segIter1);</b>
&nbsp;					do {
<b class="fc">&nbsp;						while (segIter2.hasNextSegment()) {</b>
<b class="fc">&nbsp;							/* const */Segment seg2 = segIter2.nextSegment();</b>
<b class="fc">&nbsp;							int res = seg1._isIntersecting(seg2,</b>
&nbsp;									m_toleranceIsSimple, true);
<b class="fc">&nbsp;							if (res != 0) {</b>
<b class="fc">&nbsp;								NonSimpleResult.Reason reason = res == 2 ? NonSimpleResult.Reason.CrossOver</b>
<b class="fc">&nbsp;										: NonSimpleResult.Reason.Cracking;</b>
<b class="fc">&nbsp;								m_nonSimpleResult = new NonSimpleResult(reason,</b>
<b class="fc">&nbsp;										segIter1.getStartPointIndex(),</b>
<b class="fc">&nbsp;										segIter2.getStartPointIndex());</b>
<b class="fc">&nbsp;								return false;</b>
&nbsp;							}
<b class="fc">&nbsp;						}</b>
<b class="fc">&nbsp;					} while (segIter2.nextPath());</b>
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;		}
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean checkSelfIntersections_() {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
<b class="fc">&nbsp;		m_edges.clear();</b>
<b class="fc">&nbsp;		m_edges.ensureCapacity(20);// we reuse the edges while going through a</b>
&nbsp;		// polygon.
<b class="fc">&nbsp;		m_lineEdgesRecycle.clear();</b>
<b class="fc">&nbsp;		m_lineEdgesRecycle.ensureCapacity(20);// we reuse the edges while going</b>
&nbsp;												// through a polygon.
&nbsp;
<b class="fc">&nbsp;		m_recycledSegIter = multiPathImpl.querySegmentIterator();</b>
<b class="fc">&nbsp;		m_recycledSegIter.setCirculator(true);</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt32 bunch = new AttributeStreamOfInt32(0);// stores</b>
&nbsp;																		// coincident
&nbsp;																		// vertices
<b class="fc">&nbsp;		bunch.reserve(10);</b>
<b class="fc">&nbsp;		int pointCount = multiPathImpl.getPointCount();</b>
<b class="fc">&nbsp;		double xprev = NumberUtils.TheNaN;</b>
<b class="fc">&nbsp;		double yprev = 0;</b>
&nbsp;		// We already have a sorted list of vertices from clustering check.
<b class="fc">&nbsp;		for (int index = 0, n = pointCount * 2; index &lt; n; index++) {</b>
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(index);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			if ((pair &amp; 1) != 0)</b>
<b class="fc">&nbsp;				continue; // m_pairs array is redundant. See checkClustering_.</b>
&nbsp;
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
&nbsp;
<b class="fc">&nbsp;			double x = m_xy.read(2 * xyindex);</b>
<b class="fc">&nbsp;			double y = m_xy.read(2 * xyindex + 1);</b>
<b class="fc">&nbsp;			if (bunch.size() != 0) {</b>
<b class="fc">&nbsp;				if (x != xprev || y != yprev) {</b>
<b class="fc">&nbsp;					if (!processBunchForSelfIntersectionTest_(bunch))</b>
<b class="fc">&nbsp;						return false;</b>
<b class="fc">&nbsp;					if (bunch != null)</b>
<b class="fc">&nbsp;						bunch.clear(false);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			bunch.add(xyindex);</b>
<b class="fc">&nbsp;			xprev = x;</b>
<b class="fc">&nbsp;			yprev = y;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		assert (bunch.size() &gt; 0);// cannot be empty</b>
&nbsp;
<b class="fc">&nbsp;		if (!processBunchForSelfIntersectionTest_(bunch))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
<b class="nc">&nbsp;	static final class Vertex_info {</b>
&nbsp;		double x, y;
&nbsp;		int ipath;
&nbsp;		int ivertex;
&nbsp;		boolean boundary;
&nbsp;	};
&nbsp;
<b class="fc">&nbsp;	static final class Vertex_info_pl {</b>
&nbsp;		double x;
&nbsp;		double y;
&nbsp;		int ipath;
&nbsp;		int ivertex;
&nbsp;		boolean boundary;
&nbsp;		boolean end_point;
&nbsp;	};
&nbsp;
&nbsp;	boolean checkSelfIntersectionsPolylinePlanar_() {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
&nbsp;
<b class="fc">&nbsp;		boolean closedPaths[] = new boolean[multiPathImpl.getPathCount()];</b>
<b class="fc">&nbsp;		for (int ipath = 0, npaths = multiPathImpl.getPathCount(); ipath &lt; npaths; ipath++) {</b>
<b class="fc">&nbsp;			closedPaths[ipath] = multiPathImpl.isClosedPathInXYPlane(ipath);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Vertex_info_pl vi_prev = new Vertex_info_pl();</b>
&nbsp;		boolean is_closed_path;
&nbsp;		int path_start;
&nbsp;		int path_last;
&nbsp;
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
&nbsp;
&nbsp;		{// scope
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(0);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			m_xy.read(2 * xyindex, pt);</b>
<b class="fc">&nbsp;			int ipath = m_paths_for_OGC_tests.get(xyindex);</b>
<b class="fc">&nbsp;			is_closed_path = closedPaths[ipath];</b>
<b class="fc">&nbsp;			path_start = multiPathImpl.getPathStart(ipath);</b>
<b class="fc">&nbsp;			path_last = multiPathImpl.getPathEnd(ipath) - 1;</b>
<b class="fc">&nbsp;			vi_prev.end_point = (xyindex == path_start)</b>
&nbsp;					|| (xyindex == path_last);
<b class="fc">&nbsp;			if (m_bOGCRestrictions)</b>
<b class="fc">&nbsp;				vi_prev.boundary = !is_closed_path &amp;&amp; vi_prev.end_point;</b>
&nbsp;			else {
&nbsp;				// for regular planar simplify, only the end points are allowed
&nbsp;				// to coincide
<b class="nc">&nbsp;				vi_prev.boundary = vi_prev.end_point;</b>
&nbsp;			}
&nbsp;			
<b class="fc">&nbsp;			vi_prev.ipath = ipath;</b>
<b class="fc">&nbsp;			vi_prev.x = pt.x;</b>
<b class="fc">&nbsp;			vi_prev.y = pt.y;</b>
<b class="fc">&nbsp;			vi_prev.ivertex = xyindex;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Vertex_info_pl vi = new Vertex_info_pl();</b>
&nbsp;
<b class="fc">&nbsp;		for (int index = 1, n = m_pairIndices.size(); index &lt; n; index++) {</b>
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(index);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			if ((pair &amp; 1) != 0)</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			m_xy.read(2 * xyindex, pt);</b>
<b class="fc">&nbsp;			int ipath = m_paths_for_OGC_tests.get(xyindex);</b>
<b class="fc">&nbsp;			if (ipath != vi_prev.ipath) {</b>
<b class="fc">&nbsp;				is_closed_path = closedPaths[ipath];</b>
<b class="fc">&nbsp;				path_start = multiPathImpl.getPathStart(ipath);</b>
<b class="fc">&nbsp;				path_last = multiPathImpl.getPathEnd(ipath) - 1;</b>
&nbsp;			}
&nbsp;			boolean boundary;
<b class="fc">&nbsp;			boolean end_point = (xyindex == path_start)</b>
&nbsp;					|| (xyindex == path_last);
<b class="fc">&nbsp;			if (m_bOGCRestrictions)</b>
<b class="fc">&nbsp;				boundary = !is_closed_path &amp;&amp; end_point;</b>
&nbsp;			else
&nbsp;				// for regular planar simplify, only the end points are allowed
&nbsp;				// to coincide
<b class="nc">&nbsp;				boundary = end_point;</b>
&nbsp;
<b class="fc">&nbsp;			vi.x = pt.x;</b>
<b class="fc">&nbsp;			vi.y = pt.y;</b>
<b class="fc">&nbsp;			vi.ipath = ipath;</b>
<b class="fc">&nbsp;			vi.ivertex = xyindex;</b>
<b class="fc">&nbsp;			vi.boundary = boundary;</b>
<b class="fc">&nbsp;			vi.end_point = end_point;</b>
&nbsp;
<b class="fc">&nbsp;			if (vi.x == vi_prev.x &amp;&amp; vi.y == vi_prev.y) {</b>
<b class="fc">&nbsp;				if (m_bOGCRestrictions) {</b>
<b class="fc">&nbsp;					if (!vi.boundary || !vi_prev.boundary) {</b>
&nbsp;						 // check that this is not the endpoints of a closed path						
<b class="fc">&nbsp;						if ((vi.ipath != vi_prev.ipath)</b>
&nbsp;								|| (!vi.end_point &amp;&amp; !vi_prev.end_point)) {
&nbsp;							// one of coincident vertices is not on the boundary
&nbsp;							// this is either NonSimpleResult.CrossOver or
&nbsp;							// NonSimpleResult.OGCPolylineSelfTangency.
&nbsp;							// too expensive to distinguish between the two.
<b class="fc">&nbsp;							m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;									NonSimpleResult.Reason.OGCPolylineSelfTangency,
&nbsp;									vi.ivertex, vi_prev.ivertex);
<b class="fc">&nbsp;							return false;// common point not on the boundary</b>
&nbsp;						}
&nbsp;					}
&nbsp;				} else {
<b class="nc">&nbsp;					if (!vi.end_point || !vi_prev.end_point) {</b>
&nbsp;						 //one of coincident vertices is not an endpoint
<b class="nc">&nbsp;						 m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;								NonSimpleResult.Reason.CrossOver, vi.ivertex,
&nbsp;								vi_prev.ivertex);
<b class="nc">&nbsp;						return false;// common point not on the boundary</b>
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			Vertex_info_pl tmp = vi_prev;</b>
<b class="fc">&nbsp;			vi_prev = vi;</b>
<b class="fc">&nbsp;			vi = tmp;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	final static class Vertex_info_pg {
&nbsp;		double x;
&nbsp;		double y;
&nbsp;		int ipath;
&nbsp;		int ivertex;
&nbsp;		int ipolygon;
&nbsp;
&nbsp;		Vertex_info_pg(double x_, double y_, int ipath_, int xyindex_,
<b class="fc">&nbsp;				int polygon_) {</b>
<b class="fc">&nbsp;			x = x_;</b>
<b class="fc">&nbsp;			y = y_;</b>
<b class="fc">&nbsp;			ipath = ipath_;</b>
<b class="fc">&nbsp;			ivertex = xyindex_;</b>
<b class="fc">&nbsp;			ipolygon = polygon_;</b>
&nbsp;		}
&nbsp;
&nbsp;		boolean is_equal(Vertex_info_pg other) {
<b class="nc">&nbsp;			return x == other.x &amp;&amp; y == other.y &amp;&amp; ipath == other.ipath</b>
&nbsp;					&amp;&amp; ivertex == other.ivertex &amp;&amp; ipolygon == other.ipolygon;
&nbsp;		}
&nbsp;	};
&nbsp;
&nbsp;	boolean check_self_intersections_polygons_OGC_() {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) (m_geometry._getImpl());</b>
&nbsp;		// OGC MultiPolygon is simple when each Polygon is simple and Polygons a
&nbsp;		// allowed only touch at finite number of vertices.
&nbsp;		// OGC Polygon is simple if it consist of simple LinearRings.
&nbsp;		// LinearRings cannot cross.
&nbsp;		// Any two LinearRings of a OGC Polygon are allowed to touch at single
&nbsp;		// vertex only.
&nbsp;		// The OGC Polygon interior has to be a connected set.
&nbsp;
&nbsp;		// At this point we assume that the ring order has to be correct (holes
&nbsp;		// follow corresponding exterior ring).
&nbsp;		// No Rings cross. Exterior rings can only touch at finite number of
&nbsp;		// vertices.
&nbsp;
&nbsp;		// Fill a mapping of ring to
<b class="fc">&nbsp;		int[] ring_to_polygon = new int[multiPathImpl.getPathCount()];</b>
<b class="fc">&nbsp;		int exteriors = -1;</b>
<b class="fc">&nbsp;		boolean has_holes = false;</b>
<b class="fc">&nbsp;		for (int ipath = 0, n = multiPathImpl.getPathCount(); ipath &lt; n; ipath++) {</b>
<b class="fc">&nbsp;			if (multiPathImpl.isExteriorRing(ipath)) {</b>
<b class="fc">&nbsp;				has_holes = false;</b>
<b class="fc">&nbsp;				exteriors++;</b>
<b class="fc">&nbsp;				if (ipath &lt; n - 1) {</b>
<b class="fc">&nbsp;					if (!multiPathImpl.isExteriorRing(ipath + 1))</b>
<b class="fc">&nbsp;						has_holes = true;</b>
&nbsp;				}
&nbsp;			}
&nbsp;
&nbsp;			// For OGC polygons with no holes, store -1.
&nbsp;			// For polygons with holes, store polygon index for each ring.
<b class="fc">&nbsp;			ring_to_polygon[ipath] = has_holes ? exteriors : -1;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Use already sorted m_pairIndices
<b class="fc">&nbsp;		Vertex_info_pg vi_prev = null;</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
&nbsp;		{// scope
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(0);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			m_xy.read(2 * xyindex, pt);</b>
<b class="fc">&nbsp;			int ipath = m_paths_for_OGC_tests.get(xyindex);</b>
<b class="fc">&nbsp;			vi_prev = new Vertex_info_pg(pt.x, pt.y, ipath, xyindex,</b>
&nbsp;					ring_to_polygon[ipath]);
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		ArrayList&lt;Vertex_info_pg&gt; intersections = new ArrayList&lt;Vertex_info_pg&gt;(</b>
<b class="fc">&nbsp;				multiPathImpl.getPathCount() * 2);</b>
<b class="fc">&nbsp;		for (int index = 1, n = m_pairIndices.size(); index &lt; n; index++) {</b>
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(index);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			if ((pair &amp; 1) != 0)</b>
<b class="fc">&nbsp;				continue;</b>
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			m_xy.read(2 * xyindex, pt);</b>
<b class="fc">&nbsp;			int ipath = m_paths_for_OGC_tests.get(xyindex);</b>
<b class="fc">&nbsp;			Vertex_info_pg vi = new Vertex_info_pg(pt.x, pt.y, ipath, xyindex,</b>
&nbsp;					ring_to_polygon[ipath]);
&nbsp;
<b class="fc">&nbsp;			if (vi.x == vi_prev.x &amp;&amp; vi.y == vi_prev.y) {</b>
<b class="fc">&nbsp;				if (vi.ipath == vi_prev.ipath) {// the ring has self tangency</b>
<b class="fc">&nbsp;					m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;							NonSimpleResult.Reason.OGCPolygonSelfTangency,
&nbsp;							vi.ivertex, vi_prev.ivertex);
<b class="fc">&nbsp;					return false;</b>
<b class="fc">&nbsp;				} else if (ring_to_polygon[vi.ipath] &gt;= 0</b>
&nbsp;						&amp;&amp; ring_to_polygon[vi.ipath] == ring_to_polygon[vi_prev.ipath]) {// only
&nbsp;																							// add
&nbsp;																							// rings
&nbsp;																							// from
&nbsp;																							// polygons
&nbsp;																							// with
&nbsp;																							// holes.
&nbsp;																							// Only
&nbsp;																							// interested
&nbsp;																							// in
&nbsp;																							// touching
&nbsp;																							// rings
&nbsp;																							// that
&nbsp;																							// belong
&nbsp;																							// to
&nbsp;																							// the
&nbsp;																							// same
&nbsp;																							// polygon
<b class="fc">&nbsp;					if (intersections.size() == 0</b>
<b class="fc">&nbsp;							|| intersections.get(intersections.size() - 1) != vi_prev)</b>
<b class="fc">&nbsp;						intersections.add(vi_prev);</b>
<b class="fc">&nbsp;					intersections.add(vi);</b>
&nbsp;				}
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			vi_prev = vi;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (intersections.size() == 0)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
&nbsp;		// Find disconnected interior cases (OGC spec: Interior of polygon has
&nbsp;		// to be a closed set)
&nbsp;
&nbsp;		// Note: Now we&#39;ll reuse ring_to_polygon for different purpose - to
&nbsp;		// store mapping from the rings to the graph nodes.
&nbsp;
<b class="fc">&nbsp;		IndexMultiDCList graph = new IndexMultiDCList(true);</b>
<b class="fc">&nbsp;		Arrays.fill(ring_to_polygon, -1);</b>
<b class="fc">&nbsp;		int vnode_index = -1;</b>
<b class="fc">&nbsp;		Point2D prev = new Point2D();</b>
<b class="fc">&nbsp;		prev.setNaN();</b>
<b class="fc">&nbsp;		for (int i = 0, n = intersections.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			Vertex_info_pg cur = intersections.get(i);</b>
<b class="fc">&nbsp;			if (cur.x != prev.x || cur.y != prev.y) {</b>
<b class="fc">&nbsp;				vnode_index = graph.createList(0);</b>
<b class="fc">&nbsp;				prev.x = cur.x;</b>
<b class="fc">&nbsp;				prev.y = cur.y;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			int rnode_index = ring_to_polygon[cur.ipath];</b>
<b class="fc">&nbsp;			if (rnode_index == -1) {</b>
<b class="fc">&nbsp;				rnode_index = graph.createList(2);</b>
<b class="fc">&nbsp;				ring_to_polygon[cur.ipath] = rnode_index;</b>
&nbsp;			}
<b class="fc">&nbsp;			graph.addElement(rnode_index, vnode_index); // add to rnode</b>
&nbsp;														// adjacency list the
&nbsp;														// current vnode
<b class="fc">&nbsp;			graph.addElement(vnode_index, rnode_index); // add to vnode</b>
&nbsp;														// adjacency list the
&nbsp;														// rnode
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt32 depth_first_stack = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		depth_first_stack.reserve(10);</b>
&nbsp;
<b class="fc">&nbsp;		for (int node = graph.getFirstList(); node != -1; node = graph</b>
<b class="fc">&nbsp;				.getNextList(node)) {</b>
<b class="fc">&nbsp;			int ncolor = graph.getListData(node);</b>
<b class="fc">&nbsp;			if ((ncolor &amp; 1) != 0 || (ncolor &amp; 2) == 0)</b>
<b class="fc">&nbsp;				continue;// already visited or this is a vnode (we do not want</b>
&nbsp;							// to start from vnode).
&nbsp;
<b class="fc">&nbsp;			int bad_rnode = -1;</b>
<b class="fc">&nbsp;			depth_first_stack.add(node);</b>
<b class="fc">&nbsp;			depth_first_stack.add(-1);// parent</b>
<b class="fc">&nbsp;			while (depth_first_stack.size() &gt; 0) {</b>
<b class="fc">&nbsp;				int cur_node_parent = depth_first_stack.getLast();</b>
<b class="fc">&nbsp;				depth_first_stack.removeLast();</b>
<b class="fc">&nbsp;				int cur_node = depth_first_stack.getLast();</b>
<b class="fc">&nbsp;				depth_first_stack.removeLast();</b>
<b class="fc">&nbsp;				int color = graph.getListData(cur_node);</b>
<b class="fc">&nbsp;				if ((color &amp; 1) != 0) {</b>
&nbsp;					// already visited this node. This means we found a loop.
<b class="fc">&nbsp;					if ((color &amp; 2) == 0) {// closing on vnode</b>
<b class="nc">&nbsp;						bad_rnode = cur_node_parent;</b>
&nbsp;					} else
<b class="fc">&nbsp;						bad_rnode = cur_node;</b>
&nbsp;
&nbsp;					// assert(bad_rnode != -1);
<b class="fc">&nbsp;					break;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				graph.setListData(cur_node, color | 1);</b>
<b class="fc">&nbsp;				for (int adjacent_node = graph.getFirst(cur_node); adjacent_node != -1; adjacent_node = graph</b>
<b class="fc">&nbsp;						.getNext(adjacent_node)) {</b>
<b class="fc">&nbsp;					int adjacent_node_data = graph.getData(adjacent_node);</b>
<b class="fc">&nbsp;					if (adjacent_node_data == cur_node_parent)</b>
<b class="fc">&nbsp;						continue;// avoid going back to where we just came from</b>
<b class="fc">&nbsp;					depth_first_stack.add(adjacent_node_data);</b>
<b class="fc">&nbsp;					depth_first_stack.add(cur_node);// push cur_node as parent</b>
&nbsp;													// of adjacent_node
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;
<b class="fc">&nbsp;			if (bad_rnode != -1) {</b>
<b class="fc">&nbsp;				int bad_ring_index = -1;</b>
<b class="fc">&nbsp;				for (int i = 0, n = ring_to_polygon.length; i &lt; n; i++)</b>
<b class="fc">&nbsp;					if (ring_to_polygon[i] == bad_rnode) {</b>
<b class="fc">&nbsp;						bad_ring_index = i;</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					}
&nbsp;
&nbsp;				// bad_ring_index is any ring in a problematic chain of touching
&nbsp;				// rings.
&nbsp;				// When chain of touching rings form a loop, the result is a
&nbsp;				// disconnected interior,
&nbsp;				// which is non-simple for OGC spec.
<b class="fc">&nbsp;				m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;						NonSimpleResult.Reason.OGCDisconnectedInterior,
&nbsp;						bad_ring_index, -1);
<b class="fc">&nbsp;				return false;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int checkValidRingOrientation_() {
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
<b class="fc">&nbsp;		double totalArea = multiPathImpl.calculateArea2D();</b>
<b class="fc">&nbsp;		if (totalArea &lt;= 0) {</b>
<b class="fc">&nbsp;			m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;					NonSimpleResult.Reason.RingOrientation,
<b class="fc">&nbsp;					multiPathImpl.getPathCount() == 1 ? 1 : -1, -1);</b>
<b class="fc">&nbsp;			return 0;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (multiPathImpl.getPathCount() == 1) {// optimization for a single</b>
&nbsp;												// polygon
<b class="fc">&nbsp;			if (m_bOGCRestrictions) {</b>
<b class="fc">&nbsp;				if (!check_self_intersections_polygons_OGC_())</b>
<b class="fc">&nbsp;					return 0;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return 2;</b>
&nbsp;		}
&nbsp;
&nbsp;		// 1.Go through all vertices in the sorted order.
&nbsp;		// 2.For each vertex,insert any non-horizontal segment that has the
&nbsp;		// vertex as low point(there can be max two segments)
<b class="fc">&nbsp;		m_pathOrientations = new AttributeStreamOfInt32(</b>
<b class="fc">&nbsp;				multiPathImpl.getPathCount(), 0);</b>
&nbsp;
<b class="fc">&nbsp;		m_pathParentage = new AttributeStreamOfInt32(</b>
<b class="fc">&nbsp;				multiPathImpl.getPathCount(), -1);</b>
&nbsp;
<b class="fc">&nbsp;		int parent_ring = -1;</b>
<b class="fc">&nbsp;		double exteriorArea = 0;</b>
<b class="fc">&nbsp;		for (int ipath = 0, n = multiPathImpl.getPathCount(); ipath &lt; n; ipath++) {</b>
<b class="fc">&nbsp;			double area = multiPathImpl.calculateRingArea2D(ipath);</b>
<b class="fc">&nbsp;			m_pathOrientations.write(ipath, area &lt; 0 ? 0 : 256); // 8th bit</b>
&nbsp;																	// is
&nbsp;																	// existing
&nbsp;																	// orientation
<b class="fc">&nbsp;			if (area &gt; 0) {</b>
<b class="fc">&nbsp;				parent_ring = ipath;</b>
<b class="fc">&nbsp;				exteriorArea = area;</b>
<b class="fc">&nbsp;			} else if (area == 0) {</b>
<b class="nc">&nbsp;				m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;						NonSimpleResult.Reason.RingOrientation, ipath, -1);
<b class="nc">&nbsp;				return 0;</b>
&nbsp;			} else {
&nbsp;				// area &lt; 0: this is a hole.
&nbsp;				// We write the parent exterior
&nbsp;				// ring for it (assumed to be first previous exterior ring)
<b class="fc">&nbsp;				if (parent_ring &lt; 0 || exteriorArea &lt; Math.abs(area)) {</b>
&nbsp;					// The first ring is a hole - this is a wrong ring ordering.
&nbsp;					// Or the hole&#39;s area is bigger than the previous exterior
&nbsp;					// area - this means ring order is broken,
&nbsp;					// because holes are always smaller. This is not the only
&nbsp;					// condition when ring order is broken though.
<b class="fc">&nbsp;					m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;							NonSimpleResult.Reason.RingOrder, ipath, -1);
<b class="fc">&nbsp;					if (m_bOGCRestrictions)</b>
<b class="fc">&nbsp;						return 0;</b>
&nbsp;				}
<b class="fc">&nbsp;				m_pathParentage.write(ipath, parent_ring);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		m_unknownOrientationPathCount = multiPathImpl.getPathCount();</b>
<b class="fc">&nbsp;		m_newEdges = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		m_newEdges.reserve(10);</b>
&nbsp;
<b class="fc">&nbsp;		int pointCount = multiPathImpl.getPointCount();</b>
<b class="fc">&nbsp;		m_yScanline = NumberUtils.TheNaN;</b>
<b class="fc">&nbsp;		AttributeStreamOfInt32 bunch = new AttributeStreamOfInt32(0); // stores</b>
&nbsp;																		// coincident
&nbsp;																		// vertices
<b class="fc">&nbsp;		bunch.reserve(10);</b>
&nbsp;		// Each vertex has two edges attached.These two arrays map vertices to
&nbsp;		// edges as nodes in the m_AET
<b class="fc">&nbsp;		m_xyToNode1 = new AttributeStreamOfInt32(pointCount, Treap.nullNode());</b>
<b class="fc">&nbsp;		m_xyToNode2 = new AttributeStreamOfInt32(pointCount, Treap.nullNode());</b>
<b class="fc">&nbsp;		if (m_FreeEdges != null)</b>
<b class="nc">&nbsp;			m_FreeEdges.clear(false);</b>
&nbsp;		else
<b class="fc">&nbsp;			m_FreeEdges = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		m_FreeEdges.reserve(10);</b>
&nbsp;
<b class="fc">&nbsp;		m_AET.clear();</b>
<b class="fc">&nbsp;		m_AET.setComparator(new RingOrientationTestComparator(this));</b>
<b class="fc">&nbsp;		for (int index = 0, n = pointCount * 2; m_unknownOrientationPathCount &gt; 0</b>
<b class="fc">&nbsp;				&amp;&amp; index &lt; n; index++) {</b>
<b class="fc">&nbsp;			int pairIndex = m_pairIndices.get(index);</b>
<b class="fc">&nbsp;			int pair = m_pairs.get(pairIndex);</b>
<b class="fc">&nbsp;			if ((pair &amp; 1) != 0)</b>
<b class="fc">&nbsp;				continue;// m_pairs array is redundant.See checkClustering_.</b>
&nbsp;
<b class="fc">&nbsp;			int xyindex = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			double y = m_xy.read(2 * xyindex + 1);</b>
&nbsp;
<b class="fc">&nbsp;			if (y != m_yScanline &amp;&amp; bunch.size() != 0) {</b>
<b class="fc">&nbsp;				if (!processBunchForRingOrientationTest_(bunch)) {</b>
&nbsp;					// m_nonSimpleResult is set in the
&nbsp;					// processBunchForRingOrientationTest_
<b class="fc">&nbsp;					return 0;</b>
&nbsp;				}
<b class="fc">&nbsp;				if (bunch != null)</b>
<b class="fc">&nbsp;					bunch.clear(false);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			bunch.add(xyindex);// all vertices that have same y are added to the</b>
&nbsp;			// bunch
<b class="fc">&nbsp;			m_yScanline = y;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_unknownOrientationPathCount &gt; 0</b>
<b class="nc">&nbsp;				&amp;&amp; !processBunchForRingOrientationTest_(bunch)) {</b>
&nbsp;			// m_nonSimpleResult is set in the
&nbsp;			// processBunchForRingOrientationTest_
<b class="nc">&nbsp;			return 0;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_bOGCRestrictions) {</b>
<b class="fc">&nbsp;			if (m_nonSimpleResult.m_reason != NonSimpleResult.Reason.NotDetermined)</b>
<b class="nc">&nbsp;				return 0;// cannot proceed with OGC verification if the ring</b>
&nbsp;							// order is broken (cannot decide polygons then).
&nbsp;
<b class="fc">&nbsp;			if (!check_self_intersections_polygons_OGC_())</b>
<b class="fc">&nbsp;				return 0;</b>
&nbsp;
<b class="fc">&nbsp;			return 2;// everything is good</b>
&nbsp;		} else {
<b class="fc">&nbsp;			if (m_nonSimpleResult.m_reason == NonSimpleResult.Reason.NotDetermined)</b>
<b class="fc">&nbsp;				return 2;// everything is good</b>
&nbsp;
&nbsp;			// weak simple
<b class="fc">&nbsp;			return 1;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private boolean processBunchForSelfIntersectionTest_(
&nbsp;			AttributeStreamOfInt32 bunch) {
<b class="fc">&nbsp;		assert (bunch.size() &gt; 0);</b>
<b class="fc">&nbsp;		if (bunch.size() == 1)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		assert (m_edges.size() == 0);</b>
&nbsp;
&nbsp;		// Bunch contains vertices that have exactly same x and y.
&nbsp;		// We populate m_edges array with the edges that originate in the
&nbsp;		// vertices of the bunch.
<b class="fc">&nbsp;		for (int i = 0, n = bunch.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			int xyindex = bunch.get(i);</b>
<b class="fc">&nbsp;			m_recycledSegIter.resetToVertex(xyindex);// the iterator is</b>
&nbsp;														// circular.
<b class="fc">&nbsp;			/* const */Segment seg1 = m_recycledSegIter.previousSegment();</b>
<b class="fc">&nbsp;			m_edges.add(createEdge_(seg1, xyindex,</b>
<b class="fc">&nbsp;					m_recycledSegIter.getPathIndex(), true));</b>
<b class="fc">&nbsp;			m_recycledSegIter.nextSegment();// Need to skip one,because of the</b>
&nbsp;											// previousSegment call
&nbsp;			// before (otherwise will get same segment again)
<b class="fc">&nbsp;			/* const */Segment seg2 = m_recycledSegIter.nextSegment();</b>
<b class="fc">&nbsp;			m_edges.add(createEdge_(seg2, xyindex,</b>
<b class="fc">&nbsp;					m_recycledSegIter.getPathIndex(), false));</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		assert ((m_edges.size() &amp; 1) == 0); // even size</b>
&nbsp;
&nbsp;		// Analyze the bunch edges for self intersections(the edges touch at the
&nbsp;		// end points only at this stage of IsSimple)
&nbsp;		// 1.sort the edges by angle between edge and the unit vector along axis
&nbsp;		// x,using the cross product sign.Precondition:no overlaps occur at this
&nbsp;		// stage.
&nbsp;
<b class="fc">&nbsp;		Collections.sort(m_edges, new EdgeComparerForSelfIntersection(this));</b>
&nbsp;
&nbsp;		// 2.Analyze the bunch.There can be no edges between edges that share
&nbsp;		// same vertex coordinates.
&nbsp;		// We populate a doubly linked list with the edge indices and iterate
&nbsp;		// over this list getting rid of the neighbouring pairs of vertices.
&nbsp;		// The process is similar to peeling an onion.
&nbsp;		// If the list becomes empty,there are no crossovers,otherwise,the
&nbsp;		// geometry has cross-over.
<b class="fc">&nbsp;		int list = m_crossOverHelperList.getFirstList();</b>
&nbsp;
<b class="fc">&nbsp;		if (list == -1)</b>
<b class="fc">&nbsp;			list = m_crossOverHelperList.createList(0);</b>
&nbsp;
<b class="fc">&nbsp;		m_crossOverHelperList.reserveNodes(m_edges.size());</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0, n = m_edges.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			m_crossOverHelperList.addElement(list, i);</b>
&nbsp;		}
&nbsp;
&nbsp;		// Peel the onion
<b class="fc">&nbsp;		boolean bContinue = true;</b>
<b class="fc">&nbsp;		int i1 = -1;</b>
<b class="fc">&nbsp;		int i2 = -1;</b>
<b class="fc">&nbsp;		while (bContinue) {</b>
<b class="fc">&nbsp;			bContinue = false;</b>
<b class="fc">&nbsp;			int listnode = m_crossOverHelperList.getFirst(list);</b>
<b class="fc">&nbsp;			if (listnode == -1)</b>
<b class="fc">&nbsp;				break;</b>
&nbsp;
<b class="fc">&nbsp;			int nextnode = m_crossOverHelperList.getNext(listnode);</b>
<b class="fc">&nbsp;			while (nextnode != -1) {</b>
<b class="fc">&nbsp;				int edgeindex1 = m_crossOverHelperList.getData(listnode);</b>
<b class="fc">&nbsp;				int edgeindex2 = m_crossOverHelperList.getData(nextnode);</b>
<b class="fc">&nbsp;				i1 = m_edges.get(edgeindex1).m_vertexIndex;</b>
<b class="fc">&nbsp;				i2 = m_edges.get(edgeindex2).m_vertexIndex;</b>
<b class="fc">&nbsp;				if (i1 == i2) {</b>
<b class="fc">&nbsp;					bContinue = true;</b>
<b class="fc">&nbsp;					m_crossOverHelperList.deleteElement(list, listnode);</b>
<b class="fc">&nbsp;					listnode = m_crossOverHelperList.getPrev(nextnode);</b>
<b class="fc">&nbsp;					nextnode = m_crossOverHelperList.deleteElement(list,</b>
&nbsp;							nextnode);
<b class="fc">&nbsp;					if (nextnode == -1 || listnode == -1)</b>
<b class="fc">&nbsp;						break;</b>
&nbsp;					else
&nbsp;						continue;
&nbsp;				}
<b class="fc">&nbsp;				listnode = nextnode;</b>
<b class="fc">&nbsp;				nextnode = m_crossOverHelperList.getNext(listnode);</b>
<b class="fc">&nbsp;			}</b>
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		int listSize = m_crossOverHelperList.getListSize(list);</b>
<b class="fc">&nbsp;		m_crossOverHelperList.clear(list);</b>
<b class="fc">&nbsp;		if (listSize &gt; 0) {</b>
&nbsp;			// There is self-intersection here.
<b class="fc">&nbsp;			m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;					NonSimpleResult.Reason.CrossOver, i1, i2);
<b class="fc">&nbsp;			return false;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Recycle the bunch to save on object creation
<b class="fc">&nbsp;		for (int i = 0, n = bunch.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			recycleEdge_(m_edges.get(i));</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		m_edges.clear();</b>
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private boolean processBunchForRingOrientationTest_(
&nbsp;			AttributeStreamOfInt32 bunch) {
<b class="fc">&nbsp;		m_dbgCounter++;</b>
<b class="fc">&nbsp;		assert (bunch.size() &gt; 0);</b>
&nbsp;
&nbsp;		// remove nodes that go out of scope
<b class="fc">&nbsp;		for (int i = 0, n = bunch.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			int xyindex = bunch.get(i);</b>
<b class="fc">&nbsp;			int aetNode = m_xyToNode1.read(xyindex);</b>
<b class="fc">&nbsp;			if (aetNode != Treap.nullNode()) {// We found that there is an edge</b>
&nbsp;												// in AET, attached to the
&nbsp;												// xyindex vertex. This edge
&nbsp;												// goes out of scope. Delete it
&nbsp;												// from AET.
<b class="fc">&nbsp;				int edgeIndex = m_AET.getElement(aetNode);</b>
<b class="fc">&nbsp;				m_FreeEdges.add(edgeIndex);</b>
<b class="fc">&nbsp;				m_AET.deleteNode(aetNode, -1);</b>
<b class="fc">&nbsp;				recycleEdge_(m_edges.get(edgeIndex));</b>
<b class="fc">&nbsp;				m_edges.set(edgeIndex, null);</b>
<b class="fc">&nbsp;				m_xyToNode1.write(xyindex, Treap.nullNode());</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			aetNode = m_xyToNode2.read(xyindex);</b>
<b class="fc">&nbsp;			if (aetNode != Treap.nullNode()) {// We found that there is an edge</b>
&nbsp;												// in AET, attached to the
&nbsp;												// xyindex vertex. This edge
&nbsp;												// goes out of scope. Delete it
&nbsp;												// from AET.
<b class="fc">&nbsp;				int edgeIndex = m_AET.getElement(aetNode);</b>
<b class="fc">&nbsp;				m_FreeEdges.add(edgeIndex);</b>
<b class="fc">&nbsp;				m_AET.deleteNode(aetNode, -1);</b>
<b class="fc">&nbsp;				recycleEdge_(m_edges.get(edgeIndex));</b>
<b class="fc">&nbsp;				m_edges.set(edgeIndex, null);</b>
<b class="fc">&nbsp;				m_xyToNode2.write(xyindex, Treap.nullNode());</b>
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// add new edges to AET
<b class="fc">&nbsp;		for (int i = 0, n = bunch.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			int xyindex = bunch.get(i);</b>
<b class="fc">&nbsp;			m_recycledSegIter.resetToVertex(xyindex);// the iterator is</b>
&nbsp;														// circular.
<b class="fc">&nbsp;			Segment seg1 = m_recycledSegIter.previousSegment();// this</b>
&nbsp;																// segment
&nbsp;																// has
&nbsp;																// end
&nbsp;																// point
&nbsp;																// at
&nbsp;																// xyindex
<b class="fc">&nbsp;			if (seg1.getStartY() &gt; seg1.getEndY())// do not allow horizontal</b>
&nbsp;			// segments in here
&nbsp;			{
&nbsp;				// get the top vertex index.We use it to determine what segments
&nbsp;				// to get rid of.
<b class="fc">&nbsp;				int edgeTopIndex = m_recycledSegIter.getStartPointIndex();</b>
<b class="fc">&nbsp;				Edge edge = createEdge_(seg1, xyindex,</b>
<b class="fc">&nbsp;						m_recycledSegIter.getPathIndex(), true);</b>
&nbsp;				int edgeIndex;
<b class="fc">&nbsp;				if (m_FreeEdges.size() &gt; 0) {</b>
<b class="fc">&nbsp;					edgeIndex = m_FreeEdges.getLast();</b>
<b class="fc">&nbsp;					m_FreeEdges.removeLast();</b>
<b class="fc">&nbsp;					m_edges.set(edgeIndex, edge);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					edgeIndex = m_edges.size();</b>
<b class="fc">&nbsp;					m_edges.add(edge);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				int aetNode = m_AET.addElement(edgeIndex, -1);</b>
&nbsp;				// Remember AET nodes in the vertex to AET node maps.
<b class="fc">&nbsp;				if (m_xyToNode1.read(edgeTopIndex) == Treap.nullNode())</b>
<b class="fc">&nbsp;					m_xyToNode1.write(edgeTopIndex, aetNode);</b>
&nbsp;				else {
<b class="fc">&nbsp;					assert (m_xyToNode2.read(edgeTopIndex) == Treap.nullNode());</b>
<b class="fc">&nbsp;					m_xyToNode2.write(edgeTopIndex, aetNode);</b>
&nbsp;				}
&nbsp;
&nbsp;				// If this edge belongs to a path that has not have direction
&nbsp;				// figured out yet,
&nbsp;				// add it to m_newEdges for post processing
<b class="fc">&nbsp;				if ((m_pathOrientations.read(m_recycledSegIter.getPathIndex()) &amp; 3) == 0)</b>
<b class="fc">&nbsp;					m_newEdges.add(aetNode);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			m_recycledSegIter.nextSegment();// Need to skip one,because of the</b>
&nbsp;			// previousSegment call
&nbsp;			// before(otherwise will get same
&nbsp;			// segment again)
&nbsp;			// seg1 is invalid now
<b class="fc">&nbsp;			Segment seg2 = m_recycledSegIter.nextSegment();</b>
&nbsp;			// start has to be lower than end for this one
<b class="fc">&nbsp;			if (seg2.getStartY() &lt; seg2.getEndY())// do not allow horizontal</b>
&nbsp;			// segments in here
&nbsp;			{
&nbsp;				// get the top vertex index.We use it to determine what segments
&nbsp;				// to get rid of.
<b class="fc">&nbsp;				int edgeTopIndex = m_recycledSegIter.getEndPointIndex();</b>
<b class="fc">&nbsp;				Edge edge = createEdge_(seg2, xyindex,</b>
<b class="fc">&nbsp;						m_recycledSegIter.getPathIndex(), false);</b>
&nbsp;				int edgeIndex;
<b class="fc">&nbsp;				if (m_FreeEdges.size() &gt; 0) {</b>
<b class="fc">&nbsp;					edgeIndex = m_FreeEdges.getLast();</b>
<b class="fc">&nbsp;					m_FreeEdges.removeLast();</b>
<b class="fc">&nbsp;					m_edges.set(edgeIndex, edge);</b>
&nbsp;				} else {
<b class="fc">&nbsp;					edgeIndex = m_edges.size();</b>
<b class="fc">&nbsp;					m_edges.add(edge);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				int aetNode = m_AET.addElement(edgeIndex, -1);</b>
<b class="fc">&nbsp;				if (m_xyToNode1.read(edgeTopIndex) == Treap.nullNode())</b>
<b class="fc">&nbsp;					m_xyToNode1.write(edgeTopIndex, aetNode);</b>
&nbsp;				else {
<b class="fc">&nbsp;					assert (m_xyToNode2.read(edgeTopIndex) == Treap.nullNode());</b>
<b class="fc">&nbsp;					m_xyToNode2.write(edgeTopIndex, aetNode);</b>
&nbsp;				}
&nbsp;
&nbsp;				// If this edge belongs to a path that has not have direction
&nbsp;				// figured out yet,
&nbsp;				// add it to m_newEdges for post processing
<b class="fc">&nbsp;				if ((m_pathOrientations.read(m_recycledSegIter.getPathIndex()) &amp; 3) == 0)</b>
<b class="fc">&nbsp;					m_newEdges.add(aetNode);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		for (int i = 0, n = m_newEdges.size(); i &lt; n</b>
<b class="fc">&nbsp;				&amp;&amp; m_unknownOrientationPathCount &gt; 0; i++) {</b>
<b class="fc">&nbsp;			int aetNode = m_newEdges.get(i);</b>
<b class="fc">&nbsp;			int edgeIndexInitial = m_AET.getElement(aetNode);</b>
<b class="fc">&nbsp;			Edge edgeInitial = m_edges.get(edgeIndexInitial);</b>
<b class="fc">&nbsp;			int pathIndexInitial = edgeInitial.m_pathIndex;</b>
<b class="fc">&nbsp;			int directionInitial = m_pathOrientations.read(pathIndexInitial);</b>
<b class="fc">&nbsp;			if ((directionInitial &amp; 3) == 0) {</b>
<b class="fc">&nbsp;				int prevExteriorPath = -1;</b>
<b class="fc">&nbsp;				int node = m_AET.getPrev(aetNode);</b>
<b class="fc">&nbsp;				int prevNode = aetNode;</b>
<b class="fc">&nbsp;				int oddEven = 0;</b>
&nbsp;				{// scope
<b class="fc">&nbsp;					int edgeIndex = -1;</b>
<b class="fc">&nbsp;					Edge edge = null;</b>
<b class="fc">&nbsp;					int pathIndex = -1;</b>
<b class="fc">&nbsp;					int dir = 0;</b>
&nbsp;					// find the leftmost edge for which the ring orientation is
&nbsp;					// known
<b class="fc">&nbsp;					while (node != Treap.nullNode()) {</b>
<b class="fc">&nbsp;						edgeIndex = m_AET.getElement(node);</b>
<b class="fc">&nbsp;						edge = m_edges.get(edgeIndex);</b>
<b class="fc">&nbsp;						pathIndex = edge.m_pathIndex;</b>
<b class="fc">&nbsp;						dir = m_pathOrientations.read(pathIndex);</b>
<b class="fc">&nbsp;						if ((dir &amp; 3) != 0)</b>
<b class="fc">&nbsp;							break;</b>
&nbsp;
<b class="fc">&nbsp;						prevNode = node;</b>
<b class="fc">&nbsp;						node = m_AET.getPrev(node);</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if (node == Treap.nullNode()) {// if no edges have ring</b>
&nbsp;													// orientation known, then
&nbsp;													// start
&nbsp;													// from the left most and it
&nbsp;													// has
&nbsp;													// to be exterior ring.
<b class="fc">&nbsp;						oddEven = 1;</b>
<b class="fc">&nbsp;						node = prevNode;</b>
&nbsp;					} else {
<b class="fc">&nbsp;						if ((dir &amp; 3) == 1) {</b>
<b class="fc">&nbsp;							prevExteriorPath = pathIndex;</b>
&nbsp;						} else {
<b class="fc">&nbsp;							prevExteriorPath = m_pathParentage.read(pathIndex);</b>
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						oddEven = (edge.getRightSide() != 0) ? 0 : 1;</b>
<b class="fc">&nbsp;						node = m_AET.getNext(node);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				do {
<b class="fc">&nbsp;					int edgeIndex = m_AET.getElement(node);</b>
<b class="fc">&nbsp;					Edge edge = m_edges.get(edgeIndex);</b>
<b class="fc">&nbsp;					int pathIndex = edge.m_pathIndex;</b>
<b class="fc">&nbsp;					int direction = m_pathOrientations.read(pathIndex);</b>
<b class="fc">&nbsp;					if ((direction &amp; 3) == 0) {</b>
<b class="fc">&nbsp;						if (oddEven != edge.getRightSide()) {</b>
<b class="fc">&nbsp;							m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;									NonSimpleResult.Reason.RingOrientation,
&nbsp;									pathIndex, -1);
<b class="fc">&nbsp;							return false;// wrong ring orientation</b>
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						int dir = (oddEven != 0 &amp;&amp; !edge.getReversed()) ? 1 : 2;</b>
<b class="fc">&nbsp;						direction = (direction &amp; 0xfc) | dir;</b>
<b class="fc">&nbsp;						m_pathOrientations.write(pathIndex, dir);</b>
<b class="fc">&nbsp;						if (dir == 2</b>
&nbsp;								&amp;&amp; m_nonSimpleResult.m_reason == NonSimpleResult.Reason.NotDetermined) {
&nbsp;							// check that this hole has a correct parent
&nbsp;							// exterior ring.
<b class="fc">&nbsp;							int parent = m_pathParentage.read(pathIndex);</b>
<b class="fc">&nbsp;							if (parent != prevExteriorPath) {</b>
<b class="nc">&nbsp;								m_nonSimpleResult = new NonSimpleResult(</b>
&nbsp;										NonSimpleResult.Reason.RingOrder,
&nbsp;										pathIndex, -1);
<b class="nc">&nbsp;								if (m_bOGCRestrictions)</b>
<b class="nc">&nbsp;									return false;</b>
&nbsp;							}
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						m_unknownOrientationPathCount--;</b>
<b class="fc">&nbsp;						if (m_unknownOrientationPathCount == 0)// if(!m_unknownOrientationPathCount)</b>
<b class="fc">&nbsp;							return true;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if ((direction &amp; 3) == 1) {</b>
<b class="fc">&nbsp;						prevExteriorPath = pathIndex;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					prevNode = node;</b>
<b class="fc">&nbsp;					node = m_AET.getNext(node);</b>
<b class="fc">&nbsp;					oddEven = oddEven != 0 ? 0 : 1;</b>
<b class="fc">&nbsp;				} while (prevNode != aetNode);</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_newEdges != null)</b>
<b class="fc">&nbsp;			m_newEdges.clear(false);</b>
&nbsp;		else
<b class="nc">&nbsp;			m_newEdges = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Edge createEdge_(/* const */Segment seg, int xyindex, int pathIndex,
&nbsp;			boolean bReversed) {
&nbsp;		Edge edge;
<b class="fc">&nbsp;		Geometry.Type gt = seg.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Line) {</b>
<b class="fc">&nbsp;			edge = createEdgeLine_(seg);</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError(); // implement</b>
&nbsp;															// recycling for
&nbsp;															// curves
&nbsp;		}
<b class="fc">&nbsp;		edge.m_vertexIndex = xyindex;</b>
<b class="fc">&nbsp;		edge.m_pathIndex = pathIndex;</b>
<b class="fc">&nbsp;		edge.m_flags = 0;</b>
<b class="fc">&nbsp;		edge.setReversed(bReversed);</b>
&nbsp;
<b class="fc">&nbsp;		return edge;</b>
&nbsp;	}
&nbsp;
&nbsp;	private Edge createEdgeLine_(/* const */Segment seg) {
<b class="fc">&nbsp;		Edge edge = null;</b>
<b class="fc">&nbsp;		if (m_lineEdgesRecycle.size() &gt; 0) {</b>
<b class="fc">&nbsp;			int indexLast = m_lineEdgesRecycle.size() - 1;</b>
<b class="fc">&nbsp;			edge = m_lineEdgesRecycle.get(indexLast);</b>
<b class="fc">&nbsp;			m_lineEdgesRecycle.remove(indexLast);</b>
<b class="fc">&nbsp;			seg.copyTo(edge.m_segment);</b>
<b class="fc">&nbsp;		} else {</b>
<b class="fc">&nbsp;			edge = new Edge();</b>
<b class="fc">&nbsp;			edge.m_segment = (Segment) Segment._clone(seg);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return edge;</b>
&nbsp;	}
&nbsp;
&nbsp;	private void recycleEdge_(/* const */Edge edge) {
<b class="fc">&nbsp;		Geometry.Type gt = edge.m_segment.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Line) {</b>
<b class="fc">&nbsp;			m_lineEdgesRecycle.add(edge);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static final class ClusterTestComparator extends Treap.Comparator {
&nbsp;		OperatorSimplifyLocalHelper m_helper;
&nbsp;
<b class="fc">&nbsp;		ClusterTestComparator(OperatorSimplifyLocalHelper helper) {</b>
<b class="fc">&nbsp;			m_helper = helper;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		int compare(/* const */Treap treap, int xy1, int node) {
<b class="fc">&nbsp;			int xy2 = treap.getElement(node);</b>
<b class="fc">&nbsp;			double x1 = m_helper.m_xy.read(2 * xy1);</b>
<b class="fc">&nbsp;			double x2 = m_helper.m_xy.read(2 * xy2);</b>
<b class="fc">&nbsp;			double dx = x1 - x2;</b>
<b class="fc">&nbsp;			return dx &lt; 0 ? -1 : (dx &gt; 0 ? 1 : 0);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
<b class="fc">&nbsp;	private static final class RingOrientationTestComparator extends</b>
&nbsp;			Treap.Comparator {
&nbsp;		private OperatorSimplifyLocalHelper m_helper;
&nbsp;
<b class="fc">&nbsp;		RingOrientationTestComparator(OperatorSimplifyLocalHelper helper) {</b>
<b class="fc">&nbsp;			m_helper = helper;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		int compare(/* const */Treap treap, int left, int node) {
<b class="fc">&nbsp;			int right = treap.getElement(node);</b>
<b class="fc">&nbsp;			Edge edge1 = m_helper.m_edges.get(left);</b>
<b class="fc">&nbsp;			Edge edge2 = m_helper.m_edges.get(right);</b>
<b class="fc">&nbsp;			boolean bEdge1Reversed = edge1.getReversed();</b>
<b class="fc">&nbsp;			boolean bEdge2Reversed = edge2.getReversed();</b>
&nbsp;
<b class="fc">&nbsp;			double x1 = edge1.m_segment.intersectionOfYMonotonicWithAxisX(</b>
<b class="fc">&nbsp;					m_helper.m_yScanline, 0);</b>
<b class="fc">&nbsp;			double x2 = edge2.m_segment.intersectionOfYMonotonicWithAxisX(</b>
<b class="fc">&nbsp;					m_helper.m_yScanline, 0);</b>
&nbsp;
<b class="fc">&nbsp;			if (x1 == x2) {</b>
&nbsp;				// apparently these edges originate from same vertex and the
&nbsp;				// scanline is on the vertex.move scanline a little.
<b class="fc">&nbsp;				double y1 = bEdge1Reversed ? edge1.m_segment.getStartY()</b>
<b class="fc">&nbsp;						: edge1.m_segment.getEndY();</b>
<b class="fc">&nbsp;				double y2 = bEdge2Reversed ? edge2.m_segment.getStartY()</b>
<b class="fc">&nbsp;						: edge2.m_segment.getEndY();</b>
<b class="fc">&nbsp;				double miny = Math.min(y1, y2);</b>
<b class="fc">&nbsp;				double y = (miny - m_helper.m_yScanline) * 0.5</b>
<b class="fc">&nbsp;						+ m_helper.m_yScanline;</b>
<b class="fc">&nbsp;				if (y == m_helper.m_yScanline) {</b>
&nbsp;					// assert(0); //ST: not a bug. just curious to see this
&nbsp;					// happens.
<b class="nc">&nbsp;					y = miny; // apparently, one of the segments is almost</b>
&nbsp;								// horizontal line.
&nbsp;				}
<b class="fc">&nbsp;				x1 = edge1.m_segment.intersectionOfYMonotonicWithAxisX(y, 0);</b>
<b class="fc">&nbsp;				x2 = edge2.m_segment.intersectionOfYMonotonicWithAxisX(y, 0);</b>
<b class="fc">&nbsp;				assert (x1 != x2);</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return x1 &lt; x2 ? -1 : (x1 &gt; x2 ? 1 : 0);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	int multiPointIsSimpleAsFeature_() {
<b class="fc">&nbsp;		MultiVertexGeometryImpl multiVertexImpl = (MultiVertexGeometryImpl) m_geometry</b>
<b class="fc">&nbsp;				._getImpl();</b>
&nbsp;		// sort lexicographically: by y,then by x, then by other attributes in
&nbsp;		// the order.
&nbsp;		// Go through the sorted list and make sure no points coincide exactly
&nbsp;		// (no tolerance is taken into account).
<b class="fc">&nbsp;		int pointCount = multiVertexImpl.getPointCount();</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt32 indices = new AttributeStreamOfInt32(0);</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			indices.add(i);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		indices.Sort(0, pointCount, new MultiPointVertexComparer(this));</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 1; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			if (compareVerticesMultiPoint_(indices.get(i - 1), indices.get(i)) == 0) {</b>
<b class="fc">&nbsp;				m_nonSimpleResult = new NonSimpleResult(</b>
<b class="fc">&nbsp;						NonSimpleResult.Reason.Clustering, indices.get(i - 1),</b>
<b class="fc">&nbsp;						indices.get(i));</b>
<b class="fc">&nbsp;				return 0;// points are coincident-simplify.</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return 2;</b>
&nbsp;	}
&nbsp;
&nbsp;	int polylineIsSimpleAsFeature_() {
<b class="fc">&nbsp;		if (!checkStructure_())</b>
<b class="fc">&nbsp;			return 0;</b>
&nbsp;		// Non planar IsSimple.
&nbsp;		// Go through all line segments and make sure no line segments are
&nbsp;		// degenerate.
&nbsp;		// Degenerate segment is the one which has its length shorter than
&nbsp;		// tolerance or Z projection shorter than z tolerance.
<b class="fc">&nbsp;		return checkDegenerateSegments_(true) ? 2 : 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	int polygonIsSimpleAsFeature_() {
<b class="fc">&nbsp;		return isSimplePlanarImpl_();</b>
&nbsp;	}
&nbsp;
&nbsp;	MultiPoint multiPointSimplifyAsFeature_() {
<b class="fc">&nbsp;		MultiVertexGeometryImpl multiVertexImpl = (MultiVertexGeometryImpl) m_geometry</b>
<b class="fc">&nbsp;				._getImpl();</b>
&nbsp;		// sort lexicographically:by y,then by x,then by other attributes in the
&nbsp;		// order.
<b class="fc">&nbsp;		int pointCount = multiVertexImpl.getPointCount();</b>
<b class="fc">&nbsp;		assert (pointCount &gt; 0);</b>
&nbsp;
<b class="fc">&nbsp;		AttributeStreamOfInt32 indices = new AttributeStreamOfInt32(0);</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			indices.add(i);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		indices.Sort(0, pointCount, new MultiPointVertexComparer2(this));</b>
&nbsp;
&nbsp;		// Mark vertices that are unique
<b class="fc">&nbsp;		boolean[] indicesOut = new boolean[pointCount];</b>
&nbsp;
<b class="fc">&nbsp;		indicesOut[indices.get(0)] = true;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 1; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			int ind1 = indices.get(i - 1);</b>
<b class="fc">&nbsp;			int ind2 = indices.get(i);</b>
<b class="fc">&nbsp;			if (compareVerticesMultiPoint_(ind1, ind2) == 0) {</b>
<b class="fc">&nbsp;				indicesOut[ind2] = false;</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			indicesOut[ind2] = true;</b>
&nbsp;		}
&nbsp;
&nbsp;		// get rid of non-unique vertices.
&nbsp;		// We preserve the order of MultiPoint vertices.Among duplicate
&nbsp;		// vertices,those that have
&nbsp;		// higher index are deleted.
<b class="fc">&nbsp;		MultiPoint dst = (MultiPoint) m_geometry.createInstance();</b>
<b class="fc">&nbsp;		MultiPoint src = (MultiPoint) m_geometry;</b>
<b class="fc">&nbsp;		int istart = 0;</b>
<b class="fc">&nbsp;		int iend = 1;</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			if (indicesOut[i])</b>
<b class="fc">&nbsp;				iend = i + 1;</b>
&nbsp;			else {
<b class="fc">&nbsp;				if (istart &lt; iend) {</b>
<b class="fc">&nbsp;					dst.add(src, istart, iend);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				istart = i + 1;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (istart &lt; iend) {</b>
<b class="fc">&nbsp;			dst.add(src, istart, iend);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		((MultiVertexGeometryImpl) dst._getImpl()).setIsSimple(</b>
&nbsp;				GeometryXSimple.Strong, m_toleranceSimplify, false);
<b class="fc">&nbsp;		return dst;</b>
&nbsp;	}
&nbsp;
&nbsp;	Polyline polylineSimplifyAsFeature_() {
&nbsp;		// Non planar simplify.
&nbsp;		// Go through all line segments and make sure no line segments are
&nbsp;		// degenerate.
&nbsp;		// Degenerate segment is the one which has its length shorter than
&nbsp;		// tolerance or Z projection shorter than z tolerance.
&nbsp;		// The algorithm processes each path symmetrically from each end to
&nbsp;		// ensure the result of simplify does not depend on the direction of the
&nbsp;		// path.
&nbsp;
<b class="fc">&nbsp;		MultiPathImpl multiPathImpl = (MultiPathImpl) m_geometry._getImpl();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterFwd = multiPathImpl.querySegmentIterator();</b>
<b class="fc">&nbsp;		SegmentIteratorImpl segIterBwd = multiPathImpl.querySegmentIterator();</b>
<b class="fc">&nbsp;		Polyline dst = (Polyline) m_geometry.createInstance();</b>
<b class="fc">&nbsp;		Polyline src = (Polyline) m_geometry;</b>
&nbsp;		// Envelope2D env2D;
<b class="fc">&nbsp;		boolean bHasZ = multiPathImpl</b>
<b class="fc">&nbsp;				.hasAttribute(VertexDescription.Semantics.Z);</b>
<b class="fc">&nbsp;		double ztolerance = !bHasZ ? 0.0 : InternalUtils</b>
<b class="nc">&nbsp;				.calculateZToleranceFromGeometry(m_sr, multiPathImpl, true);</b>
<b class="fc">&nbsp;		AttributeStreamOfInt32 fwdStack = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		AttributeStreamOfInt32 bwdStack = new AttributeStreamOfInt32(0);</b>
<b class="fc">&nbsp;		fwdStack.reserve(multiPathImpl.getPointCount() / 2 + 1);</b>
<b class="fc">&nbsp;		bwdStack.reserve(multiPathImpl.getPointCount() / 2 + 1);</b>
<b class="fc">&nbsp;		while (segIterFwd.nextPath()) {</b>
<b class="fc">&nbsp;			segIterBwd.nextPath();</b>
<b class="fc">&nbsp;			if (multiPathImpl.getPathSize(segIterFwd.getPathIndex()) &lt; 2)</b>
<b class="fc">&nbsp;				continue;</b>
&nbsp;
<b class="fc">&nbsp;			segIterBwd.resetToLastSegment();</b>
<b class="fc">&nbsp;			double lengthFwd = 0;</b>
<b class="fc">&nbsp;			double lengthBwd = 0;</b>
<b class="fc">&nbsp;			boolean bFirst = true;</b>
<b class="fc">&nbsp;			while (segIterFwd.hasNextSegment()) {</b>
<b class="fc">&nbsp;				assert (segIterBwd.hasPreviousSegment());</b>
&nbsp;
<b class="fc">&nbsp;				/* const */Segment segFwd = segIterFwd.nextSegment();</b>
<b class="fc">&nbsp;				/* const */Segment segBwd = segIterBwd.previousSegment();</b>
&nbsp;
<b class="fc">&nbsp;				int idx1 = segIterFwd.getStartPointIndex();</b>
<b class="fc">&nbsp;				int idx2 = segIterBwd.getStartPointIndex();</b>
<b class="fc">&nbsp;				if (idx1 &gt; idx2)</b>
<b class="fc">&nbsp;					break;</b>
&nbsp;
<b class="fc">&nbsp;				if (bFirst) {</b>
&nbsp;					// add the very first and the very last point indices
<b class="fc">&nbsp;					fwdStack.add(segIterFwd.getStartPointIndex());// first goes</b>
&nbsp;																	// to
&nbsp;																	// fwdStack
<b class="fc">&nbsp;					bwdStack.add(segIterBwd.getEndPointIndex());// last goes to</b>
&nbsp;																// bwdStack
<b class="fc">&nbsp;					bFirst = false;</b>
&nbsp;				}
&nbsp;
&nbsp;				{
<b class="fc">&nbsp;					int index0 = fwdStack.getLast();</b>
<b class="fc">&nbsp;					int index1 = segIterFwd.getEndPointIndex();</b>
<b class="fc">&nbsp;					if (index1 - index0 &gt; 1) {</b>
<b class="nc">&nbsp;						Point2D pt = new Point2D();</b>
<b class="nc">&nbsp;						pt.sub(multiPathImpl.getXY(index0),</b>
<b class="nc">&nbsp;								multiPathImpl.getXY(index1));</b>
<b class="nc">&nbsp;						lengthFwd = pt.length();</b>
<b class="nc">&nbsp;					} else {</b>
<b class="fc">&nbsp;						lengthFwd = segFwd.calculateLength2D();</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				{
<b class="fc">&nbsp;					int index0 = bwdStack.getLast();</b>
<b class="fc">&nbsp;					int index1 = segIterBwd.getStartPointIndex();</b>
<b class="fc">&nbsp;					if (index1 - index0 &gt; 1) {</b>
<b class="nc">&nbsp;						Point2D pt = new Point2D();</b>
<b class="nc">&nbsp;						pt.sub(multiPathImpl.getXY(index0),</b>
<b class="nc">&nbsp;								multiPathImpl.getXY(index1));</b>
<b class="nc">&nbsp;						lengthBwd = pt.length();</b>
<b class="nc">&nbsp;					} else {</b>
<b class="fc">&nbsp;						lengthBwd = segBwd.calculateLength2D();</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (lengthFwd &gt; m_toleranceSimplify) {</b>
<b class="fc">&nbsp;					fwdStack.add(segIterFwd.getEndPointIndex());</b>
<b class="fc">&nbsp;					lengthFwd = 0;</b>
&nbsp;				} else {
<b class="fc">&nbsp;					if (bHasZ) {</b>
<b class="nc">&nbsp;						double z0 = multiPathImpl.getAttributeAsDbl(</b>
&nbsp;								VertexDescription.Semantics.Z,
<b class="nc">&nbsp;								fwdStack.getLast(), 0);</b>
<b class="nc">&nbsp;						double z1 = segFwd.getEndAttributeAsDbl(</b>
&nbsp;								VertexDescription.Semantics.Z, 0);
<b class="nc">&nbsp;						if (Math.abs(z1 - z0) &gt; ztolerance) {</b>
<b class="nc">&nbsp;							fwdStack.add(segIterFwd.getEndPointIndex());</b>
<b class="nc">&nbsp;							lengthFwd = 0;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (lengthBwd &gt; m_toleranceSimplify) {</b>
<b class="fc">&nbsp;					bwdStack.add(segIterBwd.getStartPointIndex());</b>
<b class="fc">&nbsp;					lengthBwd = 0;</b>
&nbsp;				} else {
<b class="fc">&nbsp;					if (bHasZ) {</b>
<b class="nc">&nbsp;						double z0 = multiPathImpl.getAttributeAsDbl(</b>
&nbsp;								VertexDescription.Semantics.Z,
<b class="nc">&nbsp;								bwdStack.getLast(), 0);</b>
<b class="nc">&nbsp;						double z1 = segBwd.getEndAttributeAsDbl(</b>
&nbsp;								VertexDescription.Semantics.Z, 0);
<b class="nc">&nbsp;						if (Math.abs(z1 - z0) &gt; ztolerance) {</b>
<b class="nc">&nbsp;							bwdStack.add(segIterBwd.getStartPointIndex());</b>
<b class="nc">&nbsp;							lengthBwd = 0;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;
&nbsp;			// assert(fwdStack.getLast() &lt;= bwdStack.getLast());
<b class="fc">&nbsp;			if (fwdStack.getLast() &lt; bwdStack.getLast()) {</b>
&nbsp;				// There is degenerate segment in the middle. Remove.
&nbsp;				// If the path degenerate, this will make fwdStack.size() +
&nbsp;				// bwdStack.size() &lt; 2.
<b class="fc">&nbsp;				if (fwdStack.size() &gt; bwdStack.size())</b>
<b class="fc">&nbsp;					fwdStack.removeLast();</b>
&nbsp;				else
<b class="fc">&nbsp;					bwdStack.removeLast();</b>
<b class="fc">&nbsp;			} else if (fwdStack.getLast() == bwdStack.getLast()) {</b>
<b class="fc">&nbsp;				bwdStack.removeLast();</b>
&nbsp;			} else {
<b class="fc">&nbsp;				assert (fwdStack.getLast() - bwdStack.getLast() == 1);</b>
<b class="fc">&nbsp;				bwdStack.removeLast();</b>
<b class="fc">&nbsp;				bwdStack.removeLast();</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (bwdStack.size() + fwdStack.size() &gt;= 2) {</b>
&nbsp;				// Completely ignore the curves for now.
<b class="fc">&nbsp;				Point point = new Point();</b>
<b class="fc">&nbsp;				for (int i = 0, n = fwdStack.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;					src.getPointByVal(fwdStack.get(i), point);</b>
<b class="fc">&nbsp;					if (i == 0)</b>
<b class="fc">&nbsp;						dst.startPath(point);</b>
&nbsp;					else
<b class="fc">&nbsp;						dst.lineTo(point);</b>
&nbsp;				}
&nbsp;
&nbsp;				// int prevIdx = fwdStack.getLast();
<b class="fc">&nbsp;				for (int i = bwdStack.size() - 1; i &gt; 0; i--) {</b>
<b class="fc">&nbsp;					src.getPointByVal(bwdStack.get(i), point);</b>
<b class="fc">&nbsp;					dst.lineTo(point);</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (src.isClosedPath(segIterFwd.getPathIndex())) {</b>
<b class="nc">&nbsp;					dst.closePathWithLine();</b>
&nbsp;				} else {
<b class="fc">&nbsp;					if (bwdStack.size() &gt; 0) {</b>
<b class="fc">&nbsp;						src.getPointByVal(bwdStack.get(0), point);</b>
<b class="fc">&nbsp;						dst.lineTo(point);</b>
&nbsp;					}
&nbsp;				}
&nbsp;			} else {
&nbsp;				// degenerate path won&#39;t be added
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (fwdStack != null)</b>
<b class="fc">&nbsp;				fwdStack.clear(false);</b>
<b class="fc">&nbsp;			if (bwdStack != null)</b>
<b class="fc">&nbsp;				bwdStack.clear(false);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;
<b class="fc">&nbsp;		((MultiVertexGeometryImpl) dst._getImpl()).setIsSimple(</b>
&nbsp;				GeometryXSimple.Strong, m_toleranceSimplify, false);
<b class="fc">&nbsp;		return dst;</b>
&nbsp;	}
&nbsp;
&nbsp;	Polygon polygonSimplifyAsFeature_() {
<b class="fc">&nbsp;		return (Polygon) simplifyPlanar_();</b>
&nbsp;	}
&nbsp;
&nbsp;	MultiVertexGeometry simplifyPlanar_() {
&nbsp;		// do clustering/cracking loop
&nbsp;		// if (false)
&nbsp;		// {
&nbsp;		// ((MultiPathImpl)m_geometry._getImpl()).saveToTextFileDbg(&quot;c:/temp/_simplifyDbg0.txt&quot;);
&nbsp;		// }
&nbsp;
<b class="fc">&nbsp;		if (m_geometry.getType() == Geometry.Type.Polygon) {</b>
<b class="fc">&nbsp;			if (((Polygon) m_geometry).getFillRule() == Polygon.FillRule.enumFillRuleWinding) {</b>
&nbsp;				// when the fill rule is winding, we need to call a special
&nbsp;				// method.
<b class="fc">&nbsp;				return TopologicalOperations.planarSimplify(</b>
&nbsp;						(MultiVertexGeometry) m_geometry, m_toleranceSimplify,
&nbsp;						true, false, m_progressTracker);
&nbsp;			}
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		m_editShape = new EditShape();</b>
<b class="fc">&nbsp;		m_editShape.addGeometry(m_geometry);</b>
&nbsp;
<b class="fc">&nbsp;		if (m_editShape.getTotalPointCount() != 0) {</b>
<b class="fc">&nbsp;			assert (m_knownSimpleResult != GeometryXSimple.Strong);</b>
<b class="fc">&nbsp;			if (m_knownSimpleResult != GeometryXSimple.Weak) {</b>
<b class="fc">&nbsp;				CrackAndCluster.execute(m_editShape, m_toleranceSimplify,</b>
&nbsp;						m_progressTracker, true);
&nbsp;			}
&nbsp;	
<b class="fc">&nbsp;			if (m_geometry.getType().equals(Geometry.Type.Polygon)) {</b>
<b class="fc">&nbsp;				Simplificator.execute(m_editShape, m_editShape.getFirstGeometry(),</b>
&nbsp;						m_knownSimpleResult, false, m_progressTracker);
&nbsp;			}
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		m_geometry = m_editShape.getGeometry(m_editShape.getFirstGeometry()); // extract</b>
&nbsp;																				// the
&nbsp;																				// result
&nbsp;																				// of
&nbsp;																				// simplify
&nbsp;
<b class="fc">&nbsp;		if (m_geometry.getType().equals(Geometry.Type.Polygon)) {</b>
<b class="fc">&nbsp;			((MultiPathImpl)m_geometry._getImpl())._updateOGCFlags();</b>
<b class="fc">&nbsp;			((Polygon)m_geometry).setFillRule(Polygon.FillRule.enumFillRuleOddEven);</b>
&nbsp;		}
&nbsp;
&nbsp;		// We have simplified the geometry using the given tolerance. Now mark
&nbsp;		// the geometry as strong simple,
&nbsp;		// So that the next call will not have to repeat these steps.
&nbsp;
<b class="fc">&nbsp;		((MultiVertexGeometryImpl) m_geometry._getImpl()).setIsSimple(</b>
&nbsp;				GeometryXSimple.Strong, m_toleranceSimplify, false);
&nbsp;
<b class="fc">&nbsp;		return (MultiVertexGeometry) (m_geometry);</b>
&nbsp;	}
&nbsp;
&nbsp;	NonSimpleResult m_nonSimpleResult;
&nbsp;
&nbsp;	OperatorSimplifyLocalHelper(Geometry geometry,
&nbsp;			SpatialReference spatialReference, int knownSimpleResult,
<b class="fc">&nbsp;			ProgressTracker progressTracker, boolean bOGCRestrictions) {</b>
&nbsp;
<b class="fc">&nbsp;		m_description = geometry.getDescription();</b>
<b class="fc">&nbsp;		m_geometry = geometry;</b>
<b class="fc">&nbsp;		m_sr = (SpatialReferenceImpl) spatialReference;</b>
<b class="fc">&nbsp;		m_dbgCounter = 0;</b>
<b class="fc">&nbsp;		m_toleranceIsSimple = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				m_sr, geometry, false);
<b class="fc">&nbsp;		m_toleranceSimplify = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				m_sr, geometry, true);
&nbsp;		// m_toleranceCluster = m_toleranceSimplify * Math.sqrt(2.0) * 1.00001;
<b class="fc">&nbsp;		m_knownSimpleResult = knownSimpleResult;</b>
<b class="fc">&nbsp;		m_attributeCount = m_description.getAttributeCount();</b>
<b class="fc">&nbsp;		m_edges = new ArrayList&lt;Edge&gt;();</b>
<b class="fc">&nbsp;		m_lineEdgesRecycle = new ArrayList&lt;Edge&gt;();</b>
<b class="fc">&nbsp;		m_crossOverHelperList = new IndexMultiDCList();</b>
<b class="fc">&nbsp;		m_AET = new Treap();</b>
<b class="fc">&nbsp;		m_nonSimpleResult = new NonSimpleResult();</b>
<b class="fc">&nbsp;		m_bOGCRestrictions = bOGCRestrictions;</b>
<b class="fc">&nbsp;		m_bPlanarSimplify = m_bOGCRestrictions;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns 0 non-simple, 1 weak simple, 2 strong simple
&nbsp;	/**
&nbsp;	 * The code is executed in the 2D plane only.Attributes are ignored.
&nbsp;	 * MultiPoint-check for clustering. Polyline -check for clustering and
&nbsp;	 * cracking. Polygon -check for clustering,cracking,absence of
&nbsp;	 * self-intersections,and correct ring ordering.
&nbsp;	 */
&nbsp;	static protected int isSimplePlanar(/* const */Geometry geometry, /* const */
&nbsp;	SpatialReference spatialReference, boolean bForce,
&nbsp;			ProgressTracker progressTracker) {
<b class="nc">&nbsp;		assert (false); // this code is not called yet.</b>
<b class="nc">&nbsp;		if (geometry.isEmpty())</b>
<b class="nc">&nbsp;			return 1;</b>
<b class="nc">&nbsp;		Geometry.Type gt = geometry.getType();</b>
<b class="nc">&nbsp;		if (gt == Geometry.Type.Point)</b>
<b class="nc">&nbsp;			return 1;</b>
<b class="nc">&nbsp;		else if (gt == Geometry.Type.Envelope) {</b>
<b class="nc">&nbsp;			Envelope2D env2D = new Envelope2D();</b>
<b class="nc">&nbsp;			geometry.queryEnvelope2D(env2D);</b>
<b class="nc">&nbsp;			boolean bReturnValue = !env2D.isDegenerate(InternalUtils</b>
<b class="nc">&nbsp;					.calculateToleranceFromGeometry(spatialReference, geometry,</b>
&nbsp;							false));
<b class="nc">&nbsp;			return bReturnValue ? 1 : 0;</b>
<b class="nc">&nbsp;		} else if (Geometry.isSegment(gt.value())) {</b>
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;			// return seg.IsSimple(m_tolerance);
<b class="nc">&nbsp;		} else if (!Geometry.isMultiVertex(gt.value())) {</b>
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();// What else?</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				spatialReference, geometry, false);
&nbsp;
<b class="nc">&nbsp;		double geomTolerance = 0;</b>
<b class="nc">&nbsp;		int isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())</b>
<b class="nc">&nbsp;				.getIsSimple(tolerance);</b>
<b class="nc">&nbsp;		int knownSimpleResult = bForce ? -1 : isSimple;</b>
&nbsp;		// TODO: need to distinguish KnownSimple between SimpleAsFeature and
&nbsp;		// SimplePlanar. The SimplePlanar implies SimpleAsFeature.
<b class="nc">&nbsp;		if (knownSimpleResult != -1)</b>
<b class="nc">&nbsp;			return knownSimpleResult;</b>
&nbsp;
<b class="nc">&nbsp;		if (knownSimpleResult == GeometryXSimple.Weak) {</b>
<b class="nc">&nbsp;			assert (tolerance &lt;= geomTolerance);</b>
<b class="nc">&nbsp;			tolerance = geomTolerance;// OVERRIDE the tolerance.</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		OperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(</b>
&nbsp;				geometry, spatialReference, knownSimpleResult, progressTracker,
&nbsp;				false);
<b class="nc">&nbsp;		knownSimpleResult = helper.isSimplePlanarImpl_();</b>
<b class="nc">&nbsp;		((MultiVertexGeometryImpl) geometry._getImpl()).setIsSimple(</b>
&nbsp;				knownSimpleResult, tolerance, false);
<b class="nc">&nbsp;		return knownSimpleResult;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Checks if Geometry is simple for storing in DB:
&nbsp;	 * 
&nbsp;	 * MultiPoint:check that no points coincide.tolerance is ignored.
&nbsp;	 * Polyline:ensure there no segments degenerate segments. Polygon:Same as
&nbsp;	 * IsSimplePlanar.
&nbsp;	 */
&nbsp;	static protected int isSimpleAsFeature(/* const */Geometry geometry, /* const */
&nbsp;	SpatialReference spatialReference, boolean bForce, NonSimpleResult result,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		if (result != null) {</b>
<b class="fc">&nbsp;			result.m_reason = NonSimpleResult.Reason.NotDetermined;</b>
<b class="fc">&nbsp;			result.m_vertexIndex1 = -1;</b>
<b class="fc">&nbsp;			result.m_vertexIndex2 = -1;</b>
&nbsp;		}
<b class="fc">&nbsp;		if (geometry.isEmpty())</b>
<b class="fc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		Geometry.Type gt = geometry.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Point)</b>
<b class="fc">&nbsp;			return 1;</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				spatialReference, geometry, false);
<b class="fc">&nbsp;		if (gt == Geometry.Type.Envelope) {</b>
<b class="fc">&nbsp;			/* const */Envelope env = (Envelope) geometry;</b>
<b class="fc">&nbsp;			Envelope2D env2D = new Envelope2D();</b>
<b class="fc">&nbsp;			env.queryEnvelope2D(env2D);</b>
<b class="fc">&nbsp;			if (env2D.isDegenerate(tolerance)) {</b>
<b class="fc">&nbsp;				if (result != null) {</b>
<b class="nc">&nbsp;					result.m_reason = NonSimpleResult.Reason.DegenerateSegments;</b>
<b class="nc">&nbsp;					result.m_vertexIndex1 = -1;</b>
<b class="nc">&nbsp;					result.m_vertexIndex2 = -1;</b>
&nbsp;				}
<b class="fc">&nbsp;				return 0;</b>
&nbsp;			}
<b class="fc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		} else if (Geometry.isSegment(gt.value())) {</b>
<b class="fc">&nbsp;			/* const */Segment seg = (Segment) geometry;</b>
<b class="fc">&nbsp;			Polyline polyline = new Polyline(seg.getDescription());</b>
<b class="fc">&nbsp;			polyline.addSegment(seg, true);</b>
<b class="fc">&nbsp;			return isSimpleAsFeature(polyline, spatialReference, bForce,</b>
&nbsp;					result, progressTracker);
&nbsp;		}
&nbsp;
&nbsp;		// double geomTolerance = 0;
<b class="fc">&nbsp;		int isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())</b>
<b class="fc">&nbsp;				.getIsSimple(tolerance);</b>
<b class="fc">&nbsp;		int knownSimpleResult = bForce ? -1 : isSimple;</b>
&nbsp;		// TODO: need to distinguish KnownSimple between SimpleAsFeature and
&nbsp;		// SimplePlanar.
&nbsp;		// From the first sight it seems the SimplePlanar implies
&nbsp;		// SimpleAsFeature.
<b class="fc">&nbsp;		if (knownSimpleResult != -1)</b>
<b class="fc">&nbsp;			return knownSimpleResult;</b>
&nbsp;
<b class="fc">&nbsp;		OperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(</b>
&nbsp;				geometry, spatialReference, knownSimpleResult, progressTracker,
&nbsp;				false);
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.Type.MultiPoint) {</b>
<b class="fc">&nbsp;			knownSimpleResult = helper.multiPointIsSimpleAsFeature_();</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.Type.Polyline) {</b>
<b class="fc">&nbsp;			knownSimpleResult = helper.polylineIsSimpleAsFeature_();</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.Type.Polygon) {</b>
<b class="fc">&nbsp;			knownSimpleResult = helper.polygonIsSimpleAsFeature_();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();// what else?</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		((MultiVertexGeometryImpl) (geometry._getImpl())).setIsSimple(</b>
&nbsp;				knownSimpleResult, tolerance, false);
<b class="fc">&nbsp;		if (result != null &amp;&amp; knownSimpleResult == 0)</b>
<b class="fc">&nbsp;			result.Assign(helper.m_nonSimpleResult);</b>
<b class="fc">&nbsp;		return knownSimpleResult;</b>
&nbsp;	}
&nbsp;
&nbsp;	static int isSimpleOGC(/* const */Geometry geometry, /* const */
&nbsp;	SpatialReference spatialReference, boolean bForce, NonSimpleResult result,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		if (result != null) {</b>
<b class="fc">&nbsp;			result.m_reason = NonSimpleResult.Reason.NotDetermined;</b>
<b class="fc">&nbsp;			result.m_vertexIndex1 = -1;</b>
<b class="fc">&nbsp;			result.m_vertexIndex2 = -1;</b>
&nbsp;		}
<b class="fc">&nbsp;		if (geometry.isEmpty())</b>
<b class="nc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		Geometry.Type gt = geometry.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Point)</b>
<b class="nc">&nbsp;			return 1;</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				spatialReference, geometry, false);
<b class="fc">&nbsp;		if (gt == Geometry.Type.Envelope) {</b>
<b class="nc">&nbsp;			/* const */Envelope env = (Envelope) geometry;</b>
<b class="nc">&nbsp;			Envelope2D env2D = new Envelope2D();</b>
<b class="nc">&nbsp;			env.queryEnvelope2D(env2D);</b>
<b class="nc">&nbsp;			if (env2D.isDegenerate(tolerance)) {</b>
<b class="nc">&nbsp;				if (result != null) {</b>
<b class="nc">&nbsp;					result.m_reason = NonSimpleResult.Reason.DegenerateSegments;</b>
<b class="nc">&nbsp;					result.m_vertexIndex1 = -1;</b>
<b class="nc">&nbsp;					result.m_vertexIndex2 = -1;</b>
&nbsp;				}
<b class="nc">&nbsp;				return 0;</b>
&nbsp;			}
<b class="nc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		} else if (Geometry.isSegment(gt.value())) {</b>
<b class="nc">&nbsp;			/* const */Segment seg = (Segment) geometry;</b>
<b class="nc">&nbsp;			Polyline polyline = new Polyline(seg.getDescription());</b>
<b class="nc">&nbsp;			polyline.addSegment(seg, true);</b>
<b class="nc">&nbsp;			return isSimpleAsFeature(polyline, spatialReference, bForce,</b>
&nbsp;					result, progressTracker);
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int knownSimpleResult = -1;</b>
&nbsp;
<b class="fc">&nbsp;		OperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(</b>
&nbsp;				geometry, spatialReference, knownSimpleResult, progressTracker,
&nbsp;				true);
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.Type.MultiPoint || gt == Geometry.Type.Polyline</b>
&nbsp;				|| gt == Geometry.Type.Polygon) {
<b class="fc">&nbsp;			knownSimpleResult = helper.isSimplePlanarImpl_();</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();// what else?</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (result != null)</b>
<b class="fc">&nbsp;			result.Assign(helper.m_nonSimpleResult);</b>
&nbsp;
<b class="fc">&nbsp;		return knownSimpleResult;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Simplifies geometries for storing in DB:
&nbsp;	 * 
&nbsp;	 * MultiPoint:check that no points coincide.tolerance is ignored.
&nbsp;	 * Polyline:ensure there no segments degenerate segments. Polygon:cracks and
&nbsp;	 * clusters using cluster tolerance and resolves all self intersections,
&nbsp;	 * orients rings properly and arranges the rings in the OGC order.
&nbsp;	 * 
&nbsp;	 * Returns simplified geometry.
&nbsp;	 */
&nbsp;	static protected Geometry simplifyAsFeature(/* const */Geometry geometry, /* const */
&nbsp;	SpatialReference spatialReference, boolean bForce,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		if (geometry.isEmpty())</b>
<b class="fc">&nbsp;			return geometry;</b>
<b class="fc">&nbsp;		Geometry.Type gt = geometry.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Point)</b>
<b class="nc">&nbsp;			return geometry;</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				spatialReference, geometry, false);
<b class="fc">&nbsp;		if (gt == Geometry.Type.Envelope) {</b>
<b class="nc">&nbsp;			Envelope env = (Envelope) geometry;</b>
<b class="nc">&nbsp;			Envelope2D env2D = new Envelope2D();</b>
<b class="nc">&nbsp;			env.queryEnvelope2D(env2D);</b>
<b class="nc">&nbsp;			if (env2D.isDegenerate(tolerance)) {</b>
<b class="nc">&nbsp;				return (Geometry) (env.createInstance()); // return empty</b>
&nbsp;															// geometry
&nbsp;			}
<b class="nc">&nbsp;			return geometry;</b>
<b class="fc">&nbsp;		} else if (Geometry.isSegment(gt.value())) {</b>
<b class="nc">&nbsp;			Segment seg = (Segment) geometry;</b>
<b class="nc">&nbsp;			Polyline polyline = new Polyline(seg.getDescription());</b>
<b class="nc">&nbsp;			polyline.addSegment(seg, true);</b>
<b class="nc">&nbsp;			return simplifyAsFeature(polyline, spatialReference, bForce,</b>
&nbsp;					progressTracker);
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		double geomTolerance = 0;</b>
<b class="fc">&nbsp;		int isSimple = ((MultiVertexGeometryImpl) geometry._getImpl())</b>
<b class="fc">&nbsp;				.getIsSimple(tolerance);</b>
<b class="fc">&nbsp;		int knownSimpleResult = bForce ? GeometryXSimple.Unknown : isSimple;</b>
&nbsp;
&nbsp;		// TODO: need to distinguish KnownSimple between SimpleAsFeature and
&nbsp;		// SimplePlanar.
&nbsp;		// From the first sight it seems the SimplePlanar implies
&nbsp;		// SimpleAsFeature.
<b class="fc">&nbsp;		if (knownSimpleResult == GeometryXSimple.Strong) {</b>
<b class="fc">&nbsp;	        if (gt == Geometry.Type.Polygon &amp;&amp; ((Polygon)geometry).getFillRule() != Polygon.FillRule.enumFillRuleOddEven)</b>
&nbsp;	        {
<b class="nc">&nbsp;	          Geometry res = geometry.copy();</b>
<b class="nc">&nbsp;	          ((Polygon)res).setFillRule(Polygon.FillRule.enumFillRuleOddEven);//standardize on odd_even fill rule</b>
<b class="nc">&nbsp;	          return res;</b>
&nbsp;	        }			
&nbsp;	        
<b class="fc">&nbsp;			return geometry;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		OperatorSimplifyLocalHelper helper = new OperatorSimplifyLocalHelper(</b>
&nbsp;				geometry, spatialReference, knownSimpleResult, progressTracker,
&nbsp;				false);
&nbsp;
&nbsp;		Geometry result;
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.Type.MultiPoint) {</b>
<b class="fc">&nbsp;			result = (Geometry) (helper.multiPointSimplifyAsFeature_());</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.Type.Polyline) {</b>
<b class="fc">&nbsp;			result = (Geometry) (helper.polylineSimplifyAsFeature_());</b>
<b class="fc">&nbsp;		} else if (gt == Geometry.Type.Polygon) {</b>
<b class="fc">&nbsp;			result = (Geometry) (helper.polygonSimplifyAsFeature_());</b>
&nbsp;		} else {
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError(); // what else?</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Simplifies geometries for storing in OGC format:
&nbsp;	 * 
&nbsp;	 * MultiPoint:check that no points coincide.tolerance is ignored.
&nbsp;	 * Polyline:ensure there no segments degenerate segments. Polygon:cracks and
&nbsp;	 * clusters using cluster tolerance and resolves all self intersections,
&nbsp;	 * orients rings properly and arranges the rings in the OGC order.
&nbsp;	 * 
&nbsp;	 * Returns simplified geometry.
&nbsp;	 */
&nbsp;	static Geometry simplifyOGC(/* const */Geometry geometry, /* const */
&nbsp;	SpatialReference spatialReference, boolean bForce,
&nbsp;			ProgressTracker progressTracker) {
<b class="fc">&nbsp;		if (geometry.isEmpty())</b>
<b class="nc">&nbsp;			return geometry;</b>
<b class="fc">&nbsp;		Geometry.Type gt = geometry.getType();</b>
<b class="fc">&nbsp;		if (gt == Geometry.Type.Point)</b>
<b class="nc">&nbsp;			return geometry;</b>
&nbsp;
<b class="fc">&nbsp;		double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;				spatialReference, geometry, false);
<b class="fc">&nbsp;		if (gt == Geometry.Type.Envelope) {</b>
<b class="nc">&nbsp;			Envelope env = (Envelope) geometry;</b>
<b class="nc">&nbsp;			Envelope2D env2D = new Envelope2D();</b>
<b class="nc">&nbsp;			env.queryEnvelope2D(env2D);</b>
<b class="nc">&nbsp;			if (env2D.isDegenerate(tolerance)) {</b>
<b class="nc">&nbsp;				return (Geometry) (env.createInstance()); // return empty</b>
&nbsp;															// geometry
&nbsp;			}
<b class="nc">&nbsp;			return geometry;</b>
<b class="fc">&nbsp;		} else if (Geometry.isSegment(gt.value())) {</b>
<b class="nc">&nbsp;			Segment seg = (Segment) geometry;</b>
<b class="nc">&nbsp;			Polyline polyline = new Polyline(seg.getDescription());</b>
<b class="nc">&nbsp;			polyline.addSegment(seg, true);</b>
<b class="nc">&nbsp;			return simplifyOGC(polyline, spatialReference, bForce,</b>
&nbsp;					progressTracker);
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (!Geometry.isMultiVertex(gt.value())) {</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;OGC simplify is not implemented for this geometry type&quot; + gt);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiVertexGeometry result = TopologicalOperations.simplifyOGC(</b>
&nbsp;				(MultiVertexGeometry) geometry, tolerance, false, progressTracker);
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int compareVertices_(int i1, int i2, boolean get_paths) {
<b class="fc">&nbsp;		if (i1 == i2)</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;
<b class="fc">&nbsp;		int pair1 = m_pairs.get(i1);</b>
<b class="fc">&nbsp;		int pair2 = m_pairs.get(i2);</b>
<b class="fc">&nbsp;		int xy1 = pair1 &gt;&gt; 1;</b>
<b class="fc">&nbsp;		int xy2 = pair2 &gt;&gt; 1;</b>
<b class="fc">&nbsp;		Point2D pt1 = new Point2D();</b>
<b class="fc">&nbsp;		Point2D pt2 = new Point2D();</b>
<b class="fc">&nbsp;		m_xy.read(2 * xy1, pt1);</b>
<b class="fc">&nbsp;		pt1.y += (((pair1 &amp; 1) != 0) ? m_toleranceIsSimple</b>
<b class="fc">&nbsp;				: -m_toleranceIsSimple);</b>
<b class="fc">&nbsp;		m_xy.read(2 * xy2, pt2);</b>
<b class="fc">&nbsp;		pt2.y += (((pair2 &amp; 1) != 0) ? m_toleranceIsSimple</b>
<b class="fc">&nbsp;				: -m_toleranceIsSimple);</b>
<b class="fc">&nbsp;		int res = pt1.compare(pt2);</b>
<b class="fc">&nbsp;		if (res == 0 &amp;&amp; get_paths) {</b>
<b class="fc">&nbsp;			int di = m_paths_for_OGC_tests.get(xy1)</b>
<b class="fc">&nbsp;					- m_paths_for_OGC_tests.get(xy2);</b>
<b class="fc">&nbsp;			return di &lt; 0 ? -1 : di &gt; 0 ? 1 : 0;</b>
&nbsp;		}
<b class="fc">&nbsp;		return res;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static final class VertexComparer extends
&nbsp;			AttributeStreamOfInt32.IntComparator {
&nbsp;		OperatorSimplifyLocalHelper parent;
&nbsp;		boolean get_paths;
&nbsp;
<b class="fc">&nbsp;		VertexComparer(OperatorSimplifyLocalHelper parent_, boolean get_paths_) {</b>
<b class="fc">&nbsp;			parent = parent_;</b>
<b class="fc">&nbsp;			get_paths = get_paths_;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(int i1, int i2) {
<b class="fc">&nbsp;			return parent.compareVertices_(i1, i2, get_paths);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static final class IndexSorter extends ClassicSort {
&nbsp;		OperatorSimplifyLocalHelper parent;
&nbsp;		private boolean get_paths;
<b class="fc">&nbsp;		private Point2D pt1_dummy = new Point2D();</b>
&nbsp;
<b class="fc">&nbsp;		IndexSorter(OperatorSimplifyLocalHelper parent_, boolean get_paths_) {</b>
<b class="fc">&nbsp;			parent = parent_;</b>
<b class="fc">&nbsp;			get_paths = get_paths_;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public void userSort(int begin, int end, AttributeStreamOfInt32 indices) {
<b class="fc">&nbsp;			indices.Sort(begin, end, new VertexComparer(parent, get_paths));</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public double getValue(int index) /* const */
&nbsp;		{
<b class="fc">&nbsp;			int pair = parent.m_pairs.get(index);</b>
<b class="fc">&nbsp;			int xy1 = pair &gt;&gt; 1;</b>
<b class="fc">&nbsp;			parent.m_xy.read(2 * xy1, pt1_dummy);</b>
<b class="fc">&nbsp;			double y = pt1_dummy.y</b>
<b class="fc">&nbsp;					+ (((pair &amp; 1) != 0) ? parent.m_toleranceIsSimple</b>
<b class="fc">&nbsp;							: -parent.m_toleranceIsSimple);</b>
<b class="fc">&nbsp;			return y;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private int compareVerticesMultiPoint_(int i1, int i2) {
<b class="fc">&nbsp;		if (i1 == i2)</b>
<b class="nc">&nbsp;			return 0;</b>
<b class="fc">&nbsp;		MultiVertexGeometryImpl multiVertexImpl = (MultiVertexGeometryImpl) m_geometry</b>
<b class="fc">&nbsp;				._getImpl();</b>
<b class="fc">&nbsp;		Point2D pt1 = multiVertexImpl.getXY(i1);</b>
<b class="fc">&nbsp;		Point2D pt2 = multiVertexImpl.getXY(i2);</b>
&nbsp;
<b class="fc">&nbsp;		if (pt1.x &lt; pt2.x)</b>
<b class="fc">&nbsp;			return -1;</b>
<b class="fc">&nbsp;		if (pt1.x &gt; pt2.x)</b>
<b class="fc">&nbsp;			return 1;</b>
<b class="fc">&nbsp;		if (pt1.y &lt; pt2.y)</b>
<b class="fc">&nbsp;			return -1;</b>
<b class="fc">&nbsp;		if (pt1.y &gt; pt2.y)</b>
<b class="fc">&nbsp;			return 1;</b>
&nbsp;
<b class="fc">&nbsp;		for (int attrib = 1; attrib &lt; m_attributeCount; attrib++) {</b>
<b class="nc">&nbsp;			int semantics = m_description.getSemantics(attrib);</b>
<b class="nc">&nbsp;			int nords = VertexDescription.getComponentCount(semantics);</b>
<b class="nc">&nbsp;			for (int ord = 0; ord &lt; nords; ord++) {</b>
<b class="nc">&nbsp;				double v1 = multiVertexImpl.getAttributeAsDbl(semantics, i1,</b>
&nbsp;						ord);
<b class="nc">&nbsp;				double v2 = multiVertexImpl.getAttributeAsDbl(semantics, i2,</b>
&nbsp;						ord);
<b class="nc">&nbsp;				if (v1 &lt; v2)</b>
<b class="nc">&nbsp;					return -1;</b>
<b class="nc">&nbsp;				if (v1 &gt; v2)</b>
<b class="nc">&nbsp;					return 1;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	private int compareVerticesMultiPoint2_(int i1, int i2) {
<b class="fc">&nbsp;		int res = compareVerticesMultiPoint_(i1, i2);</b>
<b class="fc">&nbsp;		if (res == 0)</b>
<b class="fc">&nbsp;			return i1 &lt; i2 ? -1 : 1;</b>
&nbsp;		else
<b class="fc">&nbsp;			return res;</b>
&nbsp;	}
&nbsp;
&nbsp;	private static final class EdgeComparerForSelfIntersection implements
&nbsp;			Comparator&lt;Edge&gt; {
&nbsp;		OperatorSimplifyLocalHelper parent;
&nbsp;
<b class="fc">&nbsp;		EdgeComparerForSelfIntersection(OperatorSimplifyLocalHelper parent_) {</b>
<b class="fc">&nbsp;			parent = parent_;</b>
&nbsp;		}
&nbsp;
&nbsp;		// Recall that the total ordering [&lt;] induced by compare satisfies e1
&nbsp;		// [&lt;] e2 if and only if compare(e1, e2) &lt; 0.
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(Edge e1, Edge e2) {
<b class="fc">&nbsp;			return parent.edgeAngleCompare_(e1, e2);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static final class MultiPointVertexComparer extends
&nbsp;			AttributeStreamOfInt32.IntComparator {
&nbsp;		OperatorSimplifyLocalHelper parent;
&nbsp;
<b class="fc">&nbsp;		MultiPointVertexComparer(OperatorSimplifyLocalHelper parent_) {</b>
<b class="fc">&nbsp;			parent = parent_;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(int i1, int i2) {
<b class="fc">&nbsp;			return parent.compareVerticesMultiPoint_(i1, i2);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private static final class MultiPointVertexComparer2 extends
&nbsp;			AttributeStreamOfInt32.IntComparator {
&nbsp;		OperatorSimplifyLocalHelper parent;
&nbsp;
<b class="fc">&nbsp;		MultiPointVertexComparer2(OperatorSimplifyLocalHelper parent_) {</b>
<b class="fc">&nbsp;			parent = parent_;</b>
&nbsp;		}
&nbsp;
&nbsp;		@Override
&nbsp;		public int compare(int i1, int i2) {
<b class="fc">&nbsp;			return parent.compareVerticesMultiPoint2_(i1, i2);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// compares angles between two edges
&nbsp;	private int edgeAngleCompare_(/* const */Edge edge1, /* const */Edge edge2) {
<b class="fc">&nbsp;		if (edge1.equals(edge2))</b>
<b class="nc">&nbsp;			return 0;</b>
&nbsp;
<b class="fc">&nbsp;		Point2D v1 = edge1.m_segment._getTangent(edge1.getReversed() ? 1.0</b>
<b class="fc">&nbsp;				: 0.0);</b>
<b class="fc">&nbsp;		if (edge1.getReversed())</b>
<b class="fc">&nbsp;			v1.negate();</b>
<b class="fc">&nbsp;		Point2D v2 = edge2.m_segment._getTangent(edge2.getReversed() ? 1.0</b>
<b class="fc">&nbsp;				: 0.0);</b>
<b class="fc">&nbsp;		if (edge2.getReversed())</b>
<b class="fc">&nbsp;			v2.negate();</b>
&nbsp;
<b class="fc">&nbsp;		int q1 = v1._getQuarter();</b>
<b class="fc">&nbsp;		int q2 = v2._getQuarter();</b>
&nbsp;
<b class="fc">&nbsp;		if (q2 == q1) {</b>
<b class="fc">&nbsp;			double cross = v1.crossProduct(v2);</b>
<b class="fc">&nbsp;			double crossError = 4 * NumberUtils.doubleEps()</b>
<b class="fc">&nbsp;					* (Math.abs(v2.x * v1.y) + Math.abs(v2.y * v1.x));</b>
<b class="fc">&nbsp;			if (Math.abs(cross) &lt;= crossError) {</b>
<b class="nc">&nbsp;				cross--; // To avoid warning of &quot;this line has no effect&quot; from</b>
&nbsp;							// cross = cross.
<b class="nc">&nbsp;				cross++;</b>
&nbsp;			}
<b class="fc">&nbsp;			assert (Math.abs(cross) &gt; crossError);</b>
<b class="fc">&nbsp;			return cross &lt; 0 ? 1 : (cross &gt; 0 ? -1 : 0);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			return q1 &lt; q2 ? -1 : 1;</b>
&nbsp;		}
&nbsp;	}
&nbsp;};
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
