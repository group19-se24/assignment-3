


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > OperatorProximity2DLocal</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: OperatorProximity2DLocal (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">OperatorProximity2DLocal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88,1%
  </span>
  <span class="absValue">
    (141/160)
  </span>
</td>
</tr>
  <tr>
    <td class="name">OperatorProximity2DLocal$Side_helper</td>
<td class="coverageStat">
  <span class="percent">
    85,7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (53/106)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    94,1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72,9%
  </span>
  <span class="absValue">
    (194/266)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.VertexDescription.Semantics;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;
<b class="fc">&nbsp;class OperatorProximity2DLocal extends OperatorProximity2D {</b>
&nbsp;
<b class="fc">&nbsp;	class Side_helper {</b>
&nbsp;		int m_i1;
&nbsp;		int m_i2;
&nbsp;		boolean m_bRight1;
&nbsp;		boolean m_bRight2;
&nbsp;
&nbsp;		void reset() {
<b class="fc">&nbsp;			m_i1 = -1;</b>
<b class="fc">&nbsp;			m_i2 = -1;</b>
<b class="fc">&nbsp;			m_bRight1 = false;</b>
<b class="fc">&nbsp;			m_bRight2 = false;</b>
&nbsp;		}
&nbsp;
&nbsp;		int find_non_degenerate(SegmentIterator segIter, int vertexIndex,
&nbsp;				int pathIndex) {
<b class="fc">&nbsp;			segIter.resetToVertex(vertexIndex, pathIndex);</b>
&nbsp;
<b class="fc">&nbsp;			while (segIter.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment = segIter.nextSegment();</b>
<b class="fc">&nbsp;				double length = segment.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				if (length != 0.0)</b>
<b class="fc">&nbsp;					return segIter.getStartPointIndex();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			segIter.resetToVertex(vertexIndex, pathIndex);</b>
&nbsp;
<b class="nc">&nbsp;			while (segIter.hasPreviousSegment()) {</b>
<b class="nc">&nbsp;				Segment segment = segIter.previousSegment();</b>
<b class="nc">&nbsp;				double length = segment.calculateLength2D();</b>
&nbsp;
<b class="nc">&nbsp;				if (length != 0)</b>
<b class="nc">&nbsp;					return segIter.getStartPointIndex();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;
&nbsp;		int find_prev_non_degenerate(SegmentIterator segIter, int index) {
<b class="nc">&nbsp;			segIter.resetToVertex(index, -1);</b>
&nbsp;
<b class="nc">&nbsp;			while (segIter.hasPreviousSegment()) {</b>
<b class="nc">&nbsp;				Segment segment = segIter.previousSegment();</b>
<b class="nc">&nbsp;				double length = segment.calculateLength2D();</b>
&nbsp;
<b class="nc">&nbsp;				if (length != 0)</b>
<b class="nc">&nbsp;					return segIter.getStartPointIndex();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;
&nbsp;		int find_next_non_degenerate(SegmentIterator segIter, int index) {
<b class="fc">&nbsp;			segIter.resetToVertex(index, -1);</b>
<b class="fc">&nbsp;			segIter.nextSegment();</b>
&nbsp;
<b class="fc">&nbsp;			while (segIter.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment = segIter.nextSegment();</b>
<b class="fc">&nbsp;				double length = segment.calculateLength2D();</b>
&nbsp;
<b class="fc">&nbsp;				if (length != 0)</b>
<b class="fc">&nbsp;					return segIter.getStartPointIndex();</b>
<b class="nc">&nbsp;			}</b>
&nbsp;
<b class="nc">&nbsp;			return -1;</b>
&nbsp;		}
&nbsp;
&nbsp;		void find_analysis_pair_from_index(Point2D inputPoint,
&nbsp;				SegmentIterator segIter, int vertexIndex, int pathIndex) {
<b class="fc">&nbsp;			m_i1 = find_non_degenerate(segIter, vertexIndex, pathIndex);</b>
&nbsp;
<b class="fc">&nbsp;			if (m_i1 != -1) {</b>
<b class="fc">&nbsp;				segIter.resetToVertex(m_i1, -1);</b>
<b class="fc">&nbsp;				Segment segment1 = segIter.nextSegment();</b>
<b class="fc">&nbsp;				double t1 = segment1.getClosestCoordinate(inputPoint, false);</b>
<b class="fc">&nbsp;				Point2D p1 = segment1.getCoord2D(t1);</b>
<b class="fc">&nbsp;				double d1 = Point2D.sqrDistance(p1, inputPoint);</b>
<b class="fc">&nbsp;				Point2D pq = new Point2D();</b>
<b class="fc">&nbsp;				pq.setCoords(p1);</b>
<b class="fc">&nbsp;				pq.sub(segment1.getStartXY());</b>
<b class="fc">&nbsp;				Point2D pr = new Point2D();</b>
<b class="fc">&nbsp;				pr.setCoords(inputPoint);</b>
<b class="fc">&nbsp;				pr.sub(segment1.getStartXY());</b>
<b class="fc">&nbsp;				m_bRight1 = (pq.crossProduct(pr) &lt; 0);</b>
&nbsp;
<b class="fc">&nbsp;				m_i2 = find_next_non_degenerate(segIter, m_i1);</b>
<b class="fc">&nbsp;				if (m_i2 != -1) {</b>
<b class="fc">&nbsp;					segIter.resetToVertex(m_i2, -1);</b>
<b class="fc">&nbsp;					Segment segment2 = segIter.nextSegment();</b>
<b class="fc">&nbsp;					double t2 = segment2</b>
<b class="fc">&nbsp;							.getClosestCoordinate(inputPoint, false);</b>
<b class="fc">&nbsp;					Point2D p2 = segment2.getCoord2D(t2);</b>
<b class="fc">&nbsp;					double d2 = Point2D.sqrDistance(p2, inputPoint);</b>
&nbsp;
<b class="fc">&nbsp;					if (d2 &gt; d1) {</b>
<b class="nc">&nbsp;						m_i2 = -1;</b>
&nbsp;					} else {
<b class="fc">&nbsp;						pq.setCoords(p2);</b>
<b class="fc">&nbsp;						pq.sub(segment2.getStartXY());</b>
<b class="fc">&nbsp;						pr.setCoords(inputPoint);</b>
<b class="fc">&nbsp;						pr.sub(segment2.getStartXY());</b>
<b class="fc">&nbsp;						m_bRight2 = (pq.crossProduct(pr) &lt; 0);</b>
&nbsp;					}
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				if (m_i2 == -1) {</b>
<b class="nc">&nbsp;					m_i2 = find_prev_non_degenerate(segIter, m_i1);</b>
<b class="nc">&nbsp;					if (m_i2 != -1) {</b>
<b class="nc">&nbsp;						segIter.resetToVertex(m_i2, -1);</b>
<b class="nc">&nbsp;						Segment segment2 = segIter.nextSegment();</b>
<b class="nc">&nbsp;						double t2 = segment2.getClosestCoordinate(inputPoint,</b>
&nbsp;								false);
<b class="nc">&nbsp;						Point2D p2 = segment2.getCoord2D(t2);</b>
<b class="nc">&nbsp;						double d2 = Point2D.sqrDistance(p2, inputPoint);</b>
&nbsp;
<b class="nc">&nbsp;						if (d2 &gt; d1)</b>
<b class="nc">&nbsp;							m_i2 = -1;</b>
&nbsp;						else {
<b class="nc">&nbsp;							pq.setCoords(p2);</b>
<b class="nc">&nbsp;							pq.sub(segment2.getStartXY());</b>
<b class="nc">&nbsp;							pr.setCoords(inputPoint);</b>
<b class="nc">&nbsp;							pr.sub(segment2.getStartXY());</b>
<b class="nc">&nbsp;							m_bRight2 = (pq.crossProduct(pr) &lt; 0);</b>
&nbsp;
<b class="nc">&nbsp;							int itemp = m_i1;</b>
<b class="nc">&nbsp;							m_i1 = m_i2;</b>
<b class="nc">&nbsp;							m_i2 = itemp;</b>
&nbsp;
<b class="nc">&nbsp;							boolean btemp = m_bRight1;</b>
<b class="nc">&nbsp;							m_bRight1 = m_bRight2;</b>
<b class="nc">&nbsp;							m_bRight2 = btemp;</b>
&nbsp;						}
&nbsp;					}
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
&nbsp;		// Try to find two segements that are not degenerate
&nbsp;		boolean calc_side(Point2D inputPoint, boolean bRight,
&nbsp;				MultiPath multipath, int vertexIndex, int pathIndex) {
<b class="fc">&nbsp;			SegmentIterator segIter = multipath.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;			find_analysis_pair_from_index(inputPoint, segIter, vertexIndex,</b>
&nbsp;					pathIndex);
&nbsp;
<b class="fc">&nbsp;			if (m_i1 != -1 &amp;&amp; m_i2 == -1) {// could not find a pair of segments</b>
<b class="nc">&nbsp;				return m_bRight1;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			if (m_i1 != -1 &amp;&amp; m_i2 != -1) {</b>
<b class="fc">&nbsp;				if (m_bRight1 == m_bRight2)</b>
<b class="fc">&nbsp;					return m_bRight1;// no conflicting result for the side</b>
&nbsp;				else {
&nbsp;					// the conflicting result, that we are trying to resolve,
&nbsp;					// happens in the obtuse (outer) side of the turn only.
<b class="nc">&nbsp;					segIter.resetToVertex(m_i1, -1);</b>
<b class="nc">&nbsp;					Segment segment1 = segIter.nextSegment();</b>
<b class="nc">&nbsp;					Point2D tang1 = segment1._getTangent(1.0);</b>
&nbsp;
<b class="nc">&nbsp;					segIter.resetToVertex(m_i2, -1);</b>
<b class="nc">&nbsp;					Segment segment2 = segIter.nextSegment();</b>
<b class="nc">&nbsp;					Point2D tang2 = segment2._getTangent(0.0);</b>
&nbsp;
<b class="nc">&nbsp;					double cross = tang1.crossProduct(tang2);</b>
&nbsp;
<b class="nc">&nbsp;					if (cross &gt;= 0) // the obtuse angle is on the right side</b>
&nbsp;					{
<b class="nc">&nbsp;						return true;</b>
&nbsp;					} else // the obtuse angle is on the right side
&nbsp;					{
<b class="nc">&nbsp;						return false;</b>
&nbsp;					}
&nbsp;				}
&nbsp;			} else {
<b class="nc">&nbsp;				assert (m_i1 == -1 &amp;&amp; m_i2 == -1);</b>
<b class="nc">&nbsp;				return bRight;// could not resolve the side. So just return the</b>
&nbsp;								// old value.
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Proximity2DResult getNearestCoordinate(Geometry geom,
&nbsp;			Point inputPoint, boolean bTestPolygonInterior) {
&nbsp;
<b class="fc">&nbsp;		return getNearestCoordinate(geom, inputPoint, bTestPolygonInterior,</b>
&nbsp;				false);
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Proximity2DResult getNearestCoordinate(Geometry geom,
&nbsp;			Point inputPoint, boolean bTestPolygonInterior,
&nbsp;			boolean bCalculateLeftRightSide) {
<b class="fc">&nbsp;		if (geom.isEmpty())</b>
<b class="nc">&nbsp;			return new Proximity2DResult();</b>
&nbsp;
<b class="fc">&nbsp;		Point2D inputPoint2D = inputPoint.getXY();</b>
&nbsp;
<b class="fc">&nbsp;		Geometry proxmityTestGeom = geom;</b>
<b class="fc">&nbsp;		int gt = geom.getType().value();</b>
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;			Polygon polygon = new Polygon();</b>
<b class="fc">&nbsp;			polygon.addEnvelope((Envelope) geom, false);</b>
<b class="fc">&nbsp;			proxmityTestGeom = polygon;</b>
<b class="fc">&nbsp;			gt = Geometry.GeometryType.Polygon;</b>
&nbsp;		}
<b class="fc">&nbsp;		switch (gt) {</b>
&nbsp;		case Geometry.GeometryType.Point:
<b class="nc">&nbsp;			return pointGetNearestVertex((Point) proxmityTestGeom, inputPoint2D);</b>
&nbsp;		case Geometry.GeometryType.MultiPoint:
<b class="nc">&nbsp;			return multiVertexGetNearestVertex(</b>
&nbsp;					(MultiVertexGeometry) proxmityTestGeom, inputPoint2D);
&nbsp;		case Geometry.GeometryType.Polyline:
&nbsp;		case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;			return multiPathGetNearestCoordinate((MultiPath) proxmityTestGeom,</b>
&nbsp;					inputPoint2D, bTestPolygonInterior, bCalculateLeftRightSide);
&nbsp;		default: {
<b class="nc">&nbsp;			throw new GeometryException(&quot;not implemented&quot;);</b>
&nbsp;		}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Proximity2DResult getNearestVertex(Geometry geom, Point inputPoint) {
<b class="fc">&nbsp;		if (geom.isEmpty())</b>
<b class="nc">&nbsp;			return new Proximity2DResult();</b>
&nbsp;
<b class="fc">&nbsp;		Point2D inputPoint2D = inputPoint.getXY();</b>
&nbsp;
<b class="fc">&nbsp;		Geometry proxmityTestGeom = geom;</b>
<b class="fc">&nbsp;		int gt = geom.getType().value();</b>
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.GeometryType.Envelope) {</b>
<b class="fc">&nbsp;			Polygon polygon = new Polygon();</b>
<b class="fc">&nbsp;			polygon.addEnvelope((Envelope) geom, false);</b>
<b class="fc">&nbsp;			proxmityTestGeom = polygon;</b>
<b class="fc">&nbsp;			gt = Geometry.GeometryType.Polygon;</b>
&nbsp;		}
<b class="fc">&nbsp;		switch (gt) {</b>
&nbsp;		case Geometry.GeometryType.Point:
<b class="fc">&nbsp;			return pointGetNearestVertex((Point) proxmityTestGeom, inputPoint2D);</b>
&nbsp;		case Geometry.GeometryType.MultiPoint:
&nbsp;		case Geometry.GeometryType.Polyline:
&nbsp;		case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;			return multiVertexGetNearestVertex(</b>
&nbsp;					(MultiVertexGeometry) proxmityTestGeom, inputPoint2D);
&nbsp;		default: {
<b class="nc">&nbsp;			throw new GeometryException(&quot;not implemented&quot;);</b>
&nbsp;		}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public Proximity2DResult[] getNearestVertices(Geometry geom,
&nbsp;			Point inputPoint, double searchRadius, int maxVertexCountToReturn) {
<b class="fc">&nbsp;		if (maxVertexCountToReturn &lt; 0)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		if (geom.isEmpty())</b>
<b class="nc">&nbsp;			return new Proximity2DResult[] {};</b>
&nbsp;
<b class="fc">&nbsp;		Point2D inputPoint2D = inputPoint.getXY();</b>
&nbsp;
<b class="fc">&nbsp;		Geometry proxmityTestGeom = geom;</b>
<b class="fc">&nbsp;		int gt = geom.getType().value();</b>
&nbsp;
<b class="fc">&nbsp;		if (gt == Geometry.GeometryType.Envelope) {</b>
<b class="nc">&nbsp;			Polygon polygon = new Polygon();</b>
<b class="nc">&nbsp;			polygon.addEnvelope((Envelope) geom, false);</b>
<b class="nc">&nbsp;			proxmityTestGeom = polygon;</b>
<b class="nc">&nbsp;			gt = Geometry.GeometryType.Polygon;</b>
&nbsp;		}
<b class="fc">&nbsp;		switch (gt) {</b>
&nbsp;		case Geometry.GeometryType.Point:
<b class="fc">&nbsp;			return pointGetNearestVertices((Point) proxmityTestGeom,</b>
&nbsp;					inputPoint2D, searchRadius, maxVertexCountToReturn);
&nbsp;		case Geometry.GeometryType.MultiPoint:
&nbsp;		case Geometry.GeometryType.Polyline:
&nbsp;		case Geometry.GeometryType.Polygon:
<b class="fc">&nbsp;			return multiVertexGetNearestVertices(</b>
&nbsp;					(MultiVertexGeometry) proxmityTestGeom, inputPoint2D,
&nbsp;					searchRadius, maxVertexCountToReturn);
&nbsp;		default: {
<b class="nc">&nbsp;			throw new GeometryException(&quot;not implemented&quot;);</b>
&nbsp;		}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	Proximity2DResult multiPathGetNearestCoordinate(MultiPath geom,
&nbsp;			Point2D inputPoint, boolean bTestPolygonInterior,
&nbsp;			boolean bCalculateLeftRightSide) {
<b class="fc">&nbsp;		if (geom.getType() == Geometry.Type.Polygon &amp;&amp; bTestPolygonInterior) {</b>
<b class="fc">&nbsp;			Envelope2D env = new Envelope2D();</b>
<b class="fc">&nbsp;			geom.queryEnvelope2D(env);</b>
<b class="fc">&nbsp;			double tolerance = InternalUtils.calculateToleranceFromGeometry(</b>
&nbsp;					null, env, false);
&nbsp;
&nbsp;			PolygonUtils.PiPResult pipResult;
&nbsp;
<b class="fc">&nbsp;			if (bCalculateLeftRightSide)</b>
<b class="fc">&nbsp;				pipResult = PolygonUtils.isPointInPolygon2D((Polygon) geom,</b>
&nbsp;						inputPoint, 0.0);
&nbsp;			else
<b class="fc">&nbsp;				pipResult = PolygonUtils.isPointInPolygon2D((Polygon) geom,</b>
&nbsp;						inputPoint, tolerance);
&nbsp;
<b class="fc">&nbsp;			if (pipResult != PolygonUtils.PiPResult.PiPOutside) {</b>
<b class="fc">&nbsp;				Proximity2DResult result = new Proximity2DResult(inputPoint, 0,</b>
&nbsp;						0.0);
&nbsp;
<b class="fc">&nbsp;				if (bCalculateLeftRightSide)</b>
<b class="nc">&nbsp;					result.setRightSide(true);</b>
&nbsp;
<b class="fc">&nbsp;				return result;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		SegmentIterator segIter = geom.querySegmentIterator();</b>
&nbsp;
<b class="fc">&nbsp;		Point2D closest = new Point2D();</b>
<b class="fc">&nbsp;		int closestVertexIndex = -1;</b>
<b class="fc">&nbsp;		int closestPathIndex = -1;</b>
<b class="fc">&nbsp;		double closestDistanceSq = NumberUtils.doubleMax();</b>
<b class="fc">&nbsp;		boolean bRight = false;</b>
<b class="fc">&nbsp;		int num_candidates = 0;</b>
&nbsp;
<b class="fc">&nbsp;		while (segIter.nextPath()) {</b>
<b class="fc">&nbsp;			while (segIter.hasNextSegment()) {</b>
<b class="fc">&nbsp;				Segment segment = segIter.nextSegment();</b>
<b class="fc">&nbsp;				double t = segment.getClosestCoordinate(inputPoint, false);</b>
&nbsp;
<b class="fc">&nbsp;				Point2D point = segment.getCoord2D(t);</b>
&nbsp;
<b class="fc">&nbsp;				double distanceSq = Point2D.sqrDistance(point, inputPoint);</b>
<b class="fc">&nbsp;				if (distanceSq &lt; closestDistanceSq) {</b>
<b class="fc">&nbsp;					num_candidates = 1;</b>
<b class="fc">&nbsp;					closest = point;</b>
<b class="fc">&nbsp;					closestVertexIndex = segIter.getStartPointIndex();</b>
<b class="fc">&nbsp;					closestPathIndex = segIter.getPathIndex();</b>
<b class="fc">&nbsp;					closestDistanceSq = distanceSq;</b>
<b class="fc">&nbsp;				} else if (distanceSq == closestDistanceSq) {</b>
<b class="fc">&nbsp;					num_candidates++;</b>
&nbsp;				}
<b class="fc">&nbsp;			}</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Proximity2DResult result = new Proximity2DResult(closest,</b>
<b class="fc">&nbsp;				closestVertexIndex, Math.sqrt(closestDistanceSq));</b>
&nbsp;
<b class="fc">&nbsp;		if (bCalculateLeftRightSide) {</b>
<b class="fc">&nbsp;			segIter.resetToVertex(closestVertexIndex, closestPathIndex);</b>
<b class="fc">&nbsp;			Segment segment = segIter.nextSegment();</b>
<b class="fc">&nbsp;			bRight = (Point2D.orientationRobust(inputPoint,</b>
<b class="fc">&nbsp;					segment.getStartXY(), segment.getEndXY()) &lt; 0);</b>
&nbsp;
<b class="fc">&nbsp;			if (num_candidates &gt; 1) {</b>
<b class="fc">&nbsp;				Side_helper sideHelper = new Side_helper();</b>
<b class="fc">&nbsp;				sideHelper.reset();</b>
<b class="fc">&nbsp;				bRight = sideHelper.calc_side(inputPoint, bRight, geom,</b>
&nbsp;						closestVertexIndex, closestPathIndex);
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			result.setRightSide(bRight);</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	Proximity2DResult pointGetNearestVertex(Point geom, Point2D input_point) {
<b class="fc">&nbsp;		Point2D pt = geom.getXY();</b>
<b class="fc">&nbsp;		double distance = Point2D.distance(pt, input_point);</b>
<b class="fc">&nbsp;		return new Proximity2DResult(pt, 0, distance);</b>
&nbsp;	}
&nbsp;
&nbsp;	Proximity2DResult multiVertexGetNearestVertex(MultiVertexGeometry geom,
&nbsp;			Point2D inputPoint) {
<b class="fc">&nbsp;		MultiVertexGeometryImpl mpImpl = (MultiVertexGeometryImpl) geom</b>
<b class="fc">&nbsp;				._getImpl();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl position = (AttributeStreamOfDbl) mpImpl</b>
<b class="fc">&nbsp;				.getAttributeStreamRef((Semantics.POSITION));</b>
<b class="fc">&nbsp;		int pointCount = geom.getPointCount();</b>
&nbsp;
<b class="fc">&nbsp;		int closestIndex = 0;</b>
<b class="fc">&nbsp;		double closestx = 0.0;</b>
<b class="fc">&nbsp;		double closesty = 0.0;</b>
<b class="fc">&nbsp;		double closestDistanceSq = NumberUtils.doubleMax();</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;			position.read(2 * i, pt);</b>
&nbsp;
<b class="fc">&nbsp;			double distanceSq = Point2D.sqrDistance(pt, inputPoint);</b>
<b class="fc">&nbsp;			if (distanceSq &lt; closestDistanceSq) {</b>
<b class="fc">&nbsp;				closestx = pt.x;</b>
<b class="fc">&nbsp;				closesty = pt.y;</b>
<b class="fc">&nbsp;				closestIndex = i;</b>
<b class="fc">&nbsp;				closestDistanceSq = distanceSq;</b>
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		Proximity2DResult result = new Proximity2DResult();</b>
<b class="fc">&nbsp;		result._setParams(closestx, closesty, closestIndex,</b>
<b class="fc">&nbsp;				Math.sqrt(closestDistanceSq));</b>
&nbsp;
<b class="fc">&nbsp;		return result;</b>
&nbsp;	}
&nbsp;
&nbsp;	Proximity2DResult[] pointGetNearestVertices(Point geom, Point2D inputPoint,
&nbsp;			double searchRadius, int maxVertexCountToReturn) {
&nbsp;		Proximity2DResult[] resultArray;
&nbsp;
<b class="fc">&nbsp;		if (maxVertexCountToReturn == 0) {</b>
<b class="nc">&nbsp;			resultArray = new Proximity2DResult[] {};</b>
<b class="nc">&nbsp;			return resultArray;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		double searchRadiusSq = searchRadius * searchRadius;</b>
<b class="fc">&nbsp;		Point2D pt = geom.getXY();</b>
&nbsp;
<b class="fc">&nbsp;		double distanceSq = Point2D.sqrDistance(pt, inputPoint);</b>
<b class="fc">&nbsp;		if (distanceSq &lt;= searchRadiusSq) {</b>
<b class="fc">&nbsp;			resultArray = new Proximity2DResult[1];</b>
&nbsp;
<b class="fc">&nbsp;			Proximity2DResult result = new Proximity2DResult();</b>
<b class="fc">&nbsp;			result._setParams(pt.x, pt.y, 0, Math.sqrt(distanceSq));</b>
<b class="fc">&nbsp;			resultArray[0] = result;</b>
<b class="fc">&nbsp;		} else {</b>
<b class="nc">&nbsp;			resultArray = new Proximity2DResult[0];</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return resultArray;</b>
&nbsp;	}
&nbsp;
&nbsp;	Proximity2DResult[] multiVertexGetNearestVertices(MultiVertexGeometry geom,
&nbsp;			Point2D inputPoint, double searchRadius, int maxVertexCountToReturn) {
&nbsp;		Proximity2DResult[] resultArray;
&nbsp;
<b class="fc">&nbsp;		if (maxVertexCountToReturn == 0) {</b>
<b class="nc">&nbsp;			resultArray = new Proximity2DResult[0];</b>
<b class="nc">&nbsp;			return resultArray;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		MultiVertexGeometryImpl mpImpl = (MultiVertexGeometryImpl) geom</b>
<b class="fc">&nbsp;				._getImpl();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl position = (AttributeStreamOfDbl) mpImpl</b>
<b class="fc">&nbsp;				.getAttributeStreamRef((Semantics.POSITION));</b>
<b class="fc">&nbsp;		int pointCount = geom.getPointCount();</b>
&nbsp;
<b class="fc">&nbsp;		ArrayList&lt;Proximity2DResult&gt; v = new ArrayList&lt;Proximity2DResult&gt;(</b>
&nbsp;				maxVertexCountToReturn);
&nbsp;
<b class="fc">&nbsp;		int count = 0;</b>
<b class="fc">&nbsp;		double searchRadiusSq = searchRadius * searchRadius;</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; pointCount; i++) {</b>
<b class="fc">&nbsp;			double x = position.read(2 * i);</b>
<b class="fc">&nbsp;			double y = position.read(2 * i + 1);</b>
&nbsp;
<b class="fc">&nbsp;			double xDiff = inputPoint.x - x;</b>
<b class="fc">&nbsp;			double yDiff = inputPoint.y - y;</b>
&nbsp;
<b class="fc">&nbsp;			double distanceSq = xDiff * xDiff + yDiff * yDiff;</b>
<b class="fc">&nbsp;			if (distanceSq &lt;= searchRadiusSq) {</b>
<b class="fc">&nbsp;				Proximity2DResult result = new Proximity2DResult();</b>
<b class="fc">&nbsp;				result._setParams(x, y, i, Math.sqrt(distanceSq));</b>
&nbsp;
<b class="fc">&nbsp;				count++;</b>
<b class="fc">&nbsp;				v.add(result);</b>
&nbsp;
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		int vsize = v.size();</b>
<b class="fc">&nbsp;		Collections.sort(v, new Proximity2DResultComparator());</b>
&nbsp;
<b class="fc">&nbsp;		if (maxVertexCountToReturn &gt;= vsize)</b>
<b class="fc">&nbsp;			return v.toArray(new Proximity2DResult[0]);</b>
<b class="fc">&nbsp;		return v.subList(0, maxVertexCountToReturn).toArray(</b>
&nbsp;				new Proximity2DResult[0]);
&nbsp;
&nbsp;	}
&nbsp;
&nbsp;	/*
&nbsp;	 * if (distanceSq &lt;= searchRadiusSq) { if (count &gt;= maxVertexCountToReturn +
&nbsp;	 * 1) { count++; double frontDistance = v.get(0).getDistance(); if
&nbsp;	 * (frontDistance * frontDistance &lt;= distanceSq) continue; }
&nbsp;	 * 
&nbsp;	 * Proximity2DResult result = new Proximity2DResult(); result._setParams(x,
&nbsp;	 * y, i, Math.sqrt(distanceSq));
&nbsp;	 * 
&nbsp;	 * count++;
&nbsp;	 * 
&nbsp;	 * if (count &lt;= maxVertexCountToReturn) { v.add(result); } // else // { //
&nbsp;	 * if (count == maxVertexCountToReturn + 1) // MAKEHEAP(v,
&nbsp;	 * Proximity2DResult, Proximity2DResult::_Compare); // // PUSHHEAP(v,
&nbsp;	 * result, Proximity2DResult, Proximity2DResult::_Compare); // POPHEAP(v,
&nbsp;	 * Proximity2DResult, Proximity2DResult::_Compare); // } } }
&nbsp;	 * 
&nbsp;	 * int vsize = v.size(); Collections.sort(v, new
&nbsp;	 * Proximity2DResultComparator());
&nbsp;	 * 
&nbsp;	 * // SORTDYNAMICARRAY(v, Proximity2DResult, 0, vsize,
&nbsp;	 * Proximity2DResult::_Compare); resultArray = new Proximity2DResult[vsize];
&nbsp;	 * for (int i = 0; i &lt; vsize; i++) { resultArray[i] =
&nbsp;	 * (Proximity2DResult)v.get(i); }
&nbsp;	 * 
&nbsp;	 * return resultArray; }
&nbsp;	 */
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
