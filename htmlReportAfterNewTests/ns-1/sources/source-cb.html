


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > SegmentIntersector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: SegmentIntersector (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">SegmentIntersector</td>
<td class="coverageStat">
  <span class="percent">
    87,5%
  </span>
  <span class="absValue">
    (14/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82,6%
  </span>
  <span class="absValue">
    (185/224)
  </span>
</td>
</tr>
  <tr>
    <td class="name">SegmentIntersector$IntersectionPart</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88,2%
  </span>
  <span class="absValue">
    (15/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83,1%
  </span>
  <span class="absValue">
    (192/231)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;/*
&nbsp; * To change this template, choose Tools | Templates
&nbsp; * and open the template in the editor.
&nbsp; */
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;
<b class="fc">&nbsp;class SegmentIntersector {</b>
&nbsp;	private static class IntersectionPart {
&nbsp;		public Segment seg;
&nbsp;		// Weight controls the snapping. When points of the same rank are
&nbsp;		// snapped together,
&nbsp;		// The new posistion is calculated as a weighted average.
&nbsp;		public double weight_start;
&nbsp;		public double weight_end;
&nbsp;		// The rank controls the snapping. The point with lower rank will be
&nbsp;		// snapped to the point with the higher rank.
&nbsp;		public int rank_start; // the rank of the start point
&nbsp;		public int rank_end; // the rank of the end point
&nbsp;		public int rank_interior; // the rank of the interior point
&nbsp;
<b class="fc">&nbsp;		IntersectionPart(Segment _seg) {</b>
<b class="fc">&nbsp;			seg = _seg;</b>
<b class="fc">&nbsp;			weight_start = 1.0;</b>
<b class="fc">&nbsp;			weight_end = 1.0;</b>
<b class="fc">&nbsp;			rank_start = 0;</b>
<b class="fc">&nbsp;			rank_end = 0;</b>
<b class="fc">&nbsp;			rank_interior = 0;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// typedef std::shared_ptr&lt;Segment_buffer&gt; segment_buffer_sptr;
&nbsp;	// typedef std::shared_ptr&lt;Intersection_part&gt; intersection_part_sptr;
&nbsp;	// typedef Dynamic_array&lt;intersection_part_sptr&gt; intersection_parts;
&nbsp;
&nbsp;	private ArrayList&lt;IntersectionPart&gt; m_input_segments;
&nbsp;	private ArrayList&lt;IntersectionPart&gt; m_result_segments_1;
&nbsp;	private ArrayList&lt;IntersectionPart&gt; m_result_segments_2;
&nbsp;	private ArrayList&lt;IntersectionPart&gt; m_recycled_intersection_parts;
&nbsp;	private ArrayList&lt;SegmentBuffer&gt; m_recycled_segments;
<b class="fc">&nbsp;	private double[] m_param_1 = new double[15];</b>
<b class="fc">&nbsp;	private double[] m_param_2 = new double[15];</b>
<b class="fc">&nbsp;	private Point m_point = new Point();</b>
&nbsp;
&nbsp;	private int m_used_recycled_segments;
&nbsp;
&nbsp;	private void recycle_(ArrayList&lt;IntersectionPart&gt; parts) {
<b class="fc">&nbsp;		if (parts == null)</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		for (int i = 0, n = (int) parts.size(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;			recycle_(parts.get(i));</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		parts.clear();</b>
&nbsp;	}
&nbsp;
&nbsp;	private void recycle_(IntersectionPart part) {
<b class="fc">&nbsp;		part.seg = null;</b>
<b class="fc">&nbsp;		m_recycled_intersection_parts.add(part);</b>
&nbsp;	}
&nbsp;
&nbsp;	private IntersectionPart newIntersectionPart_(Segment _seg) {
<b class="fc">&nbsp;		if (m_recycled_intersection_parts.isEmpty()) {</b>
<b class="fc">&nbsp;			IntersectionPart part = new IntersectionPart(_seg);</b>
<b class="fc">&nbsp;			return part;</b>
&nbsp;		} else {
<b class="fc">&nbsp;			IntersectionPart part = m_recycled_intersection_parts</b>
<b class="fc">&nbsp;					.get(m_recycled_intersection_parts.size() - 1);</b>
<b class="fc">&nbsp;			part.seg = _seg;</b>
<b class="fc">&nbsp;			m_recycled_intersection_parts.remove(m_recycled_intersection_parts</b>
<b class="fc">&nbsp;					.size() - 1);</b>
<b class="fc">&nbsp;			return part;</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private IntersectionPart getResultPart_(int input_segment_index,
&nbsp;			int segment_index) {
<b class="fc">&nbsp;		if (input_segment_index == 0) {</b>
<b class="fc">&nbsp;			return m_result_segments_1.get(segment_index);</b>
&nbsp;		} else {
<b class="fc">&nbsp;			assert (input_segment_index == 1);</b>
<b class="fc">&nbsp;			return m_result_segments_2.get(segment_index);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	private SegmentBuffer newSegmentBuffer_() {
<b class="fc">&nbsp;		if (m_used_recycled_segments &gt;= m_recycled_segments.size()) {</b>
<b class="fc">&nbsp;			m_recycled_segments.add(new SegmentBuffer());</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		SegmentBuffer p = m_recycled_segments.get(m_used_recycled_segments);</b>
<b class="fc">&nbsp;		m_used_recycled_segments++;</b>
<b class="fc">&nbsp;		return p;</b>
&nbsp;	}
&nbsp;
&nbsp;	private double m_tolerance;
&nbsp;
<b class="fc">&nbsp;	public SegmentIntersector() {</b>
<b class="fc">&nbsp;		m_used_recycled_segments = 0;</b>
<b class="fc">&nbsp;		m_tolerance = 0;</b>
<b class="fc">&nbsp;		m_input_segments = new ArrayList&lt;IntersectionPart&gt;();</b>
<b class="fc">&nbsp;		m_result_segments_1 = new ArrayList&lt;IntersectionPart&gt;();</b>
<b class="fc">&nbsp;		m_result_segments_2 = new ArrayList&lt;IntersectionPart&gt;();</b>
<b class="fc">&nbsp;		m_recycled_intersection_parts = new ArrayList&lt;IntersectionPart&gt;();</b>
<b class="fc">&nbsp;		m_recycled_segments = new ArrayList&lt;SegmentBuffer&gt;();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Clears the results and input segments
&nbsp;	public void clear() {
<b class="fc">&nbsp;		recycle_(m_input_segments);</b>
<b class="fc">&nbsp;		recycle_(m_result_segments_1);</b>
<b class="fc">&nbsp;		recycle_(m_result_segments_2);</b>
<b class="fc">&nbsp;		m_used_recycled_segments = 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Adds a segment to intersect and returns an index of the segment.
&nbsp;	// Two segments has to be pushed for the intersect method to succeed.
&nbsp;	public int pushSegment(Segment seg) {
<b class="fc">&nbsp;		assert (m_input_segments.size() &lt; 2);</b>
<b class="fc">&nbsp;		m_input_segments.add(newIntersectionPart_(seg));</b>
&nbsp;		// m_param_1.resize(15);
&nbsp;		// m_param_2.resize(15);
<b class="fc">&nbsp;		return (int) m_input_segments.size() - 1;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void setRankAndWeight(int input_segment_index, double start_weight,
&nbsp;			int start_rank, double end_weight, int end_rank, int interior_rank) {
<b class="nc">&nbsp;		IntersectionPart part = m_input_segments.get(input_segment_index);</b>
<b class="nc">&nbsp;		part.rank_end = end_rank;</b>
<b class="nc">&nbsp;		part.weight_start = start_weight;</b>
<b class="nc">&nbsp;		part.weight_end = end_weight;</b>
<b class="nc">&nbsp;		part.rank_start = start_rank;</b>
<b class="nc">&nbsp;		part.rank_end = end_rank;</b>
<b class="nc">&nbsp;		part.rank_interior = interior_rank;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Returns the number of segments the input segment has been split to.
&nbsp;	public int getResultSegmentCount(int input_segment_index) {
<b class="fc">&nbsp;		if (input_segment_index == 0) {</b>
<b class="fc">&nbsp;			return (int) m_result_segments_1.size();</b>
&nbsp;		} else {
<b class="fc">&nbsp;			assert (input_segment_index == 1);</b>
<b class="fc">&nbsp;			return (int) m_result_segments_2.size();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// Returns a part of the input segment that is the result of the
&nbsp;	// intersection with another segment.
&nbsp;	// input_segment_index is the index of the input segment.
&nbsp;	// segment_index is between 0 and
&nbsp;	// get_result_segment_count(input_segment_index) - 1
&nbsp;	public Segment getResultSegment(int input_segment_index, int segment_index) {
<b class="fc">&nbsp;		return getResultPart_(input_segment_index, segment_index).seg;</b>
&nbsp;	}
&nbsp;
&nbsp;	// double get_result_segment_start_point_weight(int input_segment_index, int
&nbsp;	// segment_index);
&nbsp;	// int get_result_segment_start_point_rank(int input_segment_index, int
&nbsp;	// segment_index);
&nbsp;	// double get_result_segment_end_point_weight(int input_segment_index, int
&nbsp;	// segment_index);
&nbsp;	// int get_result_segment_end_point_rank(int input_segment_index, int
&nbsp;	// segment_index);
&nbsp;	// int get_result_segment_interior_rank(int input_segment_index, int
&nbsp;	// segment_index);
&nbsp;	public Point getResultPoint() {
<b class="fc">&nbsp;		return m_point;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Performs the intersection
&nbsp;	public boolean intersect(double tolerance, boolean b_intersecting) {
<b class="fc">&nbsp;		if (m_input_segments.size() != 2)</b>
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;
<b class="fc">&nbsp;		m_tolerance = tolerance;</b>
<b class="fc">&nbsp;		double small_tolerance_sqr = MathUtils.sqr(tolerance * 0.01);</b>
<b class="fc">&nbsp;		boolean bigmove = false;</b>
&nbsp;		
<b class="fc">&nbsp;		IntersectionPart part1 = m_input_segments.get(0);</b>
<b class="fc">&nbsp;		IntersectionPart part2 = m_input_segments.get(1);</b>
<b class="fc">&nbsp;		if (b_intersecting</b>
<b class="fc">&nbsp;				|| (part1.seg._isIntersecting(part2.seg, tolerance, true) &amp; 5) != 0) {</b>
<b class="fc">&nbsp;			if (part1.seg.getType().value() == Geometry.GeometryType.Line) {</b>
<b class="fc">&nbsp;				Line line_1 = (Line) part1.seg;</b>
<b class="fc">&nbsp;				if (part2.seg.getType().value() == Geometry.GeometryType.Line) {</b>
<b class="fc">&nbsp;					Line line_2 = (Line) part2.seg;</b>
<b class="fc">&nbsp;					int count = Line._intersectLineLine(line_1, line_2, null,</b>
&nbsp;							m_param_1, m_param_2, tolerance);
<b class="fc">&nbsp;					if (count == 0) {</b>
<b class="nc">&nbsp;						assert (count &gt; 0);</b>
<b class="nc">&nbsp;						throw GeometryException.GeometryInternalError();</b>
&nbsp;					}
<b class="fc">&nbsp;					Point2D[] points = new Point2D[9];</b>
<b class="fc">&nbsp;					for (int i = 0; i &lt; count; i++) {</b>
&nbsp;						// For each point of intersection, we calculate a
&nbsp;						// weighted point
&nbsp;						// based on the ranks and weights of the endpoints and
&nbsp;						// the interior.
<b class="fc">&nbsp;						double t1 = m_param_1[i];</b>
<b class="fc">&nbsp;						double t2 = m_param_2[i];</b>
<b class="fc">&nbsp;						int rank1 = part1.rank_interior;</b>
<b class="fc">&nbsp;						double weight1 = 1.0;</b>
&nbsp;
<b class="fc">&nbsp;						if (t1 == 0) {</b>
<b class="fc">&nbsp;							rank1 = part1.rank_start;</b>
<b class="fc">&nbsp;							weight1 = part1.weight_start;</b>
<b class="fc">&nbsp;						} else if (t1 == 1.0) {</b>
<b class="fc">&nbsp;							rank1 = part1.rank_end;</b>
<b class="fc">&nbsp;							weight1 = part1.weight_end;</b>
&nbsp;						}
&nbsp;
<b class="fc">&nbsp;						int rank2 = part2.rank_interior;</b>
<b class="fc">&nbsp;						double weight2 = 1.0;</b>
<b class="fc">&nbsp;						if (t2 == 0) {</b>
<b class="fc">&nbsp;							rank2 = part2.rank_start;</b>
<b class="fc">&nbsp;							weight2 = part2.weight_start;</b>
<b class="fc">&nbsp;						} else if (t2 == 1.0) {</b>
<b class="fc">&nbsp;							rank2 = part2.rank_end;</b>
<b class="fc">&nbsp;							weight2 = part2.weight_end;</b>
&nbsp;						}
&nbsp;
&nbsp;						double ptWeight;
&nbsp;
<b class="fc">&nbsp;						Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;						if (rank1 == rank2) {// for equal ranks use weighted sum</b>
<b class="fc">&nbsp;							Point2D pt_1 = new Point2D();</b>
<b class="fc">&nbsp;							line_1.getCoord2D(t1, pt_1);</b>
<b class="fc">&nbsp;							Point2D pt_2 = new Point2D();</b>
<b class="fc">&nbsp;							line_2.getCoord2D(t2, pt_2);</b>
<b class="fc">&nbsp;							ptWeight = weight1 + weight2;</b>
<b class="fc">&nbsp;							double t = weight2 / ptWeight;</b>
<b class="fc">&nbsp;							MathUtils.lerp(pt_1, pt_2, t, pt);</b>
<b class="fc">&nbsp;							if (Point2D.sqrDistance(pt, pt_1)</b>
<b class="fc">&nbsp;									+ Point2D.sqrDistance(pt, pt_2) &gt; small_tolerance_sqr)</b>
<b class="fc">&nbsp;								bigmove = true;</b>
&nbsp;							
<b class="fc">&nbsp;						} else {// for non-equal ranks, the higher rank wins</b>
<b class="nc">&nbsp;							if (rank1 &gt; rank2) {</b>
<b class="nc">&nbsp;								line_1.getCoord2D(t1, pt);</b>
<b class="nc">&nbsp;								ptWeight = weight1;</b>
<b class="nc">&nbsp;								Point2D pt_2 = new Point2D();</b>
<b class="nc">&nbsp;								line_2.getCoord2D(t2, pt_2);</b>
<b class="nc">&nbsp;								if (Point2D.sqrDistance(pt, pt_2) &gt; small_tolerance_sqr)</b>
<b class="nc">&nbsp;									bigmove = true;</b>
<b class="nc">&nbsp;							} else {</b>
<b class="nc">&nbsp;								line_2.getCoord2D(t2, pt);</b>
<b class="nc">&nbsp;								ptWeight = weight2;</b>
<b class="nc">&nbsp;								Point2D pt_1 = new Point2D();</b>
<b class="nc">&nbsp;								line_1.getCoord2D(t1, pt_1);</b>
<b class="nc">&nbsp;								if (Point2D.sqrDistance(pt, pt_1) &gt; small_tolerance_sqr)</b>
<b class="nc">&nbsp;									bigmove = true;</b>
&nbsp;							}
&nbsp;						}
<b class="fc">&nbsp;						points[i] = pt;</b>
&nbsp;					}
&nbsp;
&nbsp;					// Split the line_1, making sure the endpoints are adusted
&nbsp;					// to the weighted
<b class="fc">&nbsp;					double t0 = 0;</b>
<b class="fc">&nbsp;					int i0 = -1;</b>
<b class="fc">&nbsp;					for (int i = 0; i &lt;= count; i++) {</b>
<b class="fc">&nbsp;						double t = i &lt; count ? m_param_1[i] : 1.0;</b>
<b class="fc">&nbsp;						if (t != t0) {</b>
<b class="fc">&nbsp;							SegmentBuffer seg_buffer = newSegmentBuffer_();</b>
<b class="fc">&nbsp;							line_1.cut(t0, t, seg_buffer);</b>
<b class="fc">&nbsp;							if (i0 != -1)</b>
<b class="fc">&nbsp;								seg_buffer.get().setStartXY(points[i0]);</b>
<b class="fc">&nbsp;							if (i != count)</b>
<b class="fc">&nbsp;								seg_buffer.get().setEndXY(points[i]);</b>
&nbsp;
<b class="fc">&nbsp;							t0 = t;</b>
<b class="fc">&nbsp;							m_result_segments_1</b>
<b class="fc">&nbsp;									.add(newIntersectionPart_(seg_buffer.get()));</b>
&nbsp;						}
<b class="fc">&nbsp;						i0 = i;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					int[] indices = new int[9];</b>
<b class="fc">&nbsp;					for (int i = 0; i &lt; count; i++)</b>
<b class="fc">&nbsp;						indices[i] = i;</b>
&nbsp;
<b class="fc">&nbsp;					if (count &gt; 1) {</b>
<b class="fc">&nbsp;						if (m_param_2[0] &gt; m_param_2[1]) {</b>
<b class="fc">&nbsp;							double t = m_param_2[0];</b>
<b class="fc">&nbsp;							m_param_2[0] = m_param_2[1];</b>
<b class="fc">&nbsp;							m_param_2[1] = t;</b>
<b class="fc">&nbsp;							int i = indices[0];</b>
<b class="fc">&nbsp;							indices[0] = indices[1];</b>
<b class="fc">&nbsp;							indices[1] = i;</b>
&nbsp;						}
&nbsp;					}
&nbsp;
&nbsp;					// Split the line_2
<b class="fc">&nbsp;					t0 = 0;</b>
<b class="fc">&nbsp;					i0 = -1;</b>
<b class="fc">&nbsp;					for (int i = 0; i &lt;= count; i++) {</b>
<b class="fc">&nbsp;						double t = i &lt; count ? m_param_2[i] : 1.0;</b>
<b class="fc">&nbsp;						if (t != t0) {</b>
<b class="fc">&nbsp;							SegmentBuffer seg_buffer = newSegmentBuffer_();</b>
<b class="fc">&nbsp;							line_2.cut(t0, t, seg_buffer);</b>
<b class="fc">&nbsp;							if (i0 != -1) {</b>
<b class="fc">&nbsp;								int ind = indices[i0];</b>
<b class="fc">&nbsp;								seg_buffer.get().setStartXY(points[ind]);</b>
&nbsp;							}
<b class="fc">&nbsp;							if (i != count) {</b>
<b class="fc">&nbsp;								int ind = indices[i];</b>
<b class="fc">&nbsp;								seg_buffer.get().setEndXY(points[ind]);</b>
&nbsp;							}
&nbsp;
<b class="fc">&nbsp;							t0 = t;</b>
<b class="fc">&nbsp;							m_result_segments_2</b>
<b class="fc">&nbsp;									.add(newIntersectionPart_(seg_buffer.get()));</b>
&nbsp;						}
<b class="fc">&nbsp;						i0 = i;</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					return bigmove;</b>
&nbsp;				}
&nbsp;
<b class="nc">&nbsp;				throw GeometryException.GeometryInternalError();</b>
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	public void intersect(double tolerance, Point pt_intersector_point,
&nbsp;			int point_rank, double point_weight, boolean b_intersecting) {
<b class="fc">&nbsp;		pt_intersector_point.copyTo(m_point);</b>
<b class="fc">&nbsp;		if (m_input_segments.size() != 1)</b>
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;
<b class="fc">&nbsp;		m_tolerance = tolerance;</b>
&nbsp;
<b class="fc">&nbsp;		IntersectionPart part1 = m_input_segments.get(0);</b>
<b class="fc">&nbsp;		if (b_intersecting</b>
<b class="fc">&nbsp;				|| part1.seg._isIntersectingPoint(pt_intersector_point.getXY(),</b>
&nbsp;						tolerance, true)) {
<b class="fc">&nbsp;			if (part1.seg.getType().value() == Geometry.GeometryType.Line) {</b>
<b class="fc">&nbsp;				Line line_1 = (Line) (part1.seg);</b>
<b class="fc">&nbsp;				double t1 = line_1.getClosestCoordinate(</b>
<b class="fc">&nbsp;						pt_intersector_point.getXY(), false);</b>
<b class="fc">&nbsp;				m_param_1[0] = t1;</b>
&nbsp;				// For each point of intersection, we calculate a weighted point
&nbsp;				// based on the ranks and weights of the endpoints and the
&nbsp;				// interior.
<b class="fc">&nbsp;				int rank1 = part1.rank_interior;</b>
<b class="fc">&nbsp;				double weight1 = 1.0;</b>
&nbsp;
<b class="fc">&nbsp;				if (t1 == 0) {</b>
<b class="nc">&nbsp;					rank1 = part1.rank_start;</b>
<b class="nc">&nbsp;					weight1 = part1.weight_start;</b>
<b class="fc">&nbsp;				} else if (t1 == 1.0) {</b>
<b class="nc">&nbsp;					rank1 = part1.rank_end;</b>
<b class="nc">&nbsp;					weight1 = part1.weight_end;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				int rank2 = point_rank;</b>
<b class="fc">&nbsp;				double weight2 = point_weight;</b>
&nbsp;
&nbsp;				double ptWeight;
&nbsp;
<b class="fc">&nbsp;				Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;				if (rank1 == rank2) {// for equal ranks use weighted sum</b>
<b class="fc">&nbsp;					Point2D pt_1 = new Point2D();</b>
<b class="fc">&nbsp;					line_1.getCoord2D(t1, pt_1);</b>
<b class="fc">&nbsp;					Point2D pt_2 = pt_intersector_point.getXY();</b>
<b class="fc">&nbsp;					ptWeight = weight1 + weight2;</b>
<b class="fc">&nbsp;					double t = weight2 / ptWeight;</b>
<b class="fc">&nbsp;					MathUtils.lerp(pt_1,  pt_2, t, pt);</b>
<b class="fc">&nbsp;				} else {// for non-equal ranks, the higher rank wins</b>
<b class="nc">&nbsp;					if (rank1 &gt; rank2) {</b>
<b class="nc">&nbsp;						pt = new Point2D();</b>
<b class="nc">&nbsp;						line_1.getCoord2D(t1, pt);</b>
<b class="nc">&nbsp;						ptWeight = weight1;</b>
&nbsp;					} else {
<b class="nc">&nbsp;						pt = pt_intersector_point.getXY();</b>
<b class="nc">&nbsp;						ptWeight = weight2;</b>
&nbsp;					}
&nbsp;				}
&nbsp;
&nbsp;				// Split the line_1, making sure the endpoints are adusted to
&nbsp;				// the weighted
<b class="fc">&nbsp;				double t0 = 0;</b>
<b class="fc">&nbsp;				int i0 = -1;</b>
<b class="fc">&nbsp;				int count = 1;</b>
<b class="fc">&nbsp;				for (int i = 0; i &lt;= count; i++) {</b>
<b class="fc">&nbsp;					double t = i &lt; count ? m_param_1[i] : 1.0;</b>
<b class="fc">&nbsp;					if (t != t0) {</b>
<b class="fc">&nbsp;						SegmentBuffer seg_buffer = newSegmentBuffer_();</b>
<b class="fc">&nbsp;						line_1.cut(t0, t, seg_buffer);</b>
<b class="fc">&nbsp;						if (i0 != -1)</b>
<b class="fc">&nbsp;							seg_buffer.get().setStartXY(pt);</b>
<b class="fc">&nbsp;						if (i != count)</b>
<b class="fc">&nbsp;							seg_buffer.get().setEndXY(pt);</b>
&nbsp;
<b class="fc">&nbsp;						t0 = t;</b>
<b class="fc">&nbsp;						m_result_segments_1.add(newIntersectionPart_(seg_buffer</b>
<b class="fc">&nbsp;								.get()));</b>
&nbsp;					}
<b class="fc">&nbsp;					i0 = i;</b>
&nbsp;				}
&nbsp;
<b class="fc">&nbsp;				m_point.setXY(pt);</b>
&nbsp;
&nbsp;				return;
&nbsp;			}
&nbsp;
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	public double get_tolerance_() {
<b class="nc">&nbsp;		return m_tolerance;</b>
&nbsp;	}
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
