


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MultiVertexGeometryImpl</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">com.esri.core.geometry</a>
</div>

<h1>Coverage Summary for Class: MultiVertexGeometryImpl (com.esri.core.geometry)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MultiVertexGeometryImpl</td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (51/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77%
  </span>
  <span class="absValue">
    (338/439)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MultiVertexGeometryImpl$DirtyFlags</td>
  </tr>
  <tr>
    <td class="name">MultiVertexGeometryImpl$GeometryXSimple</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (51/63)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77%
  </span>
  <span class="absValue">
    (338/439)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; Copyright 1995-2015 Esri
&nbsp;
&nbsp;   Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp;   you may not use this file except in compliance with the License.
&nbsp;   You may obtain a copy of the License at
&nbsp;
&nbsp;       http://www.apache.org/licenses/LICENSE-2.0
&nbsp;
&nbsp;   Unless required by applicable law or agreed to in writing, software
&nbsp;   distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp;   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp;   See the License for the specific language governing permissions and
&nbsp;   limitations under the License.
&nbsp;
&nbsp; For additional information, contact:
&nbsp; Environmental Systems Research Institute, Inc.
&nbsp; Attn: Contracts Dept
&nbsp; 380 New York Street
&nbsp; Redlands, California, USA 92373
&nbsp;
&nbsp; email: contracts@esri.com
&nbsp; */
&nbsp;
&nbsp;
&nbsp;package com.esri.core.geometry;
&nbsp;
&nbsp;import com.esri.core.geometry.Geometry.GeometryAccelerationDegree;
&nbsp;import com.esri.core.geometry.VertexDescription.Semantics;
&nbsp;
&nbsp;/**
&nbsp; * This class is a base for geometries with many vertices.
&nbsp; * 
&nbsp; * The vertex attributes are stored in separate arrays of corresponding type.
&nbsp; * There are as many arrays as there are attributes in the vertex. It uses lazy
&nbsp; * allocation for the vertex attributes. This means, the actual AttributeStream
&nbsp; * is allocated only when the users asks for it, or sets a non-default value.
&nbsp; * 
&nbsp; */
&nbsp;abstract class MultiVertexGeometryImpl extends MultiVertexGeometry {
&nbsp;
&nbsp;	// HEADER DEFINED
&nbsp;	public interface GeometryXSimple {
&nbsp;		final int Unknown = -1; // not know if simple or not
&nbsp;		final int Not = 0; // not simple
&nbsp;		final int Weak = 1; // weak simple (no self intersections, ring
&nbsp;							// orientation is correct, but ring order is not)
&nbsp;		final int Strong = 2; // same as weak simple + OGC ring order.
&nbsp;	}
&nbsp;
&nbsp;	// TODO Remove?
&nbsp;	/**
&nbsp;	 * \internal CHildren implement this method to copy additional information
&nbsp;	 */
&nbsp;	abstract void _copyToImpl(MultiVertexGeometryImpl mvg);
&nbsp;
&nbsp;	protected abstract void _notifyModifiedAllImpl();
&nbsp;
&nbsp;	/**
&nbsp;	 * \internal Called inside of the VerifyAllStreams to get a child class a
&nbsp;	 * chance to do additional verify.
&nbsp;	 */
&nbsp;	protected abstract void _verifyStreamsImpl();
&nbsp;
&nbsp;	public interface DirtyFlags {
&nbsp;		/**0 when IsWeakSimple flag is valid*/
&nbsp;		int DirtyIsKnownSimple = 1;
&nbsp;		/**when DirtyIsKnownSimple is 0, this flag indicates whether the geometry is weak simple or not*/
&nbsp;		int IsWeakSimple = 2; 
&nbsp;		int IsStrongSimple = 4;
&nbsp;		/**OGCFlags are set by Simplify or WKB/WKT import.*/		
&nbsp;		int DirtyOGCFlags = 8; 
&nbsp;		/** At least one stream is unverified*/
&nbsp;		int DirtyVerifiedStreams = 32;
&nbsp;		/** exact envelope is dirty*/
&nbsp;		int DirtyExactIntervals = 64;
&nbsp;		/** loose envelope is dirty*/
&nbsp;		int DirtyLooseIntervals = 128;
&nbsp;		/** loose and dirty envelopes are dirty */
&nbsp;		int DirtyIntervals = DirtyExactIntervals
&nbsp;				| DirtyLooseIntervals;
&nbsp;		/**the geometry is not known to be an envelope*/		
&nbsp;		int DirtyIsEnvelope = 256;
&nbsp;		/** The geometry length needs update*/		
&nbsp;		int DirtyLength2D = 512; 
&nbsp;		/** m_cachedRingAreas2D need update*/		
&nbsp;		int DirtyRingAreas2D = 1024; 
&nbsp;		int DirtyCoordinates = DirtyIsKnownSimple
&nbsp;				| DirtyIntervals | DirtyIsEnvelope | DirtyLength2D
&nbsp;				| DirtyRingAreas2D | DirtyOGCFlags;
&nbsp;		int DirtyAllInternal = 0xFFFF;
&nbsp;		/** There has been a change to one of attribute streams from the outside.*/
&nbsp;		int DirtyAll = 0xFFFFFF; 
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Returns the total vertex count in this Geometry.
&nbsp;	 * 
&nbsp;	 * @return total vertex count in this Geometry.
&nbsp;	 */
&nbsp;	@Override
&nbsp;	public int getPointCount() {
<b class="fc">&nbsp;		return m_pointCount;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public boolean isEmpty() {
<b class="fc">&nbsp;		return isEmptyImpl();</b>
&nbsp;	}
&nbsp;
&nbsp;	public VertexDescription getDescriptionImpl() {
<b class="nc">&nbsp;		return m_description;</b>
&nbsp;	}
&nbsp;
&nbsp;	boolean isEmptyImpl() {
<b class="fc">&nbsp;		return m_pointCount == 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected boolean _hasDirtyFlag(int flag) {
<b class="fc">&nbsp;		return (m_flagsMask &amp; flag) != 0;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void _setDirtyFlag(int flag, boolean bYesNo) {
<b class="fc">&nbsp;		if (bYesNo)</b>
<b class="fc">&nbsp;			m_flagsMask |= flag;</b>
&nbsp;		else
<b class="fc">&nbsp;			m_flagsMask &amp;= ~flag;</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void _verifyAllStreams() {
<b class="fc">&nbsp;		if (_hasDirtyFlag(DirtyFlags.DirtyVerifiedStreams))</b>
<b class="fc">&nbsp;			_verifyAllStreamsImpl();</b>
&nbsp;	}
&nbsp;
&nbsp;	protected void throwIfEmpty() {
<b class="fc">&nbsp;		if (isEmptyImpl())</b>
&nbsp;			// TODO fix exceptions
<b class="nc">&nbsp;			throw new GeometryException(</b>
&nbsp;					&quot;This operation was performed on an Empty Geometry.&quot;);
&nbsp;	}
&nbsp;
&nbsp;	private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;	AttributeStreamBase[] m_vertexAttributes;
&nbsp;	// TODO implement accelerators
&nbsp;	GeometryAccelerators m_accelerators;
&nbsp;	Envelope m_envelope; // the BBOX for all attributes
&nbsp;	protected int m_pointCount;
&nbsp;	protected int m_reservedPointCount;// the number of vertices reserved and
&nbsp;										// initialized to default value.
&nbsp;	protected int m_flagsMask;
&nbsp;	protected double m_simpleTolerance;
&nbsp;
<b class="fc">&nbsp;	public MultiVertexGeometryImpl() {</b>
<b class="fc">&nbsp;		m_flagsMask = DirtyFlags.DirtyAllInternal;</b>
<b class="fc">&nbsp;		m_pointCount = 0;</b>
<b class="fc">&nbsp;		m_reservedPointCount = -1;</b>
<b class="fc">&nbsp;		m_accelerators = null;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void getPointByVal(int index, Point dst) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
&nbsp;			// TODO
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds&quot;);</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
<b class="fc">&nbsp;		Point outPoint = dst;</b>
<b class="fc">&nbsp;		outPoint.assignVertexDescription(m_description);</b>
&nbsp;
<b class="fc">&nbsp;		for (int attributeIndex = 0; attributeIndex &lt; m_description</b>
<b class="fc">&nbsp;				.getAttributeCount(); attributeIndex++) {</b>
&nbsp;			// fix semantics
<b class="fc">&nbsp;			int semantics = m_description._getSemanticsImpl(attributeIndex);</b>
&nbsp;
&nbsp;			// VertexDescription.getComponentCount(semantics);
<b class="fc">&nbsp;			for (int icomp = 0, ncomp = VertexDescription</b>
<b class="fc">&nbsp;					.getComponentCount(semantics); icomp &lt; ncomp; icomp++) {</b>
<b class="fc">&nbsp;				double v = m_vertexAttributes[attributeIndex].readAsDbl(ncomp</b>
&nbsp;						* index + icomp);
<b class="fc">&nbsp;				outPoint.setAttribute(semantics, icomp, v);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setPointByVal(int index, Point src) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds&quot;);</b>
&nbsp;
<b class="fc">&nbsp;		Point point = src;</b>
&nbsp;
<b class="fc">&nbsp;		if (src.isEmpty())// can not assign an empty point to a multipoint</b>
&nbsp;							// vertex
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();// verify all allocated streams are of necessary</b>
&nbsp;							// size.
<b class="fc">&nbsp;		VertexDescription vdin = point.getDescription();</b>
<b class="fc">&nbsp;		for (int attributeIndex = 0; attributeIndex &lt; vdin.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;			int semantics = vdin._getSemanticsImpl(attributeIndex);</b>
<b class="fc">&nbsp;			int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;			for (int icomp = 0; icomp &lt; ncomp; icomp++) {</b>
<b class="fc">&nbsp;				double v = point.getAttributeAsDbl(semantics, icomp);</b>
<b class="fc">&nbsp;				setAttribute(semantics, index, icomp, v);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public Point2D getXY(int index) {
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;		getXY(index, pt);</b>
<b class="fc">&nbsp;		return pt;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void getXY(int index, Point2D pt) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= getPointCount())</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;		// AttributeStreamOfDbl v = (AttributeStreamOfDbl)
&nbsp;		// m_vertexAttributes[0];
<b class="fc">&nbsp;		AttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		v.read(index * 2, pt);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void setXY(int index, Point2D pt) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
&nbsp;			// TODO exception
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;		// AttributeStreamOfDbl v = (AttributeStreamOfDbl)
&nbsp;		// m_vertexAttributes[0];
<b class="fc">&nbsp;		AttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		v.write(index * 2, pt);</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	public void setXY(int index, double x, double y) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
&nbsp;			// TODO exc
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;		// AttributeStreamOfDbl v = (AttributeStreamOfDbl)
&nbsp;		// m_vertexAttributes[0];
&nbsp;		// TODO ask sergey about casts
<b class="fc">&nbsp;		AttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		v.write(index * 2, x);</b>
<b class="fc">&nbsp;		v.write(index * 2 + 1, y);</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public Point3D getXYZ(int index) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= getPointCount())</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		Point3D pt = new Point3D();</b>
<b class="fc">&nbsp;		pt.x = v.read(index * 2);</b>
<b class="fc">&nbsp;		pt.y = v.read(index * 2 + 1);</b>
&nbsp;
&nbsp;		// TODO check excluded if statement componenet
<b class="fc">&nbsp;		if (hasAttribute(Semantics.Z))// &amp;&amp; (m_vertexAttributes[1] != null))</b>
<b class="fc">&nbsp;			pt.z = m_vertexAttributes[1].readAsDbl(index);</b>
&nbsp;		else
<b class="nc">&nbsp;			pt.z = VertexDescription.getDefaultValue(Semantics.Z);</b>
&nbsp;
<b class="fc">&nbsp;		return pt;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void setXYZ(int index, Point3D pt) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= getPointCount())</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		addAttribute(Semantics.Z);</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl v = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		v.write(index * 2, pt.x);</b>
<b class="fc">&nbsp;		v.write(index * 2 + 1, pt.y);</b>
<b class="fc">&nbsp;		m_vertexAttributes[1].writeAsDbl(index, pt.z);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public double getAttributeAsDbl(int semantics, int offset, int ordinate) {
<b class="fc">&nbsp;		if (offset &lt; 0 || offset &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
&nbsp;		// TODO check if statement
<b class="fc">&nbsp;		if (attributeIndex &gt;= 0)// &amp;&amp; m_vertexAttributes[attributeIndex] !=</b>
&nbsp;								// null) {
&nbsp;		{
<b class="fc">&nbsp;			return m_vertexAttributes[attributeIndex].readAsDbl(offset * ncomps</b>
&nbsp;					+ ordinate);
&nbsp;		}
<b class="fc">&nbsp;		return VertexDescription.getDefaultValue(semantics);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public int getAttributeAsInt(int semantics, int offset, int ordinate) {
<b class="fc">&nbsp;		return (int) getAttributeAsDbl(semantics, offset, ordinate);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void setAttribute(int semantics, int offset, int ordinate,
&nbsp;			double value) {
<b class="fc">&nbsp;		if (offset &lt; 0 || offset &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;		if (ordinate &gt;= ncomps)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		addAttribute(semantics);</b>
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyCoordinates);</b>
<b class="fc">&nbsp;		m_vertexAttributes[attributeIndex].writeAsDbl(offset * ncomps</b>
&nbsp;				+ ordinate, value);
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void setAttribute(int semantics, int offset, int ordinate, int value) {
<b class="fc">&nbsp;		setAttribute(semantics, offset, ordinate, (double) value);</b>
&nbsp;	}
&nbsp;
&nbsp;	public AttributeStreamBase getAttributeStreamRef(int semantics) {
<b class="fc">&nbsp;		throwIfEmpty();</b>
&nbsp;
<b class="fc">&nbsp;		addAttribute(semantics);</b>
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
<b class="fc">&nbsp;		return m_vertexAttributes[attributeIndex];</b>
&nbsp;	}
&nbsp;
&nbsp;	/**
&nbsp;	 * Sets a reference to the given AttributeStream of the Geometry. Once the
&nbsp;	 * buffer has been obtained, the vertices of the Geometry can be manipulated
&nbsp;	 * directly. The AttributeStream parameters are not checked for the size. &lt;br&gt;
&nbsp;	 * If the attribute is missing, it will be added. &lt;br&gt;
&nbsp;	 * Note, that this method does not change the vertex count in the Geometry. &lt;br&gt;
&nbsp;	 * The stream can have more elements, than the Geometry point count, but
&nbsp;	 * only necessary part will be saved when exporting to a ESRI shape or other
&nbsp;	 * format. @param semantics Semantics of the attribute to assign the stream
&nbsp;	 * to. @param stream The input AttributeStream that will be assigned by
&nbsp;	 * reference. If one changes the stream later through the reference, one has
&nbsp;	 * to call NotifyStreamChanged. \exception Throws invalid_argument exception
&nbsp;	 * if the input stream type does not match that of the semantics
&nbsp;	 * persistence.
&nbsp;	 */
&nbsp;	public void setAttributeStreamRef(int semantics, AttributeStreamBase stream) {
&nbsp;		// int test1 = VertexDescription.getPersistence(semantics);
&nbsp;		// int test2 = stream.getPersistence();
&nbsp;
<b class="fc">&nbsp;		if ((stream != null)</b>
<b class="fc">&nbsp;				&amp;&amp; VertexDescription.getPersistence(semantics) != stream</b>
<b class="fc">&nbsp;						.getPersistence())// input stream has wrong persistence</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
&nbsp;		// Do not check for the stream size here to allow several streams to be
&nbsp;		// attached before the point count is changed.
<b class="fc">&nbsp;		addAttribute(semantics);</b>
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
<b class="fc">&nbsp;		if (m_vertexAttributes == null)</b>
<b class="fc">&nbsp;			m_vertexAttributes = new AttributeStreamBase[m_description</b>
<b class="fc">&nbsp;					.getAttributeCount()];</b>
&nbsp;
<b class="fc">&nbsp;		m_vertexAttributes[attributeIndex] = stream;</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyAll);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	protected void _assignVertexDescriptionImpl(VertexDescription newDescription) {
<b class="fc">&nbsp;		AttributeStreamBase[] newAttributes = null;</b>
&nbsp;		
<b class="fc">&nbsp;		if (m_vertexAttributes != null) {</b>
<b class="fc">&nbsp;			int[] mapping = VertexDescriptionDesignerImpl.mapAttributes(</b>
&nbsp;					newDescription, m_description);
&nbsp;			
<b class="fc">&nbsp;			newAttributes = new AttributeStreamBase[newDescription</b>
<b class="fc">&nbsp;			                    					.getAttributeCount()];</b>
&nbsp;
<b class="fc">&nbsp;			for (int i = 0, n = newDescription.getAttributeCount(); i &lt; n; i++) {</b>
<b class="fc">&nbsp;				if (mapping[i] != -1) {</b>
<b class="fc">&nbsp;					int m = mapping[i];</b>
<b class="fc">&nbsp;					newAttributes[i] = m_vertexAttributes[m];</b>
&nbsp;				}
&nbsp;
&nbsp;			}
&nbsp;		}
&nbsp;		else {
&nbsp;			//if there are no streams we do not create them
&nbsp;		}
&nbsp;		
<b class="fc">&nbsp;		m_description = newDescription;</b>
<b class="fc">&nbsp;		m_vertexAttributes = newAttributes; // late assignment to try to stay</b>
<b class="fc">&nbsp;		m_reservedPointCount = -1;// we need to recreate the new attribute then</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyAll);</b>
&nbsp;	}
&nbsp;	
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	protected void _updateEnvelope(Envelope2D env) {
<b class="fc">&nbsp;		_updateAllDirtyIntervals(true);</b>
<b class="fc">&nbsp;		m_envelope.queryEnvelope2D(env);</b>
&nbsp;	} // note: overload for polylines/polygons with curves
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	protected void _updateEnvelope(Envelope3D env) {
<b class="nc">&nbsp;		_updateAllDirtyIntervals(true);</b>
<b class="nc">&nbsp;		m_envelope.queryEnvelope3D(env);</b>
&nbsp;	} // note: overload for polylines/polygons with curves
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	protected void _updateLooseEnvelope(Envelope2D env) {
&nbsp;		// TODO ROHIT has this set to true?
<b class="fc">&nbsp;		_updateAllDirtyIntervals(false);</b>
<b class="fc">&nbsp;		m_envelope.queryEnvelope2D(env);</b>
&nbsp;	} // note: overload for polylines/polygons with curves
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	/**
&nbsp;	 * \internal Calculates loose envelope. Returns True if the calculation
&nbsp;	 * renders exact envelope.
&nbsp;	 */
&nbsp;	protected void _updateLooseEnvelope(Envelope3D env) {
&nbsp;		// TODO ROHIT has this set to true?
<b class="nc">&nbsp;		_updateAllDirtyIntervals(false);</b>
<b class="nc">&nbsp;		m_envelope.queryEnvelope3D(env);</b>
&nbsp;	} // note: overload for polylines/polygons with curves
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void queryEnvelope(Envelope env) {
<b class="fc">&nbsp;		_updateAllDirtyIntervals(true);</b>
<b class="fc">&nbsp;		m_envelope.copyTo(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	// TODO rename to remove 2D
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public void queryEnvelope2D(Envelope2D env) {
<b class="fc">&nbsp;		_updateEnvelope(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	// TODO rename to remove 3D
&nbsp;	@Override
&nbsp;	public void queryEnvelope3D(Envelope3D env) {
<b class="nc">&nbsp;		_updateEnvelope(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	// TODO rename to remove 2D
&nbsp;	@Override
&nbsp;	public void queryLooseEnvelope2D(Envelope2D env) {
<b class="fc">&nbsp;		_updateLooseEnvelope(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	// TODO rename to remove 3D
&nbsp;	@Override
&nbsp;	public void queryLooseEnvelope3D(Envelope3D env) {
<b class="nc">&nbsp;		_updateLooseEnvelope(env);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public Envelope1D queryInterval(int semantics, int ordinate) {
<b class="fc">&nbsp;		Envelope1D env = new Envelope1D();</b>
<b class="fc">&nbsp;		if (isEmptyImpl()) {</b>
<b class="nc">&nbsp;			env.setEmpty();</b>
<b class="nc">&nbsp;			return env;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		_updateAllDirtyIntervals(true);</b>
<b class="fc">&nbsp;		return m_envelope.queryInterval(semantics, ordinate);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	// TODO Rename to getHashCode
&nbsp;	@Override
&nbsp;	public int hashCode() {
<b class="fc">&nbsp;		int hashCode = m_description.hashCode();</b>
&nbsp;
<b class="fc">&nbsp;		if (!isEmptyImpl()) {</b>
<b class="nc">&nbsp;			int pointCount = getPointCount();</b>
<b class="nc">&nbsp;			for (int i = 0, n = m_description.getAttributeCount(); i &lt; n; i++) {</b>
<b class="nc">&nbsp;				int components = VertexDescription</b>
<b class="nc">&nbsp;						.getComponentCount(m_description._getSemanticsImpl(i));</b>
<b class="nc">&nbsp;				AttributeStreamBase stream = m_vertexAttributes[i];</b>
<b class="nc">&nbsp;				hashCode = stream.calculateHashImpl(hashCode, 0, pointCount</b>
&nbsp;						* components);
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return hashCode;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	@Override
&nbsp;	public boolean equals(Object other) {
&nbsp;		// Java checks
<b class="fc">&nbsp;		if (other == this)</b>
<b class="nc">&nbsp;			return true;</b>
&nbsp;
<b class="fc">&nbsp;		if (!(other instanceof MultiVertexGeometryImpl))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		MultiVertexGeometryImpl otherMulti = (MultiVertexGeometryImpl) other;</b>
&nbsp;
<b class="fc">&nbsp;		if (!(m_description.equals(otherMulti.m_description)))</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (isEmptyImpl() != otherMulti.isEmptyImpl())</b>
<b class="nc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		if (isEmptyImpl())</b>
<b class="fc">&nbsp;			return true; // both geometries are empty</b>
&nbsp;
<b class="fc">&nbsp;		int pointCount = getPointCount();</b>
<b class="fc">&nbsp;		int pointCountOther = otherMulti.getPointCount();</b>
&nbsp;
<b class="fc">&nbsp;		if (pointCount != pointCountOther)</b>
<b class="fc">&nbsp;			return false;</b>
&nbsp;
<b class="fc">&nbsp;		for (int i = 0; i &lt; m_description.getAttributeCount(); i++) {</b>
<b class="fc">&nbsp;			int semantics = m_description.getSemantics(i);</b>
&nbsp;
<b class="fc">&nbsp;			AttributeStreamBase stream = getAttributeStreamRef(semantics);</b>
<b class="fc">&nbsp;			AttributeStreamBase streamOther = otherMulti</b>
<b class="fc">&nbsp;					.getAttributeStreamRef(semantics);</b>
&nbsp;
<b class="fc">&nbsp;			int components = VertexDescription.getComponentCount(semantics);</b>
&nbsp;
<b class="fc">&nbsp;			if (!stream.equals(streamOther, 0, pointCount * components))</b>
<b class="nc">&nbsp;				return false;</b>
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		return true;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	/**
&nbsp;	 * Sets the envelope of the Geometry. The Envelope description must match
&nbsp;	 * that of the Geometry.
&nbsp;	 */
&nbsp;	public void setEnvelope(Envelope env) {
<b class="fc">&nbsp;		if (!m_description.equals(env.getDescription()))</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
&nbsp;		// m_envelope = (Envelope) env.clone();
<b class="fc">&nbsp;		m_envelope = (Envelope) env.createInstance();</b>
<b class="fc">&nbsp;		env.copyTo(m_envelope);</b>
<b class="fc">&nbsp;		_setDirtyFlag(DirtyFlags.DirtyIntervals, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void copyTo(Geometry dstGeom) {
<b class="fc">&nbsp;		MultiVertexGeometryImpl dst = (MultiVertexGeometryImpl) dstGeom;</b>
<b class="fc">&nbsp;		if (dst.getType() != getType())</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;		
<b class="fc">&nbsp;		_copyToUnsafe(dst);</b>
&nbsp;	}
&nbsp;	
&nbsp;	//Does not check geometry type. Used to copy Polygon to Polyline
&nbsp;	void _copyToUnsafe(MultiVertexGeometryImpl dst) {
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		dst.m_description = m_description;</b>
<b class="fc">&nbsp;		dst.m_vertexAttributes = null;</b>
<b class="fc">&nbsp;		int nattrib = m_description.getAttributeCount();</b>
<b class="fc">&nbsp;		AttributeStreamBase[] cloneAttributes = null;</b>
<b class="fc">&nbsp;		if (m_vertexAttributes != null) {</b>
<b class="fc">&nbsp;			cloneAttributes = new AttributeStreamBase[nattrib];</b>
<b class="fc">&nbsp;			for (int i = 0; i &lt; nattrib; i++) {</b>
<b class="fc">&nbsp;				if (m_vertexAttributes[i] != null) {</b>
<b class="fc">&nbsp;					int ncomps = VertexDescription</b>
<b class="fc">&nbsp;							.getComponentCount(m_description</b>
<b class="fc">&nbsp;									._getSemanticsImpl(i));</b>
<b class="fc">&nbsp;					cloneAttributes[i] = m_vertexAttributes[i]</b>
<b class="fc">&nbsp;							.restrictedClone(getPointCount() * ncomps);</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
&nbsp;
<b class="fc">&nbsp;		if (m_envelope != null) {</b>
<b class="fc">&nbsp;			dst.m_envelope = (Envelope) m_envelope.createInstance();</b>
<b class="fc">&nbsp;			m_envelope.copyTo(dst.m_envelope);</b>
&nbsp;			// dst.m_envelope = (Envelope) m_envelope.clone();
&nbsp;		} else
<b class="fc">&nbsp;			dst.m_envelope = null;</b>
&nbsp;
<b class="fc">&nbsp;		dst.m_pointCount = m_pointCount;</b>
<b class="fc">&nbsp;		dst.m_flagsMask = m_flagsMask;</b>
<b class="fc">&nbsp;		dst.m_vertexAttributes = cloneAttributes;</b>
&nbsp;
&nbsp;		try {
<b class="fc">&nbsp;			_copyToImpl(dst); // copy child props</b>
<b class="nc">&nbsp;		} catch (Exception ex) {</b>
<b class="nc">&nbsp;			dst.setEmpty();</b>
<b class="nc">&nbsp;			throw new RuntimeException(ex);</b>
<b class="fc">&nbsp;		}</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	public boolean _attributeStreamIsAllocated(int semantics) {
<b class="fc">&nbsp;		throwIfEmpty();</b>
&nbsp;
<b class="fc">&nbsp;		int attributeIndex = m_description.getAttributeIndex(semantics);</b>
&nbsp;
<b class="fc">&nbsp;		if (attributeIndex &gt;= 0 &amp;&amp; m_vertexAttributes[attributeIndex] != null)</b>
<b class="fc">&nbsp;			return true;</b>
&nbsp;
<b class="nc">&nbsp;		return false;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	void _setEmptyImpl() {
<b class="fc">&nbsp;		m_pointCount = 0;</b>
<b class="fc">&nbsp;		m_reservedPointCount = -1;</b>
<b class="fc">&nbsp;		m_vertexAttributes = null;// release it all streams.</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyAll);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	/**
&nbsp;	 * Notifies the Geometry of changes made to the vertices so that it could
&nbsp;	 * reset cached structures.
&nbsp;	 */
&nbsp;	public void notifyModified(int flags) {
<b class="fc">&nbsp;		if (flags == DirtyFlags.DirtyAll) {</b>
<b class="fc">&nbsp;			m_reservedPointCount = -1;// forget the reserved point number</b>
<b class="fc">&nbsp;			_notifyModifiedAllImpl();</b>
&nbsp;		}
<b class="fc">&nbsp;		m_flagsMask |= flags;</b>
&nbsp;
<b class="fc">&nbsp;		_clearAccelerators();</b>
<b class="fc">&nbsp;		_touch();</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	/**
&nbsp;	 * @param bExact
&nbsp;	 *            True, when the exact envelope need to be calculated and false
&nbsp;	 *            for the loose one.
&nbsp;	 */
&nbsp;	protected void _updateAllDirtyIntervals(boolean bExact) {
<b class="fc">&nbsp;		_verifyAllStreams();</b>
<b class="fc">&nbsp;		if (_hasDirtyFlag(DirtyFlags.DirtyIntervals)) {</b>
<b class="fc">&nbsp;			if (null == m_envelope)</b>
<b class="fc">&nbsp;				m_envelope = new Envelope(m_description);</b>
&nbsp;			else
<b class="fc">&nbsp;				m_envelope.assignVertexDescription(m_description);</b>
&nbsp;
<b class="fc">&nbsp;			if (isEmpty()) {</b>
<b class="fc">&nbsp;				m_envelope.setEmpty();</b>
&nbsp;				return;
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			_updateXYImpl(bExact);// efficient method for xy&#39;s</b>
&nbsp;			// now go through other attribues.
<b class="fc">&nbsp;			for (int attributeIndex = 1; attributeIndex &lt; m_description</b>
<b class="fc">&nbsp;					.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;				int semantics = m_description._getSemanticsImpl(attributeIndex);</b>
<b class="fc">&nbsp;				int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;				AttributeStreamBase stream = m_vertexAttributes[attributeIndex];</b>
<b class="fc">&nbsp;				for (int iord = 0; iord &lt; ncomps; iord++) {</b>
<b class="fc">&nbsp;					Envelope1D interval = new Envelope1D();</b>
<b class="fc">&nbsp;					interval.setEmpty();</b>
<b class="fc">&nbsp;					for (int i = 0; i &lt; m_pointCount; i++) {</b>
<b class="fc">&nbsp;						double value = stream.readAsDbl(i * ncomps + iord);// some</b>
&nbsp;																			// optimization
&nbsp;																			// is
&nbsp;																			// possible
&nbsp;																			// if
&nbsp;																			// non-virtual
&nbsp;																			// method
&nbsp;																			// is
&nbsp;																			// used
<b class="fc">&nbsp;						interval.merge(value);</b>
&nbsp;					}
<b class="fc">&nbsp;					m_envelope.setInterval(semantics, iord, interval);</b>
&nbsp;				}
&nbsp;			}
<b class="fc">&nbsp;			if (bExact)</b>
<b class="fc">&nbsp;				_setDirtyFlag(DirtyFlags.DirtyIntervals, false);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	/**
&nbsp;	 * \internal Updates x, y intervals.
&nbsp;	 */
&nbsp;	public void _updateXYImpl(boolean bExact) {
<b class="fc">&nbsp;		m_envelope.setEmpty();</b>
<b class="fc">&nbsp;		AttributeStreamOfDbl stream = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="fc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="fc">&nbsp;		for (int i = 0; i &lt; m_pointCount; i++) {</b>
<b class="fc">&nbsp;			stream.read(2 * i, pt);</b>
<b class="fc">&nbsp;			m_envelope.merge(pt);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	void calculateEnvelope2D(Envelope2D env, boolean bExact) {
<b class="nc">&nbsp;		env.setEmpty();</b>
<b class="nc">&nbsp;		AttributeStreamOfDbl stream = (AttributeStreamOfDbl) m_vertexAttributes[0];</b>
<b class="nc">&nbsp;		Point2D pt = new Point2D();</b>
<b class="nc">&nbsp;		for (int i = 0; i &lt; m_pointCount; i++) {</b>
<b class="nc">&nbsp;			stream.read(2 * i, pt);</b>
<b class="nc">&nbsp;			env.merge(pt);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011 lots of changes
&nbsp;	/**
&nbsp;	 * \internal Verifies all streams (calls _VerifyStream for every attribute).
&nbsp;	 */
&nbsp;	protected void _verifyAllStreamsImpl() {
&nbsp;		// This method checks that the streams are of correct size.
&nbsp;		// It resizes the streams to ensure they are not shorter than
&nbsp;		// m_PointCount
&nbsp;		// _ASSERT(_HasDirtyFlag(enum_value1(DirtyFlags,
&nbsp;		// DirtyVerifiedStreams)));
<b class="fc">&nbsp;		if (m_reservedPointCount &lt; m_pointCount) // an optimization to skip this</b>
&nbsp;													// expensive loop when
&nbsp;													// adding point by point
&nbsp;		{
<b class="fc">&nbsp;			if (m_vertexAttributes == null)</b>
<b class="fc">&nbsp;				m_vertexAttributes = new AttributeStreamBase[m_description</b>
<b class="fc">&nbsp;						.getAttributeCount()];</b>
&nbsp;
<b class="fc">&nbsp;			m_reservedPointCount = NumberUtils.intMax();</b>
<b class="fc">&nbsp;			for (int attributeIndex = 0; attributeIndex &lt; m_description</b>
<b class="fc">&nbsp;					.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;				int semantics = m_description._getSemanticsImpl(attributeIndex);</b>
<b class="fc">&nbsp;				if (m_vertexAttributes[attributeIndex] != null) {</b>
<b class="fc">&nbsp;					int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;					int size = m_vertexAttributes[attributeIndex].virtualSize()</b>
&nbsp;							/ ncomp;
<b class="fc">&nbsp;					if (size &lt; m_pointCount) {</b>
<b class="fc">&nbsp;						size = (m_reservedPointCount &gt; m_pointCount + 5) ? (m_pointCount * 5 + 3) / 4</b>
<b class="fc">&nbsp;								: m_pointCount;// reserve 25% more than user</b>
&nbsp;												// asks
<b class="fc">&nbsp;						m_vertexAttributes[attributeIndex].resize(size * ncomp,</b>
<b class="fc">&nbsp;								VertexDescription.getDefaultValue(semantics));</b>
&nbsp;					}
&nbsp;
<b class="fc">&nbsp;					if (size &lt; m_reservedPointCount)</b>
<b class="fc">&nbsp;						m_reservedPointCount = size;</b>
<b class="fc">&nbsp;				} else {</b>
<b class="fc">&nbsp;					m_vertexAttributes[attributeIndex] = AttributeStreamBase</b>
<b class="fc">&nbsp;							.createAttributeStreamWithSemantics(semantics,</b>
&nbsp;									m_pointCount);
<b class="fc">&nbsp;					m_reservedPointCount = m_pointCount;</b>
&nbsp;				}
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		_verifyStreamsImpl();</b>
&nbsp;
<b class="fc">&nbsp;		_setDirtyFlag(DirtyFlags.DirtyVerifiedStreams, false);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	void _resizeImpl(int pointCount) {
<b class="fc">&nbsp;		if (pointCount &lt; 0)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		if (pointCount == m_pointCount)</b>
&nbsp;			return;
&nbsp;
<b class="fc">&nbsp;		m_pointCount = pointCount;</b>
<b class="fc">&nbsp;		notifyModified(DirtyFlags.DirtyAllInternal);</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	int queryCoordinates(Point2D[] dst, int dstSize, int beginIndex,
&nbsp;			int endIndex) {
<b class="nc">&nbsp;		int endIndexC = endIndex &lt; 0 ? m_pointCount : endIndex;</b>
<b class="nc">&nbsp;		endIndexC = Math.min(endIndexC, beginIndex + dstSize);</b>
&nbsp;
<b class="nc">&nbsp;		if (beginIndex &lt; 0 || beginIndex &gt;= m_pointCount</b>
&nbsp;				|| endIndexC &lt; beginIndex)
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		AttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</b>
<b class="nc">&nbsp;		int j = 0;</b>
<b class="nc">&nbsp;		double[] dstArray = new double[dst.length * 2];</b>
<b class="nc">&nbsp;		xy.readRange(2 * beginIndex, (endIndexC - beginIndex) * 2, dstArray, j, true);</b>
&nbsp;
<b class="nc">&nbsp;		for (int i = 0; i &lt; dst.length; i++) {</b>
<b class="nc">&nbsp;			dst[i] = new Point2D(dstArray[i * 2], dstArray[i * 2 + 1]);</b>
&nbsp;		}
&nbsp;
&nbsp;		// for (int i = beginIndex; i &lt; endIndexC; i++, j++)
&nbsp;		// {
&nbsp;		// xy.read(2 * i, dst[j]);
&nbsp;		// }
&nbsp;
<b class="nc">&nbsp;		return endIndexC;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	int QueryCoordinates(Point3D[] dst, int dstSize, int beginIndex,
&nbsp;			int endIndex) {
<b class="nc">&nbsp;		int endIndexC = endIndex &lt; 0 ? m_pointCount : endIndex;</b>
<b class="nc">&nbsp;		endIndexC = Math.min(endIndexC, beginIndex + dstSize);</b>
&nbsp;
<b class="nc">&nbsp;		if (beginIndex &lt; 0 || beginIndex &gt;= m_pointCount</b>
&nbsp;				|| endIndexC &lt; beginIndex)
&nbsp;			// TODO replace geometry exc
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="nc">&nbsp;		AttributeStreamOfDbl xy = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.POSITION);</b>
<b class="nc">&nbsp;		AttributeStreamOfDbl z = null;</b>
<b class="nc">&nbsp;		double v = VertexDescription</b>
<b class="nc">&nbsp;				.getDefaultValue(VertexDescription.Semantics.Z);</b>
<b class="nc">&nbsp;		boolean bHasZ = hasAttribute(VertexDescription.Semantics.Z);</b>
<b class="nc">&nbsp;		if (bHasZ)</b>
<b class="nc">&nbsp;			z = (AttributeStreamOfDbl) getAttributeStreamRef(VertexDescription.Semantics.Z);</b>
<b class="nc">&nbsp;		int j = 0;</b>
<b class="nc">&nbsp;		for (int i = beginIndex; i &lt; endIndexC; i++, j++) {</b>
<b class="nc">&nbsp;			dst[j].x = xy.read(2 * i);</b>
<b class="nc">&nbsp;			dst[j].y = xy.read(2 * i + 1);</b>
<b class="nc">&nbsp;			dst[j].z = bHasZ ? z.read(i) : v;</b>
&nbsp;
<b class="nc">&nbsp;			dst[j] = getXYZ(i);</b>
&nbsp;		}
&nbsp;
<b class="nc">&nbsp;		return endIndexC;</b>
&nbsp;	}
&nbsp;
&nbsp;	// Checked vs. Jan 11, 2011
&nbsp;	// -1 : DirtySimple is true (whether or not the MultiPath is Simple is
&nbsp;	// unknown)
&nbsp;	// 0 : DirtySimple is false and the MultiPath is not Weak Simple
&nbsp;	// 1 : DirtySimple is false and the MultiPath is Weak Simple but not ring
&nbsp;	// ordering may be invalid
&nbsp;	// 2 : DirtySimple is false and the MultiPath is Strong Simple (Weak Simple
&nbsp;	// and valid ring ordering)
&nbsp;	public int getIsSimple(double tolerance) {
<b class="fc">&nbsp;		if (!_hasDirtyFlag(DirtyFlags.DirtyIsKnownSimple)) {</b>
<b class="fc">&nbsp;			if (!_hasDirtyFlag(DirtyFlags.IsWeakSimple)) {</b>
<b class="fc">&nbsp;				return 0;</b>
&nbsp;			}
<b class="fc">&nbsp;			if (m_simpleTolerance &gt;= tolerance) {</b>
<b class="fc">&nbsp;				if (!_hasDirtyFlag(DirtyFlags.DirtyOGCFlags))</b>
<b class="fc">&nbsp;					return 2;</b>
&nbsp;
<b class="fc">&nbsp;				return 1;</b>
&nbsp;			}
&nbsp;
<b class="fc">&nbsp;			return -1;</b>
&nbsp;		}
<b class="fc">&nbsp;		return -1;</b>
&nbsp;	}
&nbsp;
&nbsp;	void setIsSimple(int isSimpleRes, double tolerance, boolean ogc_known) {
<b class="fc">&nbsp;		m_simpleTolerance = tolerance;</b>
<b class="fc">&nbsp;		if (isSimpleRes == GeometryXSimple.Unknown) {</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.DirtyIsKnownSimple, true);</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.DirtyOGCFlags, true);</b>
&nbsp;			return;
&nbsp;		}
<b class="fc">&nbsp;		_setDirtyFlag(DirtyFlags.DirtyIsKnownSimple, false);</b>
&nbsp;
<b class="fc">&nbsp;		if (!ogc_known)</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.DirtyOGCFlags, true);</b>
&nbsp;
<b class="fc">&nbsp;		if (isSimpleRes == GeometryXSimple.Not) {</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsWeakSimple, false);</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsStrongSimple, false);</b>
<b class="fc">&nbsp;		} else if (isSimpleRes == GeometryXSimple.Weak) {</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsWeakSimple, true);</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsStrongSimple, false);</b>
<b class="fc">&nbsp;		} else if (isSimpleRes == GeometryXSimple.Strong) {</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsWeakSimple, true);</b>
<b class="fc">&nbsp;			_setDirtyFlag(DirtyFlags.IsStrongSimple, true);</b>
&nbsp;		} else
<b class="nc">&nbsp;			throw GeometryException.GeometryInternalError();// what?</b>
&nbsp;	}
&nbsp;
&nbsp;	double _getSimpleTolerance() {
<b class="nc">&nbsp;		return m_simpleTolerance;</b>
&nbsp;	}
&nbsp;
&nbsp;	public GeometryAccelerators _getAccelerators() {
<b class="fc">&nbsp;		return m_accelerators;</b>
&nbsp;	}
&nbsp;
&nbsp;	void _clearAccelerators() {
<b class="fc">&nbsp;		if (m_accelerators != null)</b>
<b class="fc">&nbsp;			m_accelerators = null;</b>
&nbsp;	}
&nbsp;
&nbsp;	void _interpolateTwoVertices(int vertex1, int vertex2, double f,
&nbsp;			Point outPoint) {
<b class="fc">&nbsp;		if (vertex1 &lt; 0 || vertex1 &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds.&quot;);</b>
<b class="fc">&nbsp;		if (vertex2 &lt; 0 || vertex2 &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new GeometryException(&quot;index out of bounds.&quot;);</b>
&nbsp;
&nbsp;		// _ASSERT(!IsEmpty());
&nbsp;		// _ASSERT(m_vertexAttributes != NULLPTR);
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
<b class="fc">&nbsp;		outPoint.assignVertexDescription(m_description);</b>
<b class="fc">&nbsp;		for (int attributeIndex = 0; attributeIndex &lt; m_description</b>
<b class="fc">&nbsp;				.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;			int semantics = m_description._getSemanticsImpl(attributeIndex);</b>
<b class="fc">&nbsp;			for (int icomp = 0, ncomp = VertexDescription</b>
<b class="fc">&nbsp;					.getComponentCount(semantics); icomp &lt; ncomp; icomp++) {</b>
<b class="fc">&nbsp;				double v1 = m_vertexAttributes[attributeIndex].readAsDbl(ncomp</b>
&nbsp;						* vertex1 + icomp);
<b class="fc">&nbsp;				double v2 = m_vertexAttributes[attributeIndex].readAsDbl(ncomp</b>
&nbsp;						* vertex2 + icomp);
<b class="fc">&nbsp;				outPoint.setAttribute(semantics, icomp, MathUtils.lerp(v1,  v2,  f));</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	double _getShortestDistance(int vertex1, int vertex2) {
<b class="fc">&nbsp;		Point2D pt = getXY(vertex1);</b>
<b class="fc">&nbsp;		pt.sub(getXY(vertex2));</b>
<b class="fc">&nbsp;		return pt.length();</b>
&nbsp;	}
&nbsp;
&nbsp;	// ////////////////// METHODS To REMOVE ///////////////////////
&nbsp;	@Override
&nbsp;	public Point getPoint(int index) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();</b>
&nbsp;
<b class="fc">&nbsp;		Point outPoint = new Point();</b>
<b class="fc">&nbsp;		outPoint.assignVertexDescription(m_description);</b>
&nbsp;
<b class="fc">&nbsp;		for (int attributeIndex = 0; attributeIndex &lt; m_description</b>
<b class="fc">&nbsp;				.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;			int semantics = m_description.getSemantics(attributeIndex);</b>
<b class="fc">&nbsp;			for (int icomp = 0, ncomp = VertexDescription</b>
<b class="fc">&nbsp;					.getComponentCount(semantics); icomp &lt; ncomp; icomp++) {</b>
<b class="fc">&nbsp;				double v = m_vertexAttributes[attributeIndex].readAsDbl(ncomp</b>
&nbsp;						* index + icomp);
<b class="fc">&nbsp;				outPoint.setAttribute(semantics, icomp, v);</b>
&nbsp;			}
&nbsp;		}
<b class="fc">&nbsp;		return outPoint;</b>
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void setPoint(int index, Point src) {
<b class="fc">&nbsp;		if (index &lt; 0 || index &gt;= m_pointCount)</b>
<b class="nc">&nbsp;			throw new IndexOutOfBoundsException();</b>
&nbsp;
<b class="fc">&nbsp;		Point point = src;</b>
&nbsp;
<b class="fc">&nbsp;		if (src.isEmpty())// can not assign an empty point to a multipoint</b>
&nbsp;							// vertex
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
<b class="fc">&nbsp;		_verifyAllStreams();// verify all allocated streams are of necessary</b>
&nbsp;							// size.
<b class="fc">&nbsp;		VertexDescription vdin = point.getDescription();</b>
<b class="fc">&nbsp;		for (int attributeIndex = 0; attributeIndex &lt; vdin.getAttributeCount(); attributeIndex++) {</b>
<b class="fc">&nbsp;			int semantics = vdin.getSemantics(attributeIndex);</b>
<b class="fc">&nbsp;			int ncomp = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;			for (int icomp = 0; icomp &lt; ncomp; icomp++) {</b>
<b class="fc">&nbsp;				double v = point.getAttributeAsDbl(semantics, icomp);</b>
<b class="fc">&nbsp;				setAttribute(semantics, index, icomp, v);</b>
&nbsp;			}
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void queryCoordinates(Point[] dst) {
<b class="nc">&nbsp;		int sz = m_pointCount;</b>
<b class="nc">&nbsp;		if (dst.length &lt; sz)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
&nbsp;		// TODO: refactor to a better AttributeAray call (ReadRange?)
<b class="nc">&nbsp;		for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;			dst[i] = getPoint(i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void queryCoordinates(Point2D[] dst) {
<b class="fc">&nbsp;		int sz = m_pointCount;</b>
<b class="fc">&nbsp;		if (dst.length &lt; sz)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
&nbsp;		// TODO: refactor to a better AttributeAray call (ReadRange?)
<b class="fc">&nbsp;		for (int i = 0; i &lt; sz; i++) {</b>
<b class="fc">&nbsp;			dst[i] = getXY(i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;
&nbsp;	@Override
&nbsp;	public void queryCoordinates(Point3D[] dst) {
<b class="nc">&nbsp;		int sz = m_pointCount;</b>
<b class="nc">&nbsp;		if (dst.length &lt; sz)</b>
<b class="nc">&nbsp;			throw new IllegalArgumentException();</b>
&nbsp;
&nbsp;		// TODO: refactor to a better AttributeAray call (ReadRange?)
<b class="nc">&nbsp;		for (int i = 0; i &lt; sz; i++) {</b>
<b class="nc">&nbsp;			dst[i] = getXYZ(i);</b>
&nbsp;		}
&nbsp;	}
&nbsp;	
&nbsp;    @Override
&nbsp;    public void replaceNaNs(int semantics, double value) {
<b class="fc">&nbsp;    	addAttribute(semantics);</b>
<b class="fc">&nbsp;    	if (isEmpty())</b>
&nbsp;    		return;
&nbsp;    	
<b class="fc">&nbsp;    	boolean modified = false;</b>
<b class="fc">&nbsp;    	int ncomps = VertexDescription.getComponentCount(semantics);</b>
<b class="fc">&nbsp;    	for (int i = 0; i &lt; ncomps; i++) {</b>
<b class="fc">&nbsp;    		AttributeStreamBase streamBase = getAttributeStreamRef(semantics);</b>
<b class="fc">&nbsp;    		if (streamBase instanceof AttributeStreamOfDbl)	{</b>
<b class="fc">&nbsp;    			AttributeStreamOfDbl dblStream = (AttributeStreamOfDbl)streamBase;</b>
<b class="fc">&nbsp;    			for (int ivert = 0, n = m_pointCount * ncomps; ivert &lt; n; ivert++) {</b>
<b class="fc">&nbsp;    				double v = dblStream.read(ivert);</b>
<b class="fc">&nbsp;    				if (Double.isNaN(v)) {</b>
<b class="fc">&nbsp;    					dblStream.write(ivert, value);</b>
<b class="fc">&nbsp;    					modified = true;</b>
&nbsp;    				}
&nbsp;    			}
<b class="fc">&nbsp;    		}</b>
&nbsp;    		else {
<b class="nc">&nbsp;    			for (int ivert = 0, n = m_pointCount * ncomps; ivert &lt; n; ivert++) {</b>
<b class="nc">&nbsp;    				double v = streamBase.readAsDbl(ivert);</b>
<b class="nc">&nbsp;    				if (Double.isNaN(v)) {</b>
<b class="nc">&nbsp;    					streamBase.writeAsDbl(ivert, value);</b>
<b class="nc">&nbsp;    					modified = true;</b>
&nbsp;    				}
&nbsp;    			}
&nbsp;    		}
&nbsp;    	}
&nbsp;    	
<b class="fc">&nbsp;    	if (modified) {</b>
<b class="fc">&nbsp;    		notifyModified(DirtyFlags.DirtyCoordinates);</b>
&nbsp;    	}
&nbsp;    }
&nbsp;
&nbsp;	public abstract boolean _buildRasterizedGeometryAccelerator(
&nbsp;			double toleranceXY, GeometryAccelerationDegree accelDegree);
&nbsp;
&nbsp;	public abstract boolean _buildQuadTreeAccelerator(
&nbsp;			GeometryAccelerationDegree d);
&nbsp;
&nbsp;	@Override
&nbsp;	public String toString() {
<b class="nc">&nbsp;		return &quot;MultiVertexGeometryImpl&quot;;</b>
&nbsp;	}	
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-02-21 16:04</div>
</div>
</body>
</html>
